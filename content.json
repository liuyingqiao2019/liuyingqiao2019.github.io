{"meta":{"title":"唐抉的个人博客","subtitle":"","description":"","author":"唐抉","url":"http://tangmenjue.top","root":"/"},"pages":[{"title":"","date":"2022-10-14T16:57:02.036Z","updated":"2022-10-14T16:57:02.032Z","comments":true,"path":"baidu_verify_code-8gDDgBH4x7.html","permalink":"http://tangmenjue.top/baidu_verify_code-8gDDgBH4x7.html","excerpt":"","text":"layout:false 701d7ecfb72299010fa6c733b074a57e"},{"title":"About","date":"2022-11-12T03:08:00.000Z","updated":"2022-12-24T12:25:49.205Z","comments":true,"path":"about/index.html","permalink":"http://tangmenjue.top/about/index.html","excerpt":"","text":"&lt;img src=&quot;https://rishavanand.github.io/static/images/greetings.gif&quot; align=&quot;center&quot; style=&quot;width: 100%&quot; /&gt; # 👋 Hey！I'm Tangmenjue 🐱 About Me 🐈 I like to explore new technologies and develop software solutions. 🖥️ I'm currently working on software development engineer at China Telecom Stocks Co.,Ltd. 🌱 I'm track for learning more about Artificial Intelligence and Software Design. ✍️ In my free time, I pursue Blog Writing as hobbies. 💬 You can shoot me an email at tangmenjue@foxmail.com! I'll try to respond as soon as I can 😃 Please have a look at my Blog for more details about me. I'm open to feedback and suggesttions! 🛠️ Tech Stack DeepLearning Frontend Backend DevOps ⚙️ Github Analytics"},{"title":"search","date":"2021-02-03T04:37:34.000Z","updated":"2021-02-03T04:37:34.996Z","comments":true,"path":"search/index.html","permalink":"http://tangmenjue.top/search/index.html","excerpt":"","text":""}],"posts":[{"title":"YAML与Redis的基本运用","slug":"YAML与Redis的基本运用","date":"2022-12-16T07:08:50.000Z","updated":"2022-12-18T14:09:40.238Z","comments":true,"path":"2022/12/16/YAML与Redis的基本运用/","link":"","permalink":"http://tangmenjue.top/2022/12/16/YAML%E4%B8%8ERedis%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/","excerpt":"","text":"YAML YAML是一种数据序列化语言而不是标记语言，其语法比较简洁直观，特点是使用空格来表达层次结构，其最大的优势是在数据结构的表达上，且能配合大多数编程语言使用，因此YAML更多应用于配置文件的编写，其文件一般以.yml为后缀。 由于其语法的特殊性，没有编辑器可能容易写错，因而在此推荐一个无广告的yaml在线格式化网站：JS-YAML，其可以直接将yaml转化为json。 基础语法 YAML对大小写敏感 YAML用#表示注释，且只支持单行注释 用缩进表示层级关系 缩进只能使用空格，不能用TAB字符 缩进的空格数量不做要求，但要求同一层级的元素左侧必须对齐 一个文件中可以包含多个文件的内容 用三个破折号\"---\"表示一份内容的开始 用三个小数点\"...\"表示一份内容的结束（非强制） 123456789101112131415---# 这是第一份内容one:1# 其他内容...---# 这是第二份内容two:2# 其他内容# 第一份内容转换结果如下：# 'one:1'# 第二份内容转换结果如下：# 'two:2' 数据结构与类型 对象 用来表示以键值对（key:value）形式出现的数据。 使用“冒号+空格”来分开键与值，对应JSON中的\"key\"：\"value\" 12345#yamlkey:value# 内容转换结果如下： # 'key:value' 支持多层嵌套（用缩进表示层级关系） 123456key: child-key1:value1 child-key2:value2 # 内容转换结果如下： # &#123; key: 'child-key1:value1 child-key2:value2' &#125; 支持用花括号包裹，逗号加空格分隔的流式风格语法： 1234key:&#123; child-key1:value1, child-key2:value2 &#125;# 内容转换结果如下： # 'key:&#123; child-key1:value1, child-key2:value2 &#125;' 用问号声明一个复杂对象，且允许使用多个词汇（数组）来组成键： 123456789? - keypart1 - keypart2: - value1 - value2 # 内容转换结果如下：# &#123; 'keypart1,keypart2': [ 'value1', 'value2' ] &#125; 数组 一组以破折号+空格的区块形式为开头的数据便组成了一个数组： 1234567values: - value1 - value2 - value3 # 内容转换结果如下：# &#123; values: [ 'value1', 'value2', 'value3' ] &#125; 与此同时也支持用方括号包裹、逗号加空格分隔的内联格式来表达 1234values:[value1, value2, value3]# 内容转换结果如下：# 'values:[value1, value2, value3]' 支持多为数组（用缩进表示层级关系） 12345678910values: - - value1 - value2 - - value3 - value4 # 内容转换结果如下：# &#123; values: [ [ 'value1', 'value2' ], [ 'value3', 'value4' ] ] &#125; 标量 表示YAML中最基本的数据类型 字符串 字符串一般不需要引号包裹，但是如果字符串中使用了反斜杠\"\\\"开头的转义字符就必须使用引号包裹 12345678910111213141516171819strings: - Hello without quote # 不用引号包裹 - Hello world #拆成多行后会自动在中间添加空格 - 'Hello with single quotes' # 单引号包裹 - \"Hello with double quotes\" # 双引号包裹 - \"I am fine. \\u263A\" # 使用双引号包裹时支持Unicode编码 - \"\\x0d\\x0a is \\r\\n\" # 使用双引号包裹时还支持Hex编码 - 'He said: \"Hello!\"' # 单双引号支持嵌套# 内容转换结果如下： # &#123; strings: # [ 'Hello without quote',# 'Hello world',# 'Hello with single quotes',# 'Hello with double quotes',# 'I am fine. ☺',# '\\r\\n is \\r\\n',# 'He said: \"Hello!\"' ] &#125; 对于多行的文字，YAML提供了两种特殊的语法支持 保留换行 使用竖线符\"|\"来表示该语法，每行的缩进和行尾空白都会被去掉，而额外的缩进会被保留 123456789lines: | 我是第一行 我是第二行 我是第三行 我是第四行 我是第五行 # 内容转换结果如下： # &#123; lines: '我是第一行\\n我是第二行\\n 我是第三行\\n 我是第四行\\n我是第五行 \\n' &#125; 折叠换行 使用右尖括号\"&gt;\"来表示该语法，只有空白行才会被识别为换行，原来的换行符都会被转换成空格 1234567891011lines: &gt; 我是第一行 我也是第一行 我还是第一行 我仍然是第一行 我是第二行 我也是第二行 # 内容转换结果如下： # &#123; lines: '我是第一行 我也是第一行 我还是第一行 我仍然是第一行\\n我是第二行 我也是第二行\\n' &#125; 布尔值 \"true\"、\"True\"、\"TRUE\"、\"yes\"、\"Yes\"和“YES\"皆为真 \"false\"、\"False\"、\"FALSE\"、\"no\"、\"No\"和“NO\"皆为假 12345678boolean: - true # True、TRUE - yes # Yes、YES - false # False、FALSE - no # No、NO # 内容转换结果如下：# &#123; boolean: [ true, 'yes', false, 'no' ] &#125; 整数 支持二进制表示 123456int: - 666 - 0001_0000 #二进制表示 # 内容转换结果如下：# &#123; int: [ 666, 10000 ] &#125; 浮点数 支持科学计数法 123456float: - 3.14 - 6.8523015e+5 # 使用科学计数法 # 内容转换结果如下：# &#123; float: [ 3.14, 685230.15 ] &#125; 空值（Null） \"null\"、\"Null\"和\"~\"都是空，不指定值默认也是空 12345678nulls: - null - Null - ~ -# 内容转换结果如下：# &#123; nulls: [ null, null, null, null ] &#125; 时间戳 YAML也支持ISO 8601格式的时间数据 12345678910date1: 2020-05-26date2: 2020-05-26T01:00:00+08:00date3: 2020-05-26T02:00:00.10+08:00date4: 2020-05-26 03:00:00.10 +8# 内容转换结果如下：# &#123; date1: Tue May 26 2020 08:00:00 GMT+0800 (中国标准时间),# date2: Tue May 26 2020 01:00:00 GMT+0800 (中国标准时间),# date3: Tue May 26 2020 02:00:00 GMT+0800 (中国标准时间),# date4: Tue May 26 2020 03:00:00 GMT+0800 (中国标准时间) &#125; 类型转换 YAML支持使用严格类型标签的双感叹号+目标类型形式，即（\"!!\"）来强制转换类型 123456789a: !!float '666'b: '666'c: !!str 666d: !!str 666.66e: !!str truef: !!str yes# 内容转换结果如下：# &#123; a: 666, b: '666', c: '666', d: '666.66', e: 'true', f: 'yes' &#125; 其他高级类型 YAML也可以使用更高级的类型，但不一定兼容所有解析器，包括集合、有序映射、十六进制数据和二进制数据等 数据重用与合并 为了避免过多重复的定义，YAML提供了由锚点标签\"&amp;\"和引用标签\"*\"组成的语法，凭借此可以快速引用一些相同的数据 123456789a: &amp;anchor #设置锚点 one: 1 two: 2 three: 3b: *anchor #引用锚点 # 内容转换结果如下：# &#123; a: &#123; one: 1, two: 2, three: 3 &#125;,# b: &#123; one: 1, two: 2, three: 3 &#125; &#125; 配合合并标签\"&lt;&lt;\"使用可以与任意数据进行合并，以此实现类似于C++中继承的功能 123456789101112131415human: &amp;base # 添加名为base的锚点 body: 1 hair: 999singer: &lt;&lt;: *base # 引用base锚点，实例化时会自动展开 skill: sing # 添加额外的属性programer: &lt;&lt;: *base # 引用base锚点，实例化时会自动展开 hair: 6 # 复写base中的属性 skill: code # 添加额外的属性 # 内容转换结果如下：# &#123; human: &#123; body: 1, hair: 999 &#125;,# singer: &#123; body: 1, hair: 999, skill: 'sing' &#125;,# programer: &#123; body: 1, hair: 6, skill: 'code' &#125; &#125; Redis Redis是一个用C语言编写的、开源的、基于内存运行并支持持久化的、高性能的NoSQL数据库，具有支持数据持久化、支持多种数据结构、支持数据备份等特点，通常被称为数据结构服务器。 NoSQL数据库泛指非关系型数据库，其去掉了关系数据库的关系型特性，是为了解决大规模数据集合多重数据种类带来的问题而生。 Windows安装 Redis下载地址：点击前往 打开上述的下载地址后，可以在网页下方的Assets处看到目前支持的版本，找到最新的版本下载安装即可。 注：msi格式的为Windows的安装文件，双击即可进行安装，而zip包和tar.gz包则需要先解压再安装。 安装好后，需要着重关注以下几个文件： 文件名 作用 redis.windows.conf Redis 运行的配置文件。 redis-benchmark.exe Redis 性能测试的工具。 redis-check-aof.exe Redis 的 aof 文件修复的工具。 redis-check-dump.exe Redis 的 rdb 文件修复的工具。 redis-cli.exe Redis 的客户端。 redis-server.exe Redis 的服务端。 Redis数据类型 Redis支持五种数据类型：string（字符串）、hash（哈希）、list（列表）、set（集合）及zset（有序集合）。 String类型 string是Redis最基本的类型，一个key对应一个value（即键值对）。Redis的string可以包含任何数据，如jpg图片或序列化图像等，其一个键最大可以存储512MB的数据。 1234567891011#设置website值127.0.0.1:6379&gt; set website tangmenjue.topOK#获取website值127.0.0.1:6379&gt; get website\"tangmenjue.top\"#删除website值127.0.0.1:6379&gt; del website(integer) 1 Hash类型 hash是一个键值对集合，其是一个string类型的field和value的映射表，适合用于存储对象，每个hash可以存储 4294967295个键值对。 12345678910111213#设置一个对象webinfo，它的键webname对应的值为tangmenjue，键weburl对应的值为tangmenjue.top，webtype对应的类型为it127.0.0.1:6379&gt; hmset webinfo webname tangmenjue weburl tangmenjue.top webtype itOK#获取webinfo对象中，weburl、webname、webtype的键值127.0.0.1:6379&gt; hmget webinfo weburl webname webtype1) \"tangmenjue.top\"2) \"tangmenjue\"3) \"it\"#删除对象webinfo127.0.0.1:6379&gt; del webinfo(integer) 1 List类型 Redis的list类型是简单的字符串列表，按照插入顺序排序，可以添加一个元素到列表的左边或右边。 12345678910111213#向列表tangmenjue.top里添加Redis、Vue 和Pgsql3个元素127.0.0.1:6379&gt; lpush tangmenjue.top Redis Vue Pgsql(integer) 3#获取列表tangmenjue.top的下标从0到3的数据127.0.0.1:6379&gt; lrange tangmenjue.top 0 31) \"Pgsql\"2) \"Vue\"3) \"Redis\"#删除值127.0.0.1:6379&gt; del tangmenjue.top(integer) 1 Set类型 Redis的Set是string类型的无序集合，集合是通过哈希表来实现的，因此添加、删除、查找的复杂度都是O(1)。每个集合中最大可存储4294967295个成员。 12345678910111213141516171819202122#向集合tangmenjue.top添加Redis、Vue 和Pgsql3个元素127.0.0.1:6379&gt; sadd tangmenjue.top Redis Vue Pgsql(integer) 3#继续向集合tangmenjue.top添加元素Sqlserver，此时返回1表示成功127.0.0.1:6379&gt; sadd tangmenjue.top Sqlserver(integer) 1#继续向集合tangmenjue.top添加元素Redis，此时返回0表示失败。因为集合中已有Redis，不可重复插入127.0.0.1:6379&gt; sadd tangmenjue.top Redis(integer) 0#获取集合tangmenjue.top的所有元素127.0.0.1:6379&gt; smembers tangmenjue.top1) \"Pgsql\"2) \"Sqlserver\"3) \"Vue\"4) \"Redis\"#删除集合tangmenjue.top127.0.0.1:6379&gt; del tangmenjue.top(integer) 1 ZSet类型 zset和set一样也是string类型元素的集合且不允许成员重复。 与set不同的是，每个元素都会关联一个double类型的分数，通过这个分数来为集合中的成员按从大到小进行排序。zset成员是唯一的，但分数（score）是可以重复的。 1234567891011121314151617181920212223242526#向有序集合tangmenjue.top添加分数为0的Redis值127.0.0.1:6379&gt; zadd tangmenjue.top 0 Redis(integer) 1#向有序集合tangmenjue.top添加分数为1的Vue值127.0.0.1:6379&gt; zadd tangmenjue.top 1 Vue(integer) 1#向有序集合tangmenjue.top添加分数为2的Pgsql值和分数为3的Sqlserver值127.0.0.1:6379&gt; zadd tangmenjue.top 2 Pgsql 3 Sqlserver(integer) 2#获取有序集合tangmenjue.top的所有数据，并打印出分数127.0.0.1:6379&gt; zrange tangmenjue.top 0 -1 withscores1) \"Redis\"2) \"0\"3) \"Vue\"4) \"1\"5) \"Pgsql\"6) \"2\"7) \"Sqlserver\"8) \"3\"#删除有序集合tangmenjue.top127.0.0.1:6379&gt; del tangmenjue.top(integer) 1 连接本地Redis 进入到Redis所在目录，在地址栏输入cmd，此时会在当前目录打开命令行窗口，如下图所示： 在命令行中输入以下命令后回车，启动redis server客户端: 12345E:\\Redis&gt;redis-server.exe[4524] 16 Dec 11:48:29.399 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo[4524] 16 Dec 11:48:29.399 # Redis version=5.0.14.1, bits=64, commit=ec77f72d, modified=0, pid=4524, just started[4524] 16 Dec 11:48:29.399 # Configuration loaded[4524] 16 Dec 11:48:29.401 # Could not create server TCP listening socket 127.0.0.1:6379: bind: 操作成功完成。 此时可以看到redis server的运行信息，说明redis server运行成功。 接下来不要关闭这个Redis server，重新在地址栏输入聪明的，打开一个新的命令行。在命令行中输入以下命令后回车，启动redis client端： 12PS E:\\Redis&gt; redis-cli.exe127.0.0.1:6379&gt; 看到127.0.0.1:6379则表明此时已经成功连接上了本地Redis服务器。 在redis client端的cmd上输入以下命令后回车,以此来测试redis-cli客户端是否能连接上redis服务器： 1234127.0.0.1:6379&gt; pingPONG#当看到输出PONG时则表示连接成功 注意：若是启动redis server客户端时出现以下错误： 12345E:\\Redis&gt;redis-server.exe[7976] 16 Dec 11:41:31.720 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo[7976] 16 Dec 11:41:31.720 # Redis version=5.0.14.1, bits=64, commit=ec77f72d, modified=0, pid=7976, just started[7976] 16 Dec 11:41:31.721 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server.exe /path/to/redis.conf[7976] 16 Dec 11:41:31.724 # Could not create server TCP listening socket *:6379: bind: 在一个非套接字上尝试了一个操作。 出现这一错误则则可以将启动命令改为如下命令： 1E:\\Redis&gt;redis-server.exe redis.windows.conf 连接远程Redis 在Redis根目录下打开cmd，使用redis-cli客户端，连接远程redis服务的语法为： 1234redis-cli -h host -p port -a password#其中：host为服务器所在的ip地址#port为Redis服务的监听端口#password为Redis服务的密码，若没有开启认证则不需要这一参数 Redis配置 使用redis-cli客户端连接上redis服务器后，可以使用config命令来查看或设置redis的配置，也可以直接修改安装目录下的redis.windows.conf文件来修改配置。 config相关命令如下： config get key：获取配置项为key的配置，配置项不存在时返回(empty list or set) config get *：获取所有配置 config set key \"value\"：设置配置项key的值为value","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"YAML","slug":"YAML","permalink":"http://tangmenjue.top/categories/YAML/"},{"name":"Redis","slug":"Redis","permalink":"http://tangmenjue.top/categories/Redis/"}],"tags":[{"name":"YAML","slug":"YAML","permalink":"http://tangmenjue.top/tags/YAML/"},{"name":"Redis","slug":"Redis","permalink":"http://tangmenjue.top/tags/Redis/"}]},{"title":"Docker应用部署实战","slug":"Docker应用部署实战","date":"2022-12-14T16:16:08.000Z","updated":"2022-12-23T09:33:15.000Z","comments":true,"path":"2022/12/15/Docker应用部署实战/","link":"","permalink":"http://tangmenjue.top/2022/12/15/Docker%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E5%AE%9E%E6%88%98/","excerpt":"","text":"Centos部署应用步骤 配置代码运行环境 nginx下载及配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#centos下载apache[root@localhost admin]# yum install httpd #centos下载nginx[root@localhost admin]# yum install epel-release[root@localhost httpd]# yum install -y update[root@localhost httpd]# yum install -y nginx#打开防火墙端口80和443[root@localhost httpd]# firewall-cmd --permanent --zone=public --add-service=http[root@localhost httpd]# firewall-cmd --permanent --zone=public --add-service=https[root@localhost httpd]# firewall-cmd --reload#启动nignx服务[root@localhost httpd]# systemctl start nginx#查看nignx进程的状态[root@localhost admin]# systemctl status nginx● nginx.service - The nginx HTTP and reverse proxy server Loaded: loaded (/usr/lib/systemd/system/nginx.service; disabled; vendor preset: disabled) Active: active (running) since 日 2022-12-11 18:32:09 PST; 1min 10s ago Process: 5678 ExecStart=/usr/sbin/nginx (code=exited, status=0/SUCCESS) Process: 5675 ExecStartPre=/usr/sbin/nginx -t (code=exited, status=0/SUCCESS) Process: 5670 ExecStartPre=/usr/bin/rm -f /run/nginx.pid (code=exited, status=0/SUCCESS) Main PID: 5680 (nginx) Tasks: 2 CGroup: /system.slice/nginx.service ├─5680 nginx: master process /usr/sbin/nginx └─5683 nginx: worker process12月 11 18:32:09 localhost.localdomain systemd[1]: Starting The nginx HTTP a...12月 11 18:32:09 localhost.localdomain nginx[5675]: nginx: the configuration...12月 11 18:32:09 localhost.localdomain nginx[5675]: nginx: configuration fil...12月 11 18:32:09 localhost.localdomain systemd[1]: Started The nginx HTTP an...Hint: Some lines were ellipsized, use -l to show in full.#设置nignx服务开机自启动[root@localhost httpd]# systemctl enable nginxCreated symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service.#进入conf.d目录新建文件并填入以下内容[root@localhost httpd]# cd /etc/nginx/conf.d[root@localhost conf.d]# ls[root@localhost conf.d]# touch flask_test.conf[root@localhost conf.d]# vi flask_test.confserver &#123; listen 80; server_name localhost; # api代理转发 location / &#123; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_pass http://127.0.0.1:8000; &#125;&#125;#重启nginx[root@localhost conf.d]# systemctl reload nginx pgsql下载及配置 123456789101112131415161718192021222324252627282930#centos下载pgsql[root@localhost httpd]# yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm[root@localhost httpd]# yum install postgresql12-server#启动pgsql服务[root@localhost httpd]# postgresql-12-setup initdbInitializing database ... OK[root@localhost httpd]# systemctl start postgresql-12#设置pgsql服务开机自启动[root@localhost httpd]# systemctl enable postgresql-12Created symlink from /etc/systemd/system/multi-user.target.wants/postgresql-12.service to /usr/lib/systemd/system/postgresql-12.service.#配置pgsql[root@localhost bin]# su - postgres-bash-4.2$ psqlpsql (12.13)Type \"help\" for help.postgres=# alter user postgres with password '123456'postgres-# \\q-bash-4.2$ exitlogout[root@localhost bin]# find / -name postgresql.conffind: ‘/run/user/1000/gvfs’: 权限不够/var/lib/pgsql/12/data/postgresql.conf#配置远程访问[root@localhost bin]# vi /var/lib/pgsql/12/data/postgresql.conflisten_addressses=\"*\"port = 5432 node.js安装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#安装node.js[root@localhost admin]# wget https://nodejs.org/dist/v16.16.0/node-v16.16.0-linux-x64.tar.xz[root@localhost admin]# tar -xvf node-v16.16.0-linux-x64.tar.xz[root@localhost admin]# mv node-v16.16.0-linux-x64 node.js#查找node.js路径[root@localhost admin]# find / -name node.jsfind: ‘/run/user/1000/gvfs’: 权限不够/home/admin/node.js/home/admin/node.js/lib/node_modules/npm/node_modules/debug/src/node.js/home/admin/node.js/lib/node_modules/npm/node_modules/@npmcli/arborist/lib/node.js/home/admin/node.js/lib/node_modules/npm/node_modules/@npmcli/fs/lib/common/node.js/home/admin/node.js/lib/node_modules/npm/node_modules/util-deprecate/node.js#检查node版本[root@localhost admin]# cd /home/admin/node.js/bin[root@localhost bin]# ./node -vv16.16.0#添加node.js的环境变量：[root@localhost bin]# vi /etc/profile#在文件末尾加上两句代码如下：#NODE_HOME为实际中node的安装位置目录export NODE_HOME=/home/admin/node.jsexport PATH=$NODE_HOME/bin:$PATH#按ESC+:+wq退出vim模式，输入以下命令使配置生效[root@localhost bin]# source /etc/profile#配置软连接将环境配置放到开机自启动的脚本中[root@localhost bin]# ln -s /usr/local/node.js/bin/node /usr/local/bin/node[root@localhost bin]# ln -s /usr/local/node.js/bin/npm /usr/local/bin/npm#查看虚拟机ip[root@localhost admin]# ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.60.129 netmask 255.255.255.0 broadcast 192.168.60.255 inet6 fe80::b659:fb9c:695f:5eff prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:b0:6f:2a txqueuelen 1000 (Ethernet) RX packets 491682 bytes 725762513 (692.1 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 49960 bytes 3119454 (2.9 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 1411 bytes 485777 (474.3 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1411 bytes 485777 (474.3 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 192.168.122.1 netmask 255.255.255.0 broadcast 192.168.122.255 ether 52:54:00:42:aa:9d txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 部署应用 应用代码传输 在window系统中下载xftp并安装，官网地址如下：家庭/学校免费 - NetSarang Website (xshell.com)，安装好后打开，点击新建，在主机一栏填上虚拟机的ip地址：192.168.60.129，用户名填root，密码填虚拟机的密码，其他默认，点击连接如下所示： 左侧窗口为本地目录，右侧窗口为虚拟机目录。选中左侧文件后右键，点击传输便可将文件从本地的windows系统传输到Linux虚拟机中。 应用前端部署 123456789101112131415161718#切换到前端代码目录[root@localhost bin]# cd /root/WeChat_exercise/front-end#下载vue及vue cli、加载项目所需的配置文件[root@localhost front-end]# npm install vue[root@localhost front-end]# npm install --global @vue/cli[root@localhost front-end]# npm install yarn[root@localhost front-end]# npm install#运行前端项目[root@localhost front-end]# npm run serve DONE Compiled successfully in 51145ms 01:47:08 App running at: - Local: http://localhost:8080 - Network: http://192.168.60.129:8080 Note that the development build is not optimized. To create a production build, run yarn build. 后端环境部署 1234567891011121314151617181920212223242526272829303132333435#编译安装python3[root@localhost admin]# wget https://www.Python.org/ftp/python/3.6.1/Python-3.6.1.tar.xz[root@localhost admin]# tar xJf Python-3.6.1.tar.xz[root@localhost admin]# cd Python-3.6.1[root@localhost Python-3.6.1]# ./configure --prefix=/usr/local/python3 &amp;&amp; make &amp;&amp; make install#创建软链接[root@localhost Python-3.6.1]# ln -s /usr/local/python3/bin/python3 /usr/bin/python3[root@localhost Python-3.6.1]# ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3#更换pip源[root@localhost ~]# mkdir ~/.pip[root@localhost ~]# vi ~/.pip/pip.conf[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com#切换到后端项目目录，安装virtualenv[root@localhost ~]# cd /root/WeChat_exercise/back-endot@localhost back-end]# yum install python-virtualenv#创建虚拟环境venv并激活[root@localhost back-end]# python3 -m venv venv[root@localhost back-end]# . venv/bin/activate[root@localhost back-end]# yum install postgresql-devel#安装Flask和项目所需环境(venv) [root@localhost back-end]# pip3 install --upgrade pip setuptools wheel(venv) [root@localhost back-end]# pip install Flask(venv) [root@localhost back-end]# pip install -r requirements.txt(venv) [root@localhost back-end]# pip install psycopg2#运行Flask项目(venv) [root@localhost back-end]#flask run docker容器部署应用 这一部分先手动启动Pgsql、Python、Nginx等容器，然后再使用Docker Compose来编排容器。 Docker安装 12345#安装并启动docker[root@localhost admin]# curl -sSL https://get.daocloud.io/docker | sh[root@localhost admin]# systemctl start docker[root@localhost admin]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. 构建PgSQL容器 安装镜像 1[root@localhost admin]# docker pull postgres 创建配置文件夹，可以看到postgres镜像创建的容器是将数据保存在/var/lib/postgresql/data位置下的： 123456789101112131415161718192021222324252627282930313233343536373839[root@localhost admin]# cd /home[root@localhost home]# mkdir -p /home/docker[root@localhost home]# mkdir -p /home/docker/postgresql[root@localhost home]# mkdir -p /home/docker/postgresql/data[root@localhost home]# docker image inspect postgres[ &#123; \"Id\": \"sha256:a26eb6069868e4bfd0095788e541bb40711861bdfb2a8252103dea85cc0758aa\", \"RepoTags\": [ \"postgres:latest\" ], \"RepoDigests\": [ \"postgres@sha256:f4cd32e7a418d9c9ba043e7d561243388202b654c740bcc85ca40b41d9fb4f1e\" ], \"Parent\": \"\", \"Comment\": \"\", \"Created\": \"2022-12-22T23:19:59.856808957Z\", \"Container\": \"938c729969fbf6312f6563590395ed0bb4cbc982b039598c38ffa539c86a5df5\", \"ContainerConfig\": &#123; \"Hostname\": \"938c729969fb\", \"Domainname\": \"\", \"User\": \"\", \"AttachStdin\": false, \"AttachStdout\": false, \"AttachStderr\": false, \"ExposedPorts\": &#123; \"5432/tcp\": &#123;&#125; &#125;, \"Tty\": false, \"OpenStdin\": false, \"StdinOnce\": false, \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/lib/postgresql/15/bin\", \"GOSU_VERSION=1.14\", \"LANG=en_US.utf8\", \"PG_MAJOR=15\", \"PG_VERSION=15.1-1.pgdg110+1\", \"PGDATA=/var/lib/postgresql/data\" ], 执行以下命令创建并启动PgSQL容器，自定义命名为my-postgres： 12[root@localhost home]# docker run -p 5432:5432 -v /home/docker/postgresql/data:/var/lib/postgresql/data -e POSTGRES_PASSWORD=123456 -e TZ=PRC -d --name=my-postgres postgres165c63929bf341497816b85f28a060a2c6f75b7d9144627a560547b9ca92f9f4 现在便可以用docker ps -a查看容器是否已经运行： 1234[root@localhost home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES165c63929bf3 postgres \"docker-entrypoint.s…\" About a minute ago Up About a minute 0.0.0.0:5432-&gt;5432/tcp, :::5432-&gt;5432/tcp my-postgres4c1699cdc854 flask-test:latest \"/bin/sh -c 'gunicor…\" 9 days ago Restarting (1) 45 seconds ago flask_test 构建Flask API镜像 由于有多条命令，不方便直接写到Dockerfile中的CMD子命令中，因此在后端项目目录下新建boot.sh 123456789101112131415161718192021#切换到后端项目目录[root@localhost home]# cd /root/WeChat_exercise/back-end[root@localhost back-end]# lsapp config.py invoke migrations package.json __pycache__ Python.gitignore requirements.txt venv weixin.py[root@localhost back-end]# touch boot.sh[root@localhost back-end]# vi boot.sh#内容如下#!/bin/shwhile true; do flask db upgrade if [[ \"$?\" == \"0\" ]]; then break fi echo Failed to apply the migration to the database, retrying in 3 secs... sleep 3doneflask deployexec gunicorn -w 3 -b 0.0.0.0:5000 --access-logfile - --error-logfile - weixin:app#授予可执行权限[root@localhost back-end]# chmod +x boot.sh 新建一个Dockerfile 12345678910111213141516[root@localhost back-end]# touch Dockerfile[root@localhost back-end]# vi Dockerfile[root@CentOS www]# vim back-end/Dockerfile内容如下：FROM python:3.6-alpineCOPY ./back-end /usr/src/appWORKDIR /usr/src/appRUN pip --no-cache-dir install -i https://mirrors.aliyun.com/pypi/simple/ --upgrade pipRUN pip install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/ \\ &amp;&amp; pip install gunicornENV FLASK_APP weixin.pyEXPOSE 5000ENTRYPOINT [\"./boot.sh\"] 开始构建后端Flask API镜像 12345678910111213141516171819202122[root@localhost back-end]# cd ../[root@localhost WeChat_exercise]# docker build -f back-end/Dockerfile -t weixin-api:0.0.1 .Sending build context to Docker daemon 573MB.2MBStep 1/8 : FROM python:3.6-alpine ---&gt; 3a9e80fa4606Step 2/8 : COPY ./back-end /usr/src/app ---&gt; f5a2a7ecb4cf...Step 6/8 : ENV FLASK_APP weixin.py ---&gt; Running in e9f4ebef3d13Removing intermediate container e9f4ebef3d13 ---&gt; 7317d7be0b13Step 7/8 : EXPOSE 5000 ---&gt; Running in c544718548e6Removing intermediate container c544718548e6 ---&gt; c6e683ab97ffStep 8/8 : ENTRYPOINT [\"./boot.sh\"] ---&gt; Running in c8e11997efb0Removing intermediate container c8e11997efb0 ---&gt; 64f072fbbbe5Successfully built 64f072fbbbe5Successfully tagged weixin-api:0.0.1 启动Flask API容器 12[root@localhost WeChat_exercise]# docker run -d --name weixin-api --link my-postgres:postgres -e DATABASE_URL=postgresql://postgres:123456@localhost:5432/postgres -p 5000:5000 --rm weixin-api:0.0.12b58b6f9a4984649df15eda6c7b5b849697b3fc6f9cdfd906009e52814763f19 构建Nginx容器 修改WeChat_exercise/front-end/src/main.js文件，增加以下代码，其中192.168.60:131为虚拟机ip 123456Vue.use(ElementUI);if (process.env.NODE_ENV==='production')&#123; axios.defaults.baseURL='http://192.168.60:131:5000'&#125;else &#123; axios.defaults.baseURL = 'http://127.0.0.1:5000';&#125; 将打包后的静态文件，拷贝到 ../docker/nginx/data 目录中，后续映射到 Nginx 容器中去 1234567[root@localhost home]# cd /root/WeChat_exercise/front-end[root@localhost front-end]# npm install[root@localhost front-end]# npm run build[root@localhost front-end]# mkdir -p ../docker/nginx/data[root@localhost front-end]# cp -a dist/* ../docker/nginx/data[root@localhost front-end]# cd ..[root@localhost WeChat_exercise]# 启动Nginx容器 12[root@localhost WeChat_exercise]# docker run -d --name nginx -p 18080:80 --rm -v $PWD/docker/nginx/data:/usr/share/nginx/html nginx50f66f6ad75ec19220e37fe510724b70448b462a7e7c6b335f42de4893f44944 浏览器访问http://192.168.60.131:18080/#/ping，前端应用能够正常访问到后端API接口： 使用Docker Compose编排容器 安装docker-compose 123456[root@localhost WeChat_exercise]# cd back-end[root@localhost back-end]# curl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose[root@localhost back-end]# chmod +x /usr/local/bin/docker-compose[root@localhost back-end]# ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose[root@localhost back-end]# docker-compose versionDocker Compose version v2.4.1 创建并编写docker-compose.yaml文件 1234567891011121314151617181920212223242526272829303132333435363738[root@localhost back-end]# touch docker-compose.yaml[root@localhost back-end]# vi docker-compose.yaml#内容如下：version: \"3.7\"services: my-postgres: image: postgres privileged: true # 权限要加，不然启动会告错 environment: POSTGRES_PASSWORD: 123456 POSTGRES_USER: postgres POSTGRES_DB: postgres TZ: Asia/Shanghai ports: - 5432:5432 volumes: - /home/docker/postgresql/data:/var/lib/postgresql/data restart: always weixin-api: image: weixin-api:0.0.1 build: context: . dockerfile: Dockerfile restart: always ports: - \"5000:5000\" depends_on: - my-postgres nginx: image: nginx ports: - \"18080:80\" volumes: - \"$PWD/docker/nginx/data:/usr/share/nginx/html\" 查看正在运行的容器并使它们全部停止运行 123456789101112131415161718192021222324252627#查看正在运行的容器[root@localhost back-end]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2b58b6f9a498 weixin-api:0.0.1 \"./boot.sh\" 47 minutes ago Up 47 minutes 0.0.0.0:5000-&gt;5000/tcp, :::5000-&gt;5000/tcp weixin-api50f66f6ad75e nginx \"/docker-entrypoint.…\" 2 hours ago Up 2 hours 0.0.0.0:18080-&gt;80/tcp, :::18080-&gt;80/tcp nginx165c63929bf3 postgres \"docker-entrypoint.s…\" 2 hours ago Up 2 hours 0.0.0.0:5432-&gt;5432/tcp, :::5432-&gt;5432/tcp my-postgres4c1699cdc854 flask-test:latest \"/bin/sh -c 'gunicor…\" 9 days ago Restarting (1) 14 seconds ago flask_test#停止所有正在运行的容器[root@localhost back-end]# docker stop $(docker ps -a -q)27ddc44b2109a0704302049bd5e6169401912b58b6f9a4982d86579808e5bb1794163d8ebe6acf36f0d650f66f6ad75e165c63929bf34a78c412395d80b4b9b476524c1699cdc854d140e8d466d0#检查是否还有容器正在运行[root@localhost back-end]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 使用Docker Compose启动应用所需的所有容器，'-d' 选项表示在后台运行 compose，否则在前台输出日志 1234567891011121314151617181920212223#启动所有容器[root@localhost back-end]# docker-compose up -d[+] Running 3/3 ⠿ Container back-end-nginx-1 Started 6.0s ⠿ Container back-end-my-postgres-1 Started 6.1s ⠿ Container back-end-weixin-api-1 Started 11.0s#查看容器状态[root@localhost back-end]# docker-compose psNAME COMMAND SERVICE STATUS PORTSback-end-my-postgres-1 \"docker-entrypoint.s…\" my-postgres running 0.0.0.0:5432-&gt;5432/tcp, :::5432-&gt;5432/tcpback-end-nginx-1 \"/docker-entrypoint.…\" nginx running 0.0.0.0:18080-&gt;80/tcp, :::18080-&gt;80/tcpback-end-weixin-api-1 \"./boot.sh\" weixin-api running 0.0.0.0:5000-&gt;5000/tcp, :::5000-&gt;5000/tcp#查看各容器的运行日志，若含有'-f' 选项则持续输出[root@localhost back-end]# docker-compose logs#停止全部容器[root@localhost back-end]# docker-compose stop[+] Running 3/3 ⠿ Container back-end-weixin-api-1 Stopped 16.3s ⠿ Container back-end-nginx-1 Stopped 4.0s ⠿ Container back-end-my-postgres-1 Stopped 端口被占用解决方法 在docker部署的过程中，若端口被占用，如80端口，可使用以下命令解除端口占用： 123456789101112#查看占用80端口的进程[root@localhost back-end]# netstat -lnp | grep 80tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 1159/nginx: master tcp6 0 0 :::80 :::* LISTEN 1159/nginx: master #杀死占用端口的进程[root@localhost back-end]# kill -9 1159#查看是否还有进程占用端口，若有，则继续杀死进程，若无，则端口占用已解除[root@localhost back-end]# netstat -lnp | grep 80tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 1160/nginx: worker tcp6 0 0 :::80 :::* LISTEN 1160/nginx: worker [root@localhost back-end]# kill -9 1160[root@localhost back-end]# netstat -lnp | grep 80","categories":[{"name":"Docker","slug":"Docker","permalink":"http://tangmenjue.top/categories/Docker/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://tangmenjue.top/tags/Docker/"},{"name":"应用部署","slug":"应用部署","permalink":"http://tangmenjue.top/tags/%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/"}]},{"title":"Docker应用部署基础","slug":"Docker应用部署基础","date":"2022-12-06T13:06:20.000Z","updated":"2022-12-23T02:24:30.000Z","comments":true,"path":"2022/12/06/Docker应用部署基础/","link":"","permalink":"http://tangmenjue.top/2022/12/06/Docker%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Docker 容器简介 什么是Linux容器 Linux容器是与系统其他部分隔离开的一系列进程。它在另一个镜像中运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包括了应用的所有依赖项，因此在开发到测试再到生产的过程中，容器都具有可移植性和一致性。 容器等同于虚拟化吗 容器不完全是虚拟化。虚拟化使得许多系统可同时在单个系统上运行，而容器可共享同一个操作系统的内核，将应用进程与系统其他部分隔离开。 这便意味着，即使是让多个操作系统在单个虚拟机监控程序上运行以实现虚拟化，也不能达到和使用容器同等的轻量级效果。Linux容器可从单个操作系统运行，在所有容器中共享该操作系统，因此应用和服务能够保持轻量级，并可以快速运行。 什么是Docker IT软件中所说的Docker，是指容器化技术，用于支持创建和使用Linux容器。借助Docker，可将容器当作重量轻、模块化的虚拟机使用，同时还将获得高度的灵活性，从而实现对容器的高效创建、部署及复制，并能将其从一个环境顺利迁移至另一个环境。 Docker技术使用Linux内核和内核功能来分隔进行，以便各进程相互独立运行。 Docker的目标 Docker的主要目标是构建、运输、处处运行（Build, Ship and Run any App, Angwhere） 构建：做一个Docker镜像 运输：Docker pull 运行：启动一个容器 每个容器都有自己的文件系统rootfs 安装Docker 在Centos系统中，安装命令如下： 12345678910111213141516171819202122232425262728293031323334#查看当前的内核版本[root@localhost admin]# uname -r3.10.0-1160.el7.x86_64#查看已安装的CentOS版本信息[root@localhost admin]# cat /etc/redhat-releaseCentOS Linux release 7.9.2009 (Core)#安装需要的软件包，yum-util提供yum-config-manager功能，另两个是devicemapper驱动依赖yum install -y yum-utils device-mapper-persistent-data lvm2#设置yun源，下面两个都可用#（中央仓库）yum-config-manager --add-repo http://download.docker.com/linux/centos/docker-ce.repo#（阿里仓库）yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo#查看可用的Docker版本yum list docker-ce --showduplicates | sort -r#选择一个Docker版本并安装yum -y install docker-ce-18.03.1.ce#启动Docker并设置开机自启systemctl start dockersystemctl enable docker#查看Docker相关信息来验证是否正确安装了Dockerdocker version#配置Docker镜像加速vim /etc/docker/daemon.json&#123;\"registry-mirrors\":[\"https://registry.docker-cn.com\"]&#125;#启动第一个容器docker run hello-world Hello World Docker允许在容器中运行应用程序，使用docker run命令来在容器中运行一个应用程序，输出Hello World如下： 1234[root@localhost admin]# docker run ubuntu:15.10 /bin/echo \"Hello world\"Hello world#其中ubuntu:15.10为所指定的要运行的镜像，Docker会首先从本地主机上查找镜像是否存在，若不存在，Dockwe就会从镜像仓库中下载公共镜像# /bin/echo \"Hello world\"为在启动的容器里执行的命令 运行交互式的容器 通过Docker的两个参数-i -t，可以让Docker运行的容器实现交互式对话的能力： 12345678910111213[root@localhost admin]# docker run -i -t ubuntu:15.10 /bin/bashroot@7cf8cc6326f7:/##此时已经进入了一个ubuntu:15.10系统的容器#查看当前系统的版本信息root@7cf8cc6326f7:/# cat /proc/versionLinux version 3.10.0-1160.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) ) #1 SMP Mon Oct 19 16:18:59 UTC 2020#查看当前目录下的文件列表root@7cf8cc6326f7:/# lsbin dev home lib64 mnt proc run srv tmp varboot etc lib media opt root sbin sys usr#可以通过运行exit命令或使用Ctrl+D来退出容器root@7cf8cc6326f7:/# exitexit 后台模式启动容器 使用以下命令可以创建一个以进程方式运行的容器： 123[root@localhost admin]# docker run -d ubuntu:15.10 /bin/sh -c \"while true'do echo hello world; sleep 1;done\"#输出的长字符串为容器的IDa26fa474ed2743ad2413c5e9c828faafa141ab1ec11ba3ffaf424de658b785de 容器ID对每个容器来说都是唯一的，可以通过容器ID来查看对应的容器发生了什么。 另外打开一个终端，用docker ps查看容器是否进行： 1234567891011[root@localhost admin]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES54539564169f ubuntu:15.10 \"/bin/bash\" 31 seconds ago Up 30 seconds nostalgic_jennings#CONTAINER ID 为容器ID#IMAGE 为使用的镜像#COMMAND 为启动容器时运行的命令#CREATED 为容器的创建时间#STATUS 为容器状态#PORTS 为容器的端口信息和使用的连接类型(tcp\\udp)#NAMES 为自动分配的容器名称 容器的状态有7种： created（已创建） restarting（重启中） running或Up（运行中） removing（迁移中） paused（暂停） exited（停止） dead（死亡） 停止容器 使用docker stop命令可以使容器停止： 1docker stop 需要停止的容器ID Docker镜像管理 Docker镜像常用命令 根据镜像名称获取镜像centos：docker pull centos 查看当前主机镜像列表：docker image list 查找镜像：docker search 镜像名 导入镜像（docker-centos.tar.gz为镜像名）：docker image load -i docker-centos.tar.gz 导出镜像centos：docker image save centos &gt; docker-centos.tar.gz 删除镜像hello-world：docker rmi hello-world 删除镜像centos：docker image rm centos:latest 更新镜像：docker run -t -i ubuntu:15.10 /bin/bash 查看镜像的详细信息：docker image inspect centos 使用Dockerfile构建镜像 当从docker镜像仓库中下载的镜像不能满足需求时，可以通过以下两种方式对镜像进行更改： 从已经创建的容器中更新镜像，并提交这个镜像 使用Dockerfile命令来创建一个新的镜像 首先，使用命令docker build 从零开始创建一个新的镜像，为此需要创建一个Dockerfile文件，其中包含一组指令来告诉Docker如何构建镜像 123456789101112[root@localhost admin]# touch Dockerfile[root@localhost admin]# vim DockerfileFROM centos:6.7MAINTAINER Fisher \"fisher@sudops.com\"RUN /bin/echo 'root:123456' |chpasswdRUN useradd runoobRUN /bin/echo 'runoob:123456' |chpasswdRUN /bin/echo -e \"LANG=\\\"en_US.UTF-8\\\"\" &gt;/etc/default/localEXPOSE 22EXPOSE 80CMD /usr/sbin/sshd -D 每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。 dockerfile 命令详情如下： FROM：镜像从那里来 MAINTAINER：镜像维护者信息 RUN：构建镜像执行的命令，每一次RUN都会构建一层 CMD：容器启动的命令，如果有多个则以最后一个为准，也可以为ENTRYPOINT提供参数 VOLUME：定义数据卷，如果没有定义则使用默认 USER：指定后续执行的用户组和用户 WORKDIR：切换当前执行的工作目录 HEALTHCHECH：健康检测指令 ARG：变量属性值，但不在容器内部起作用 EXPOSE：暴露端口 ENV：变量属性值，容器内部也会起作用 ADD：添加文件，如果是压缩文件也解压 COPY：添加文件，以复制的形式 ENTRYPOINT：容器进入时执行的命令 其中，FROM指令指定只用哪个镜像源，RUN指令告诉docker在镜像内执行命令安装了什么。然后便可以使用Dockerfile 文件通过docker build 命令来构建一个镜像。 12345678910111213141516171819202122[root@localhost admin]# docker build -t runoob/centos:6.7 .Sending build context to Docker daemon 205.8MBStep 1/9 : FROM centos:6.76.7: Pulling from library/centoscbddbc0189a0: Pull complete Digest: sha256:4c952fc7d30ed134109c769387313ab864711d1bd8b4660017f9d27243622df1Status: Downloaded newer image for centos:6.7 ---&gt; 9f1de3c6ad53Step 2/9 : MAINTAINER Fisher \"fisher@sudops.com\" ---&gt; Running in 5eaef1ca03a8Removing intermediate container 5eaef1ca03a8 ---&gt; fb3340e270e3...Step 9/9 : CMD /usr/sbin/sshd -D ---&gt; Running in 5856113fd1c1Removing intermediate container 5856113fd1c1 ---&gt; 461a6483b47bSuccessfully built 461a6483b47bSuccessfully tagged runoob/centos:6.7#其中参数-t为指定要创建的目标镜像名#参数.为Dockerfile文件所在目录，也可以指定Dockerfile的绝对路径 查看创建的镜像runoob/centos 是否已经存在： 12345678910[root@localhost admin]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZErunoob/centos 6.7 461a6483b47b 12 minutes ago 191MBnginx latest 88736fe82739 2 weeks ago 142MBubuntu latest a8780b506fa4 4 weeks ago 77.8MBhello-world latest feb5d9fea6a5 14 months ago 13.3kBcentos latest 5d0da3dc9764 14 months ago 231MBcentos 6.7 9f1de3c6ad53 3 years ago 191MBubuntu 15.10 9b9cb95443b5 6 years ago 137MBtraining/webapp latest 6fae60ef3446 7 years ago 349MB 现在可以使用新的镜像来创建容器： 123[root@localhost admin]# docker run -t -i runoob/centos:6.7 /bin/bash[root@c256ace5a3db /]# id runoobuid=500(runoob) gid=500(runoob) groups=500(runoob) 可以看到新镜像已经包含创建的用户runoob。 设置镜像标签 使用docker tag 命令可以为镜像添加一个新的标签： 123456789101112root@localhost admin]# docker tag 461a6483b47b runoob/centos:dev[root@localhost admin]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZErunoob/centos 6.7 461a6483b47b 21 minutes ago 191MBrunoob/centos dev 461a6483b47b 21 minutes ago 191MBnginx latest 88736fe82739 2 weeks ago 142MBubuntu latest a8780b506fa4 4 weeks ago 77.8MBhello-world latest feb5d9fea6a5 14 months ago 13.3kBcentos latest 5d0da3dc9764 14 months ago 231MBcentos 6.7 9f1de3c6ad53 3 years ago 191MBubuntu 15.10 9b9cb95443b5 6 years ago 137MBtraining/webapp latest 6fae60ef3446 7 years ago 349MB 容器的日常管理 启动容器 最简单的运行一个容器：docker run nginx 使用ubuntu镜像启动一个容器，参数以命令行模式进入该容器：docker run -it ubuntu /bin/bash（-it是指交互式终端） 快速启动容器：docker run centos:latest /usr/bin/sleep 20 注意：容器内的第一个进程必须一直处于运行的状态，否则这个容器，就会处于退出状态！ 查看正在运行的容器：docker container ls 查看容器详细信息/id：docker container inspect 容器名称/id 启动已停止运行的容器 查看所有容器（包括未运行的）：docker ps -a 启动一个已停止运行的容器：docker start 容器名称/id 自命名启动一个容器：docker run --name ubuntu-test ubuntu /bin/bash 让ubuntu-test容器在后台运行：docker run -itd --name ubuntu-test ubuntu /bin/bash 停止容器:docker stop 容器名称/id或者docker container kill 容器名称/id 重启停止的容器：docker restart 容器名称/id 进入容器 在使用-d参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入： docker attach 容器名称/id ：此命令会退出容器终端，且会导致容器停止 docker exec -it 容器名称/id /bin/bash：（推荐使用此命令，此命令会退出容器终端，但不会导致容器的停止） 导入容器快照 可以使用docker import 从容器快照文件中再导入为镜像，如将快照文件ubuntu.tar导入到镜像test/ubuntu:v1中： 1cat docker /ubuntu.tar | docker import - test/ubuntu:v1 也可以通过指定URL或某个目录来导入，如： 1docker import http://example.com/exampleimage.tag example/imagerepo 删除容器 使用docker rm 命令可删除容器： 1docker rm -f 容器名称/id 清理掉所有处于终止状态的容器： 1docker container prune 删除所有容器： 1docker rm -f `docker ps -a -q` 使用docker构建一个web应用程序 在dockers容器中运行一个Python Flask应用来运行一个web应用： 123456[root@localhost admin]# docker pull training/webapp[root@localhost admin]# docker run -d -P training/webapp python app.py8294ae65cc7397df396f1846582d2c55896646996eab41a26f9be0c01f3270f8#-d:让容器在后台运行#-P:将容器内部使用的网络端口随机映射到使用的主机上 不同指定的映射方法： 参数 说明 -p hostPort:containerPort 端口映射 -p 8080:80 -p ip:hostPort:containerPort 配置监听地址 -p 10.0.0.100:8080:80 -p ip::containerPort 随机分配端口 -p 10.0.0.100::80 -p hostPort:containerPort:udp 指定协议 -p 8080:80:tcp -p 81:80 –p 443:443 指定多个 此时使用docker ps来查看正在运行的容器，会发现多了端口信息： 123[root@localhost admin]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8294ae65cc73 training/webapp \"python app.py\" 49 seconds ago Up 47 seconds 0.0.0.0:32768-&gt;5000/tcp hardcore_brown 从端口信息中可知，Docker开放了5000端口（默认Python Flask端口）映射到主机端口32768上，此时可以通过浏览器访问WEB应用：(路径为主机ip:32768端口) 可以通过参数-p来设置不一样的端口，如将容器内部的5000端口映射到本地主机的5000端口上： 123456[root@localhost admin]# docker run -d -p 5000:5000 training&#x2F;webapp python app.py743a62b49b70f9575690e2b85d4ea1eed94dd19fe9f6074f1d7069d977a2ecc8[root@localhost admin]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES743a62b49b70 training&#x2F;webapp &quot;python app.py&quot; 22 seconds ago Up 21 seconds 0.0.0.0:5000-&gt;5000&#x2F;tcp infallible_allen8294ae65cc73 training&#x2F;webapp &quot;python app.py&quot; 10 minutes ago Up 10 minutes 0.0.0.0:32768-&gt;5000&#x2F;tcp hardcore_brown 网络端口的快捷方式 使用docker port 可以查看指定（ID或名字）容器的某个确定端口映射到宿主机的端口号。 查看容器端口情况可用：docker port 容器名称/id，如： 1234[root@localhost admin]# docker port 743a62b49b705000/tcp -&gt; 0.0.0.0:5000[root@localhost admin]# docker port infallible_allen5000/tcp -&gt; 0.0.0.0:5000 查看WEB应用程序日志 查看容器内部的标准输出，可以查看端口信息和应用程序的访问日志： 1234[root@localhost admin]# docker logs -f 743a62b49b70 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)192.168.18.129 - - [06/Dec/2022 01:43:49] \"GET / HTTP/1.1\" 200 -192.168.18.129 - - [06/Dec/2022 01:43:49] \"GET /favicon.ico HTTP/1.1\" 404 - 检查WEB应用程序 使用docker inspect来查看Docker的底层信息，它会返回一个JSON文件记录着Docker容器的配置和状态信息： 123456789101112131415161718192021222324[root@localhost admin]# docker inspect 743a62b49b70[ &#123; \"Id\": \"743a62b49b70f9575690e2b85d4ea1eed94dd19fe9f6074f1d7069d977a2ecc8\", \"Created\": \"2022-12-06T01:42:44.255608149Z\", \"Path\": \"python\", \"Args\": [ \"app.py\" ], \"State\": &#123; \"Status\": \"running\", \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 17733, \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2022-12-06T01:42:45.331479678Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" &#125;, ......] 停止WEB应用容器 12[root@localhost admin]# docker stop 743a62b49b70743a62b49b70 重启WEB应用容器 已经停止的容器可以使用命令docker start来启动： 123456[root@localhost admin]# docker start 743a62b49b70743a62b49b70[root@localhost admin]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES743a62b49b70 training/webapp \"python app.py\" 14 minutes ago Up 14 seconds 0.0.0.0:5000-&gt;5000/tcp infallible_allen8294ae65cc73 training/webapp \"python app.py\" 24 minutes ago Up 24 minutes 0.0.0.0:32768-&gt;5000/tcp hardcore_brown 移除WEB应用容器 使用docker rm 命令来删除不需要的容器： 1234567891011#删除容器时，容器必须是停止状态，否则会报以下错误[root@localhost admin]# docker rm 743a62b49b70Error response from daemon: You cannot remove a running container 743a62b49b70f9575690e2b85d4ea1eed94dd19fe9f6074f1d7069d977a2ecc8. Stop the container before attempting removal or force removet@localhost admin]# docker stop 743a62b49b70743a62b49b70[root@localhost admin]# docker rm 743a62b49b70743a62b49b70[root@localhost admin]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8294ae65cc73 training/webapp \"python app.py\" 26 minutes ago Up 26 minutes 0.0.0.0:32768-&gt;5000/tcp hardcore_brown Docker数据卷的管理 挂载时创建卷 挂载卷： 1234[root@localhost admin]# docker run -d -p 80:80 -v /data:/usr/share/nginx/html nginx:latest5f2530020849d15287b8bfd4dd2274945c0fd07078ab281a17e47bf2243ea113#/usr/share/nginx/html为容器内站点目录 在宿主机写入数据，查看： 12345[root@localhost admin]# echo \"http://www.nmtui.com\" &gt;/data/index.html[root@localhost admin]# curl 192.168.18.129http://www.nmtui.com#192.168.18.129为宿主机的ip地址 设置共享卷，使用同一个卷启动一个新的容器： 1234[root@localhost admin]# docker run -d -p 8080:80 -v /data:/usr/share/nginx/html nginx:latestad8ef6db5021d356f6b56a62d6aaa584ad8be7b8c8cac73cc7bd08369acf41d4[root@localhost admin]# curl 192.168.18.129:8080http://www.nmtui.com 查看卷列表： 12[root@localhost admin]# docker volume lsDRIVER VOLUME NAME 创建卷后挂载 创建一个卷： 12345[root@localhost admin]# docker volume create8bbaf77b6495bbc8e50e75dfbd945badc0fdd2d2aced2359dc8d97308fa08d92[root@localhost admin]# docker volume lsDRIVER VOLUME NAMElocal 8bbaf77b6495bbc8e50e75dfbd945badc0fdd2d2aced2359dc8d97308fa08d92 指定卷名： 123456[root@localhost admin]# docker volume create --name clsnclsn[root@localhost admin]# docker volume lsDRIVER VOLUME NAMElocal 8bbaf77b6495bbc8e50e75dfbd945badc0fdd2d2aced2359dc8d97308fa08d92local clsn 查看卷路径： 123456789101112[root@localhost admin]# docker volume inspect clsn[ &#123; \"CreatedAt\": \"2022-12-06T00:50:33-08:00\", \"Driver\": \"local\", \"Labels\": &#123;&#125;, \"Mountpoint\": \"/var/lib/docker/volumes/clsn/_data\", \"Name\": \"clsn\", \"Options\": &#123;&#125;, \"Scope\": \"local\" &#125;] 使用卷创建： 123456[root@localhost admin]# docker run -d -p 9000:80 -v clsn:/usr/share/nginx/html nginx:latest3d4e986ad050c199740ec6a2a4f38d0ba54ad78715cb72d21df396e0774f705f#宿主机测试[root@localhost admin]# echo 'blog.nmtui.com' &gt;/var/lib/docker/volumes/clsn/_data/index.html[root@localhost admin]# curl 192.168.18.129:9000blog.nmtui.com 设置卷： 12[root@localhost admin]# docker run -d -P --volumes-from 5f2530020849d15287b8bfd4dd2274945c0fd07078ab281a17e47bf2243ea113 nginx:latest5e9a1d7ea93ea7b7fb2d6918cf1cc8805aff41daa21b7e7656be1a14b2662e94 查看使用的端口： 123456789101112131415161718[root@localhost admin]# netstat -lntupActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:111 0.0.0.0:* LISTEN 595/rpcbind tcp 0 0 192.168.122.1:53 0.0.0.0:* LISTEN 1320/dnsmasq tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1074/sshd tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN 1069/cupsd tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 1352/master tcp6 0 0 :::9000 :::* LISTEN 4270/docker-proxy tcp6 0 0 :::111 :::* LISTEN 595/rpcbind tcp6 0 0 :::8080 :::* LISTEN 3992/docker-proxy tcp6 0 0 :::80 :::* LISTEN 3794/docker-proxy tcp6 0 0 :::22 :::* LISTEN 1074/sshd tcp6 0 0 ::1:631 :::* LISTEN 1069/cupsd tcp6 0 0 ::1:25 :::* LISTEN 1352/master tcp6 0 0 :::32768 :::* LISTEN 4388/docker-proxy [root@localhost admin]# curl 192.168.18.129:32768http://www.nmtui.com 手动将容器保存为镜像 启动一个centos6.8的镜像： 12345678910[root@localhost admin]# docker pull centos:6.8[root@localhost admin]# docker run -it -p 1022:22 centos:6.8 /bin/bash#在容器中安装sshd服务并修改系统密码[root@4d61bc1e379d /]# yum install openssh-server -y[root@4d61bc1e379d yum.repos.d]# echo \"root:123456\" |chpasswd[root@4d61bc1e379d yum.repos.d]# /etc/init.d/sshd startGenerating SSH2 RSA host key: [ OK ]Generating SSH1 RSA host key: [ OK ]Generating SSH2 DSA host key: [ OK ]Starting sshd: [ OK ] 启动完成后镜像进行ssh连接测试。 将容器提交为镜像： 12[root@localhost admin]# docker commit 4d61bc1e379d centos6-sshsha256:9591270dae2dda5a96c94c47e291aae0eeab7599ada3cdf44701c4dfd72e8cee 使用新的镜像启动容器： 1234567891011[root@localhost admin]# docker run -d -p 1122:22 centos6-ssh:latest /usr/sbin/sshd -D0019e8bb73550eec2526a101a19814ec92dfb045dd2fdca4d36175005e63ba20[root@localhost admin]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0019e8bb7355 centos6-ssh:latest \"/usr/sbin/sshd -D\" 30 seconds ago Up 28 seconds 0.0.0.0:1122-&gt;22/tcp blissful_albattani5e9a1d7ea93e nginx:latest \"/docker-entrypoint.…\" 2 hours ago Up 2 hours 0.0.0.0:32768-&gt;80/tcp xenodochial_kare3d4e986ad050 nginx:latest \"/docker-entrypoint.…\" 2 hours ago Up 2 hours 0.0.0.0:9000-&gt;80/tcp vibrant_bhabhaad8ef6db5021 nginx:latest \"/docker-entrypoint.…\" 2 hours ago Up 2 hours 0.0.0.0:8080-&gt;80/tcp awesome_jang5f2530020849 nginx:latest \"/docker-entrypoint.…\" 2 hours ago Up 2 hours 0.0.0.0:80-&gt;80/tcp pensive_lumiere76cf3b4dce49 ubuntu \"/bin/bash\" 8 hours ago Up 2 hours test258bbd5afb8bf ubuntu \"/bin/bash\" 8 hours ago Up 2 hours test1 进入到容器内，在容器里安装httpd服务： 12[root@localhost admin]# docker exec -it 0019e8bb7355 /bin/bash[root@0019e8bb7355 /]# yum install https -y 编写启动脚本： 123456[root@0019e8bb7355 /]# touch init.sh[root@0019e8bb7355 /]# vi init.sh#!/bin/bash /etc/init.d/httpd start /usr/sbin/sshd -D[root@0019e8bb7355 /]# chmod +x init.sh 再次提交为新的镜像： 12[root@localhost admin]# docker commit 0019e8bb7355 centos6-httpdsha256:bd9f5c339cd8494f82b8cb06396446143824f819c59c9b971687f6a9193c718a 启动镜像，做好端口映射。并在浏览器中输入宿主机的ip地址进行测试访问： 12[root@localhost admin]# docker run -d -p 1222:22 -p 88:88 centos6-httpd /init.shecbc482a781975538e7c83763fb1573af811a5baf2bc7c93de176ebd5576f407 Docker容器连接 容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过-p或-P参数来指定端口映射。下面来实现通过端口连接到一个docker容器。 网络端口映射 首先创建一个nginx容器： 123456[root@localhost admin]# docker run -d -p 80:80 nginx6675f5ad199295dd4b69f33e9b3f5b6a0e0b7b67df371f229a12e381f5083440#创建容器，做link，并进入容器中[root@localhost admin]# docker run -it --link quirky_brown:web01 centos-ssh /bin/bash#在容器中访问nginx容器是否可以ping通ping web01 使用-P绑定端口号后，使用docker ps可以看到容器端口5000绑定主机端口32770 123[root@localhost admin]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES998f4a68770c training/webapp \"python app.py\" 13 seconds ago Up 12 seconds 0.0.0.0:32770-&gt;5000/tcp angry_bassi 此外，还可以指定容器绑定的网络地址，如绑定127.0.0.1。 123456[root@localhost admin]# docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py6124b2108719c7e18b8b35992a06b3f66036ad0b951744bcfc1ca17158c2b6e3[root@localhost admin]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6124b2108719 training/webapp \"python app.py\" 6 seconds ago Up 4 seconds 127.0.0.1:5001-&gt;5000/tcp keen_sammet998f4a68770c training/webapp \"python app.py\" 4 minutes ago Up 4 minutes 0.0.0.0:32770-&gt;5000/tcp angry_bassi 这样便可以通过访问127.0.0.1:5001来访问容器的5000端口。这里默认都是绑定tcp端口，若要绑定UDP端口，则需要在端口后面加上/udp。 Docker容器互联 端口映射并不是唯一把docker连接到另一个容器的方法。docker有一个连接系统允许将多个容器连接在一起，共享连接信息。docker连接会创建一个父子关系，其中父容器可以看到子容器的信息。 容器命名 当要创建一个容器时，docker会自动对他进行命名，此外也可以使用--name标识来命名容器。 12345[root@localhost admin]# docker run -d -P --name runoob training/webapp python app.py561d0028ee9aafe9d014340ad8cecbaf7f5e395f05432e3bd149c797e5dd5f13[root@localhost admin]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES561d0028ee9a training/webapp \"python app.py\" 5 seconds ago Up 4 seconds 0.0.0.0:32771-&gt;5000/tcp runoob 连接容器 使用--link参数可以让容器之间安全的进行交互。 123456789101112131415161718192021#创建一个新的数据库容器[root@localhost admin]# docker run -d --name db training/postgresUnable to find image 'training/postgres:latest' locallylatest: Pulling from training/postgresa3ed95caeb02: Pull complete 6e71c809542e: Pull complete 2978d9af87ba: Pull complete e1bca35b062f: Pull complete 500b6decf741: Pull complete 74b14ef2151f: Pull complete 7afd5ed3826e: Pull complete 3c69bb244f5e: Pull complete d86f9ec5aedf: Pull complete 010fabf20157: Pull complete Digest: sha256:a945dc6dcfbc8d009c3d972931608344b76c2870ce796da00a827bd50791907eStatus: Downloaded newer image for training/postgres:latestef6af7333f0af9302cc6935d48be863ba2db0fdb2c56eacf42c074aa62982b12#然后创建一个新的web容器，并将他连接到db容器[root@localhost admin]# docker run -d -P --name web --link db:db training/webapp python app.py62888e6365e6551d2ceb6a6ddf7afcd39e861119f97b691b5116dba8e250e444[root@localhost admin]# 此时db容器和web容器建立了互联关系。 --link参数的格式为--link name:alias,其中name是要链接的容器的名称，alias是这个连接的别名。 此时使用docker ps来查看容器的连接： 1234[root@localhost admin]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES62888e6365e6 training/webapp \"python app.py\" 4 minutes ago Up 4 minutes 0.0.0.0:32769-&gt;5000/tcp webef6af7333f0a training/postgres \"su postgres -c '/us…\" 7 minutes ago Up 7 minutes 5432/tcp db Docker在两个互联的容器之间创建了一个安全隧道，而且不用映射他们的端口到宿主主机上、在启动db容器的时候并没有使用-p和-P标记，从而避免了暴露数据库端口到外部网络上的可能。 Docker通过2种方式为容器公开连接信息： 环境变量 更新/etc/hosts文件 使用env命令来查看web容器的环境变量： 12345678910111213[root@localhost admin]# docker run --rm --name web2 --link db:db training/webapp envPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binHOSTNAME=1621d6dd6804DB_PORT=tcp://172.17.0.2:5432DB_PORT_5432_TCP=tcp://172.17.0.2:5432DB_PORT_5432_TCP_ADDR=172.17.0.2DB_PORT_5432_TCP_PORT=5432DB_PORT_5432_TCP_PROTO=tcpDB_NAME=/web2/dbDB_ENV_PG_VERSION=9.3HOME=/root#DB_开头的环境变量是供web容器连接db容器使用，前缀采用大写的连接别名 除了环境变量，Docker还添加host信息到父容器的/etc/hosts的文件。下面是父容器web的hosts文件： 123456789101112[root@localhost admin]# docker run -t -i --rm --link db:db training/webapp /bin/bashroot@5f57b7dcc730:/opt/webapp# cat /etc/hosts127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.17.0.2 db ef6af7333f0a172.17.0.4 5f57b7dcc730#这里有2个host，第一个是web容器，web容器用id作为它的主机名。第二个是db容器的ip和主机名 在web容器中安装ping命令来测试是否跟db容器的连通： 123456root@5f57b7dcc730:/opt/webapp# apt-get install -yqq inetutils-pingroot@5f57b7dcc730:/opt/webapp# ping dbPING db (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.740 ms64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.089 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.075 ms 用ping来测试db容器，它会解析成172.17.0.2。 注意：官方的Ubuntu镜像默认没有安装ping，因此需要自行安装。 用户可以链接多个父容器到子容器，比如可以链接多个web到db容器上。 Docker仓库管理 仓库是集中存放镜像的地方，目前Docker官方维护了一个公共仓库Docker Hub，大部分需求的镜像都可以通过在Docker Hub中直接找到。 登录和登出 若还没有Docker账号，可在 https://hub.docker.com 上免费注册一个。然后输入用户名和密码登录，登录成功后便可以从Docker hub上拉去自己账号下的全部镜像。 12345[root@localhost admin]# docker loginLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.Username: tangmenjuePassword: Login Succeeded 使用docker logout命令可以登出Docker hub。 拉取镜像 使用docker search命令可以查找官方仓库中的镜像，并利用docker pull命令将其下载到本地，例如要下载ubuntu镜像，操作如下： 1234567891011121314151617[root@localhost admin]# docker search ubuntuNAME DESCRIPTION STARS OFFICIAL AUTOMATEDubuntu Ubuntu is a Debian-based Linux operating sys… 15312 [OK] websphere-liberty WebSphere Liberty multi-architecture images … 290 [OK] ubuntu-upstart DEPRECATED, as is Upstart (find other proces… 112 [OK] neurodebian NeuroDebian provides neuroscience research s… 97 [OK] ubuntu/nginx Nginx, a high-performance reverse proxy &amp; we… 69 open-liberty Open Liberty multi-architecture images based… 56 [OK] ubuntu/apache2 Apache, a secure &amp; extensible open-source HT… 50 ubuntu-debootstrap DEPRECATED; use \"ubuntu\" instead 49 [OK] ...[root@localhost admin]# docker pull ubuntuUsing default tag: latestlatest: Pulling from library/ubuntu7b1a6ab2e44d: Pull complete Digest: sha256:626ffe58f6e7566e00254b638eb7e0f3b11d4da9675088f4781a50ae288f3322Status: Downloaded newer image for ubuntu:latest 推送镜像 用户登录后，可以通过docker push命令将自己的镜像推送到Docker Hub，如： 12345678910111213141516171819202122232425262728293031323334#查看目前已有的镜像root@localhost admin]# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 5d0da3dc9764 14 months ago 231MBcentos 6.7 9f1de3c6ad53 3 years ago 191MBcentos 6.8 82f3b5f3c58f 3 years ago 195MBubuntu 15.10 9b9cb95443b5 6 years ago 137MBtraining/webapp latest 6fae60ef3446 7 years ago 349MBtraining/postgres latest 6fa973bb3c26 8 years ago 365MB#给ubuntu:15.10镜像打上标签，以下的tangmenjue都要替换成自己的Docker账号用户名[root@localhost admin]# docker tag ubuntu:15.10 tangmenjue/ubuntu:15.10#查看镜像的变化[root@localhost admin]# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 5d0da3dc9764 14 months ago 231MBcentos 6.7 9f1de3c6ad53 3 years ago 191MBcentos 6.8 82f3b5f3c58f 3 years ago 195MBubuntu 15.10 9b9cb95443b5 6 years ago 137MBtangmenjue/ubuntu 15.10 9b9cb95443b5 6 years ago 137MBtraining/webapp latest 6fae60ef3446 7 years ago 349MBtraining/postgres latest#将自己的镜像推送到Docker Hub[root@localhost admin]# docker push tangmenjue/ubuntu:15.10The push refers to repository [docker.io/tangmenjue/ubuntu]98d59071f692: Pushed af288f00b8a7: Pushed 4b955941a4d0: Mounted from library/ubuntu f121afdbbd5d: Pushed 15.10: digest: sha256:cc56b237986f2b9282f058cc7875ff5e9d0d9081934c8982ea1ec21288eeefeb size: 1150[root@localhost admin]# docker search tangmenjue/ubuntuNAME DESCRIPTION STARS OFFICIAL AUTOMATEDtangmenjue/ubuntu 0","categories":[{"name":"Docker","slug":"Docker","permalink":"http://tangmenjue.top/categories/Docker/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://tangmenjue.top/tags/Docker/"},{"name":"应用部署","slug":"应用部署","permalink":"http://tangmenjue.top/tags/%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/"}]},{"title":"企微应用之python开发","slug":"企微应用之python开发","date":"2022-11-21T08:26:24.000Z","updated":"2022-12-14T16:19:51.341Z","comments":true,"path":"2022/11/21/企微应用之python开发/","link":"","permalink":"http://tangmenjue.top/2022/11/21/%E4%BC%81%E5%BE%AE%E5%BA%94%E7%94%A8%E4%B9%8Bpython%E5%BC%80%E5%8F%91/","excerpt":"","text":"创建应用 创建准备 成功注册企业微信企业 企业微信账号拥有当前企业的超级管理员或分级管理员的权限 创建应用 登录 企业微信管理后台，在【应用管理】界面-【应用】-【自建】点击【创建应用】，在弹出框填写应用的图标、标题、描述和可见范围基本信息。填写完成后，点击【创建应用】，将会跳转至应用详情页面。 配置信息 可见范围 在【应用管理】界面-【应用】-【自建】点击刚刚创建好的应用，进入应用信息页面，点击编辑。 点击可见范围旁边的添加，即可编辑可见范围。 应用主页 配置成员从工作台打开应用时打开的页面URL，假设应用打开的网页为:http://tangmenjue.top/。 在应用信息页面点击编辑，点击应用主页旁边的设置，即可配置工作台打开的应用主页。 配置完成后，在可见范围内的成员，将在工作台看到该应用。 配置HOST 为了能在本地进行开发，需要将应用URL的访问指向本地。Window系统下打开C:，右键点击hosts，选择使用记事本打开，在文件末尾增加代码如下： 12127.0.0.1 localhost127.0.0.1 tangmenjue.top 获取应用接口凭证 获取企业ID corp_id 在登录管理后台后，在【管理后台】-【我的企业】-【企业信息】页面的最下面，便可找到【企业ID】 获取应用 Secret 在应用信息页面便可查看Secret 将Secret发送到企业微信中查看，点击【发送】，则在操作者的企业微信会话中，会收到企业微信推送过来的Secret信息 获取应用接口凭证 access_token access_token由corpid和secret产生，所有接口在通信时都需要携带此信息用于验证接口的访问权限。 借助PostMan接口工具进行获取：https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=id&amp;corpsecret=secret，链接里的id自行替换为实际的corp_id值，secret自行替换为实际的secret值。 打开PostMan，在左上角处点击Create collection 然后继续点击Add a request 在新弹出的窗口的Get输入框里输入，点击Send： 然后便可在Body处看到获取的access_token值： 本地配置项目信息 下载官方代码示例 从企业微信企业自建应用开发代码示例里下载官方代码示例，下载解压后使用VS打开项目代码。在 /configs 目录将 main.config.demo.js 复制一份到 main.config.js 文件，并根据实际项目情况补充corp_id、app_secret等信息。 安装启动服务 在一下载的示例代码项目根目录下，使用cmd执行以下代码： 12345#安装依赖cnpm install#启动后端服务cnpm run buildcnpm run start 访问示例页面 在浏览器中访问http://localhost:3000便可访问示例页面 发送应用信息 通过向企业微信信息推送接口POST对应的消息结构体即可实现应用消息的推送。对应的请求地址为：https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=ACCESS_TOKEN。 基本参数 调用接口凭证 access_token 作为 URL Params 带在请求的 URL 中。 应用的id agent_id 代表当前发送消息的应用 ID，可在应用的设置页面查看。 消息接收范围 touser、toparty、totag 分别表示接收消息的 成员、部门、标签，这几个范围标记不能同时为空。 消息类型 msgtype 用于指定消息的类型，当指定某一消息类型之后，接口服务只会读取该类型对应字段下的数据。 消息内容 不同的消息类型，会对应不同的消息内容字段。 基本流程 发送基本类型消息 文本、图文消息、markdown类型的消息仅需要直接在业务后台服务器直接向企业微信消息推送接口发送对应的数据请求即可。 在示例代码的/server/messageController.js 文件中展示了向消息推送 Api 接口发送消息数据体的基本流程： 1234567891011121314151617181920212223242526272829const axios = require('axios');const AccessToken = require('./accesstoken');const Config = require('../configs/main.config.js');module.exports = function(router) &#123; // 发送推送消息 router.post('/message/send', async function (req, res, next) &#123; // 从前端请求中获取对应的参数 let &#123;form:form_parames&#125; = req.body || &#123;&#125;; // 将 agentid 拼入请求的结构体中 let request_data = &#123; ...form_parames, agentid:Config.agent_id, &#125;; request_data.safe = form_parames.safe ? '1' : '0'; // 获取 Access Token const access_token = await AccessToken.getToken(); // 向消息推送的 Api 发送对应的数据结构体 const &#123;data&#125; = await axios.post('https://qyapi.weixin.qq.com/cgi-bin/message/send', request_data, &#123; params: &#123; access_token &#125; &#125;); // 返回请求的结果 res.send(data); &#125;); &#125;; 发送媒体类型消息 当要推送图片、语言、适配、文件等媒体类型的消息时，需要将对应的文件通过临时素材的接口上传至企业微信的临时素材库。 在示例代码的 /server/mediaController.js 文件中，展示了通过企业微信临时素材接口上传临时素材的基本流程： 123456789101112131415161718192021222324252627282930313233const FormData = require('form-data');const axios = require('axios');const AccessToken = require('./accesstoken');module.exports = function(router) &#123; router.post('/media/upload', async function (req, res, next) &#123; let &#123;media:file&#125; = req.files || &#123;&#125;; console.log(req.files); let &#123;type&#125; = req.body || &#123;&#125; ; const access_token = await AccessToken.getToken(); // 组件一个form，用来上传文件 const form = new FormData(); form.append('filename', file.name); form.append('filelength', file.size); form.append('media',file.data,file.name); const &#123;data&#125; = await axios.post('https://qyapi.weixin.qq.com/cgi-bin/media/upload', form, &#123; params: &#123; access_token, type &#125;, headers: &#123; \"Content-Type\": \"multipart/form-data\" &#125;, &#125;); console.log(data); res.send(data); &#125;);&#125;; 获取登录用户信息 企业微信提供了OAuth的授权登录方式，可以从企业微信终端打开的网页获取成员的身份信息，从而免去登录的环节。 配置可信域名 为了保证访问授权的安全性，需要配置授权链接URL所在域名为可信域名。在【应用详情】-【开发者接口】-【网页授权及 JS-SDK】，点击【设置可信域名】，在【设置可信域名】弹窗，填写网页授权功能的回调域名it.zsnet.net.cn，网页授权回调域名的配置须与实际访问链接的域名完全一致： 构造网页授权链接 以下由几个URL要注意区别： 应用主页URL 从工作台点击打开的页面URL，在创建应用时配置填写的，用来授权链接URL跳转。 重定向URL 当用户授权成功后，会带着成员授权code跳转的URL，用来接收code并获取成员身份 授权链接URL 企业微信名下的URL，包含了suite_id、重定向URL等信息，当企业微信服务参数验证成功后，会跳转到重定向URL 在示例代码的 /routes/index.js 文件中，展示了构造网页授权链接的基本流程： 1234router.get(Config.home_path, function (req, res, next) &#123; const login_url = getLoginURL('base'); res.redirect(login_url);&#125;); 解析成员授权code 企业成员从工作台点击应用，打开应用主页URL，向授权链接URL跳转；企业微信对授权链接上的信息进行校验之后，会重定向URL跳转，并以query的形式带上当前访问成员的code信息。 在示例代码的 /routes/index.js 文件中，展示了从重定向URL里解析成员授权code的基本流程： 12345678910111213router.get(Config.app_path, async function (req, res, next) &#123; let &#123; code &#125; = req.query; if (code) &#123; let access_token = await AccessToken.getToken(); if (access_token) &#123; let &#123; data: user_data &#125; = await axios.get(`https://qyapi.weixin.qq.com/cgi-bin/user/getuserinfo?access_token=$&#123;access_token&#125;&amp;code=$&#123;code&#125;`); console.log('获取 user_data 成功', user_data) let user_id = user_data.UserId; &#125; else &#123; res.render('error'); &#125; &#125; 获取访问用户身份信息 在解析出成员授权code之后，使用access_token，调用获取访问用户身份的接口，即可得到访问用户的基本信息user_id，若想访问用户更详细的信息，则需要通过读取成员得到用户的姓名、头像等完整信息。 在示例代码的 /routes/index.js 文件中，展示了从重定向URL里解析成员授权code的基本流程： 12345678910111213router.get(Config.app_path, async function (req, res, next) &#123; let &#123; code &#125; = req.query; if (code) &#123; let access_token = await AccessToken.getToken(); if (access_token) &#123; let &#123; data: user_detail_data &#125; = await axios.get(`https://qyapi.weixin.qq.com/cgi-bin/user/get?access_token=$&#123;access_token&#125;&amp;userid=$&#123;user_id&#125;`); console.log('获取成员详细信息成功', user_detail_data); req.session.user = user_detail_data; &#125; else &#123; res.render('error'); &#125; &#125; 实操过程 借助PostMan接口工具获取用户的userid（用手机号获取）：https://qyapi.weixin.qq.com/cgi-bin/user/getuserid?access_token=ACCESS_TOKEN，链接里的ACCESS_TOKEN自行替换为实际的access_token值。 打开PostMan，在左上角New collection处右键选择Add collection： 点击新弹出的窗口的Get输入框选择POST，输入链接，选择下方的Body，选择row，填写对应的参数后，点击Send： 然后便可在下方的Body处看到userid的值： 向成员发送信息 调用企业内部的开放接口，都需要带上企业的接口凭证，且必须以 query 参数形式传递。而应用消息推送接口需要指定当前应用的 agent_id。 企业微信的应用消息推送支持不同的消息类型，比如文本、图片、语音、文件等，不同类型的消息类型需要指定对应的消息种类 msgtype。 在示例代码的 /routes/index.js 文件中，编写向成员发送信息的代码如下： 123456789101112131415161718router.get(Config.app_path, async function (req, res, next) &#123; let &#123; code &#125; = req.query; if (code) &#123; let access_token = await AccessToken.getToken(); if (access_token) &#123; let &#123;data:message_data&#125; = await axios.post(`https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=$&#123;access_token&#125;`, &#123;\"touser\" : user_detail_data.userid, \"agentid\" : agent_id, \"msgtype\" : \"text\", \"text\" : &#123; \"content\" : `Hello World! $&#123;user_detail_data.name&#125;`&#125;, &#125;) &#125; else &#123; res.render('error'); &#125; &#125; 实操过程 参数说明： 参数 是否必须 说明 touser 否 指定接收消息的成员，成员ID列表（多个接收者用‘|’分隔，最多支持1000个）。 特殊情况：指定为\"@all\"，则向该企业应用的全部成员发送 toparty 否 指定接收消息的部门，部门ID列表，多个接收者用‘|’分隔，最多支持100个。 当touser为\"@all\"时忽略本参数 totag 否 指定接收消息的标签，标签ID列表，多个接收者用‘|’分隔，最多支持100个。 当touser为\"@all\"时忽略本参数 msgtype 是 消息类型，此时固定为：text agentid 是 企业应用的id，整型。企业内部开发，可在应用的设置页面查看；第三方服务商，可通过接口 获取企业授权信息 获取该参数值 content 是 消息内容，最长不超过2048个字节，超过将截断（支持id转译） safe 否 表示是否是保密消息，0表示可对外分享，1表示不能分享且内容显示水印，默认为0 enable_id_trans 否 表示是否开启id转译，0表示否，1表示是，默认0。仅第三方应用需要用到，企业自建应用可以忽略。 enable_duplicate_check 否 表示是否开启重复消息检查，0表示否，1表示是，默认0 duplicate_check_interval 否 表示是否重复消息检查的时间间隔，默认1800s，最大不超过4小时 注意：touser、toparty、totag不能同时为空。 若操作过程中出现IP不合法的错误，在应用信息页面将IP添加进企业可信IP里便可正常访问。 借助PostMan接口工具进行发送信息：https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=ACCESS_TOKEN，链接里的ACCESS_TOKEN自行替换为实际的access_token值。 打开PostMan，在左上角New collection处右键选择Add collection。点击新弹出的窗口的Get输入框选择POST，输入链接，选择下方的Body，选择row，填写对应的参数后，点击Send： 然后便可在下方的Body处看到已经信息发送成功。","categories":[{"name":"企业微信","slug":"企业微信","permalink":"http://tangmenjue.top/categories/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1/"},{"name":"应用开发","slug":"应用开发","permalink":"http://tangmenjue.top/categories/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"企业微信","slug":"企业微信","permalink":"http://tangmenjue.top/tags/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1/"},{"name":"应用开发","slug":"应用开发","permalink":"http://tangmenjue.top/tags/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"企业微信之企业应用开发流程","slug":"企业微信之企业应用开发流程","date":"2022-11-18T08:26:24.000Z","updated":"2022-11-18T16:04:44.788Z","comments":true,"path":"2022/11/18/企业微信之企业应用开发流程/","link":"","permalink":"http://tangmenjue.top/2022/11/18/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E4%B9%8B%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/","excerpt":"","text":"创建应用 创建准备 成功注册企业微信企业 企业微信账号拥有当前企业的超级管理员或分级管理员的权限 创建应用 登录 企业微信管理后台，在【应用管理】界面-【应用】-【自建】点击【创建应用】，在弹出框填写应用的图标、标题、描述和可见范围基本信息。填写完成后，点击【创建应用】，将会跳转至应用详情页面。 配置信息 可见范围 在【应用管理】界面-【应用】-【自建】点击刚刚创建好的应用，进入应用信息页面，点击编辑。 点击可见范围旁边的添加，即可编辑可见范围。 应用主页 配置成员从工作台打开应用时打开的页面URL，假设应用打开的网页为:http://it.zs.gdtel.com/#/。 在应用信息页面点击编辑，点击应用主页旁边的设置，即可配置工作台打开的应用主页。 配置完成后，在可见范围内的成员，将在工作台看到该应用。 配置HOST 为了能在本地进行开发，需要将应用URL的访问指向本地。Window系统下打开C:，右键点击hosts，选择使用记事本打开，在文件末尾增加代码如下： 12127.0.0.1 localhost127.0.0.1 tangmenjue.top 获取应用接口凭证 获取企业ID corp_id 在登录管理后台后，在【管理后台】-【我的企业】-【企业信息】页面的最下面，便可找到【企业ID】 获取应用 Secret 在应用信息页面便可查看Secret 将Secret发送到企业微信中查看，点击【发送】，则在操作者的企业微信会话中，会收到企业微信推送过来的Secret信息 获取应用接口凭证 access_token access_token由corpid和secret产生，所有接口在通信时都需要携带此信息用于验证接口的访问权限。 借助PostMan接口工具进行获取：https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=id&amp;corpsecret=secret，链接里的id自行替换为实际的corp_id值，secret自行替换为实际的secret值。 打开PostMan，在左上角处点击Create collection 然后继续点击Add a request 在新弹出的窗口的Get输入框里输入，点击Send： 然后便可在Body处看到获取的access_token值： 本地配置项目信息 下载官方代码示例 从企业微信企业自建应用开发代码示例里下载官方代码示例，下载解压后使用VS打开项目代码。在 /configs 目录将 main.config.demo.js 复制一份到 main.config.js 文件，并根据实际项目情况补充corp_id、app_secret等信息。 安装启动服务 在一下载的示例代码项目根目录下，使用cmd执行以下代码： 12345#安装依赖cnpm install#启动后端服务cnpm run buildcnpm run start 访问示例页面 在浏览器中访问http://localhost:3000便可访问示例页面 发送应用信息 通过向企业微信信息推送接口POST对应的消息结构体即可实现应用消息的推送。对应的请求地址为：https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=ACCESS_TOKEN。 基本参数 调用接口凭证 access_token 作为 URL Params 带在请求的 URL 中。 应用的id agent_id 代表当前发送消息的应用 ID，可在应用的设置页面查看。 消息接收范围 touser、toparty、totag 分别表示接收消息的 成员、部门、标签，这几个范围标记不能同时为空。 消息类型 msgtype 用于指定消息的类型，当指定某一消息类型之后，接口服务只会读取该类型对应字段下的数据。 消息内容 不同的消息类型，会对应不同的消息内容字段。 基本流程 发送基本类型消息 文本、图文消息、markdown类型的消息仅需要直接在业务后台服务器直接向企业微信消息推送接口发送对应的数据请求即可。 在示例代码的/server/messageController.js 文件中展示了向消息推送 Api 接口发送消息数据体的基本流程： 1234567891011121314151617181920212223242526272829const axios = require('axios');const AccessToken = require('./accesstoken');const Config = require('../configs/main.config.js');module.exports = function(router) &#123; // 发送推送消息 router.post('/message/send', async function (req, res, next) &#123; // 从前端请求中获取对应的参数 let &#123;form:form_parames&#125; = req.body || &#123;&#125;; // 将 agentid 拼入请求的结构体中 let request_data = &#123; ...form_parames, agentid:Config.agent_id, &#125;; request_data.safe = form_parames.safe ? '1' : '0'; // 获取 Access Token const access_token = await AccessToken.getToken(); // 向消息推送的 Api 发送对应的数据结构体 const &#123;data&#125; = await axios.post('https://qyapi.weixin.qq.com/cgi-bin/message/send', request_data, &#123; params: &#123; access_token &#125; &#125;); // 返回请求的结果 res.send(data); &#125;); &#125;; 发送媒体类型消息 当要推送图片、语言、适配、文件等媒体类型的消息时，需要将对应的文件通过临时素材的接口上传至企业微信的临时素材库。 在示例代码的 /server/mediaController.js 文件中，展示了通过企业微信临时素材接口上传临时素材的基本流程： 123456789101112131415161718192021222324252627282930313233const FormData = require('form-data');const axios = require('axios');const AccessToken = require('./accesstoken');module.exports = function(router) &#123; router.post('/media/upload', async function (req, res, next) &#123; let &#123;media:file&#125; = req.files || &#123;&#125;; console.log(req.files); let &#123;type&#125; = req.body || &#123;&#125; ; const access_token = await AccessToken.getToken(); // 组件一个form，用来上传文件 const form = new FormData(); form.append('filename', file.name); form.append('filelength', file.size); form.append('media',file.data,file.name); const &#123;data&#125; = await axios.post('https://qyapi.weixin.qq.com/cgi-bin/media/upload', form, &#123; params: &#123; access_token, type &#125;, headers: &#123; \"Content-Type\": \"multipart/form-data\" &#125;, &#125;); console.log(data); res.send(data); &#125;);&#125;; 获取登录用户信息 企业微信提供了OAuth的授权登录方式，可以从企业微信终端打开的网页获取成员的身份信息，从而免去登录的环节。 配置可信域名 为了保证访问授权的安全性，需要配置授权链接URL所在域名为可信域名。在【应用详情】-【开发者接口】-【网页授权及 JS-SDK】，点击【设置可信域名】，在【设置可信域名】弹窗，填写网页授权功能的回调域名it.zsnet.net.cn，网页授权回调域名的配置须与实际访问链接的域名完全一致： 构造网页授权链接 以下由几个URL要注意区别： 应用主页URL 从工作台点击打开的页面URL，在创建应用时配置填写的，用来授权链接URL跳转。 重定向URL 当用户授权成功后，会带着成员授权code跳转的URL，用来接收code并获取成员身份 授权链接URL 企业微信名下的URL，包含了suite_id、重定向URL等信息，当企业微信服务参数验证成功后，会跳转到重定向URL 在示例代码的 /routes/index.js 文件中，展示了构造网页授权链接的基本流程： 1234router.get(Config.home_path, function (req, res, next) &#123; const login_url = getLoginURL('base'); res.redirect(login_url);&#125;); 解析成员授权code 企业成员从工作台点击应用，打开应用主页URL，向授权链接URL跳转；企业微信对授权链接上的信息进行校验之后，会重定向URL跳转，并以query的形式带上当前访问成员的code信息。 在示例代码的 /routes/index.js 文件中，展示了从重定向URL里解析成员授权code的基本流程： 12345678910111213router.get(Config.app_path, async function (req, res, next) &#123; let &#123; code &#125; = req.query; if (code) &#123; let access_token = await AccessToken.getToken(); if (access_token) &#123; let &#123; data: user_data &#125; = await axios.get(`https://qyapi.weixin.qq.com/cgi-bin/user/getuserinfo?access_token=$&#123;access_token&#125;&amp;code=$&#123;code&#125;`); console.log('获取 user_data 成功', user_data) let user_id = user_data.UserId; &#125; else &#123; res.render('error'); &#125; &#125; 获取访问用户身份信息 在解析出成员授权code之后，使用access_token，调用获取访问用户身份的接口，即可得到访问用户的基本信息user_id，若想访问用户更详细的信息，则需要通过读取成员得到用户的姓名、头像等完整信息。 在示例代码的 /routes/index.js 文件中，展示了从重定向URL里解析成员授权code的基本流程： 12345678910111213router.get(Config.app_path, async function (req, res, next) &#123; let &#123; code &#125; = req.query; if (code) &#123; let access_token = await AccessToken.getToken(); if (access_token) &#123; let &#123; data: user_detail_data &#125; = await axios.get(`https://qyapi.weixin.qq.com/cgi-bin/user/get?access_token=$&#123;access_token&#125;&amp;userid=$&#123;user_id&#125;`); console.log('获取成员详细信息成功', user_detail_data); req.session.user = user_detail_data; &#125; else &#123; res.render('error'); &#125; &#125; 实操过程 借助PostMan接口工具获取用户的userid（用手机号获取）：https://qyapi.weixin.qq.com/cgi-bin/user/getuserid?access_token=ACCESS_TOKEN，链接里的ACCESS_TOKEN自行替换为实际的access_token值。 打开PostMan，在左上角New collection处右键选择Add collection： 点击新弹出的窗口的Get输入框选择POST，输入链接，选择下方的Body，选择row，填写对应的参数后，点击Send： 然后便可在下方的Body处看到userid的值： 向成员发送信息 调用企业内部的开放接口，都需要带上企业的接口凭证，且必须以 query 参数形式传递。而应用消息推送接口需要指定当前应用的 agent_id。 企业微信的应用消息推送支持不同的消息类型，比如文本、图片、语音、文件等，不同类型的消息类型需要指定对应的消息种类 msgtype。 在示例代码的 /routes/index.js 文件中，编写向成员发送信息的代码如下： 123456789101112131415161718router.get(Config.app_path, async function (req, res, next) &#123; let &#123; code &#125; = req.query; if (code) &#123; let access_token = await AccessToken.getToken(); if (access_token) &#123; let &#123;data:message_data&#125; = await axios.post(`https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=$&#123;access_token&#125;`, &#123;\"touser\" : user_detail_data.userid, \"agentid\" : agent_id, \"msgtype\" : \"text\", \"text\" : &#123; \"content\" : `Hello World! $&#123;user_detail_data.name&#125;`&#125;, &#125;) &#125; else &#123; res.render('error'); &#125; &#125; 实操过程 参数说明： 参数 是否必须 说明 touser 否 指定接收消息的成员，成员ID列表（多个接收者用‘|’分隔，最多支持1000个）。 特殊情况：指定为\"@all\"，则向该企业应用的全部成员发送 toparty 否 指定接收消息的部门，部门ID列表，多个接收者用‘|’分隔，最多支持100个。 当touser为\"@all\"时忽略本参数 totag 否 指定接收消息的标签，标签ID列表，多个接收者用‘|’分隔，最多支持100个。 当touser为\"@all\"时忽略本参数 msgtype 是 消息类型，此时固定为：text agentid 是 企业应用的id，整型。企业内部开发，可在应用的设置页面查看；第三方服务商，可通过接口 获取企业授权信息 获取该参数值 content 是 消息内容，最长不超过2048个字节，超过将截断（支持id转译） safe 否 表示是否是保密消息，0表示可对外分享，1表示不能分享且内容显示水印，默认为0 enable_id_trans 否 表示是否开启id转译，0表示否，1表示是，默认0。仅第三方应用需要用到，企业自建应用可以忽略。 enable_duplicate_check 否 表示是否开启重复消息检查，0表示否，1表示是，默认0 duplicate_check_interval 否 表示是否重复消息检查的时间间隔，默认1800s，最大不超过4小时 注意：touser、toparty、totag不能同时为空。 若操作过程中出现IP不合法的错误，在应用信息页面将IP添加进企业可信IP里便可正常访问。 借助PostMan接口工具进行发送信息：https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=ACCESS_TOKEN，链接里的ACCESS_TOKEN自行替换为实际的access_token值。 打开PostMan，在左上角New collection处右键选择Add collection。点击新弹出的窗口的Get输入框选择POST，输入链接，选择下方的Body，选择row，填写对应的参数后，点击Send： 然后便可在下方的Body处看到已经信息发送成功。","categories":[{"name":"企业微信","slug":"企业微信","permalink":"http://tangmenjue.top/categories/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1/"},{"name":"应用开发","slug":"应用开发","permalink":"http://tangmenjue.top/categories/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"企业微信","slug":"企业微信","permalink":"http://tangmenjue.top/tags/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1/"},{"name":"应用开发","slug":"应用开发","permalink":"http://tangmenjue.top/tags/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"CentOS 7之关于网络管理的那些知识","slug":"CentOS 7之关于网络管理的那些知识","date":"2022-11-16T08:15:26.000Z","updated":"2022-11-18T01:14:14.000Z","comments":true,"path":"2022/11/16/CentOS 7之关于网络管理的那些知识/","link":"","permalink":"http://tangmenjue.top/2022/11/16/CentOS%207%E4%B9%8B%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E7%9A%84%E9%82%A3%E4%BA%9B%E7%9F%A5%E8%AF%86/","excerpt":"","text":"前置知识 Linux常见目录 目录参数 说明 / 根目录，文件的最顶端，/etc、/bin、/dev、/lib、/sbin应和根目录放置在一个分区中，而类似/usr/local可以单独位于另一个分区 /bin 存放系统所需的重要命令，如文件或目录操作的命令ls、cp、mkdir等。/usr/bin也存放了一些系统命令，这些命令对于的文件都是可执行的，普通用户可以使用大部分的命令 /boot 存放Linux启动时内核及引导系统程序所需要的核心文件，内核文件和grub系统引导管理器都位于此目录 /dev 存放Linux系统下的设备文件，如光驱、磁盘等。访问该目录下的文件相当于访问某个硬件设备，常用于挂载光驱 /etc 存放系统的配置文件，作为一些软件启动时默认配置文件读取的目录，如/etc/fstab存放系统分区信息 /home 系统默认的用户主目录。若添加用户时不指定用户的主目录，默认在/home下创建与用户名同名的文件夹。代码中可以用HOME环境变量表示当前用户的主目录 /lib 64位系统有/lib64文件夹，主要存放动态链接库，类似的目录还有/usr/lib、/usr/local/lib等 /lost+found 存放一些当系统意外崩溃或机器意外关机时产生的文件碎片 /mnt 存放挂载储存设备的挂载目录，如光驱等 /proc 存放操作系统运行时的运行信息，如进程信息、内核信息、网络信息等。此目录的内容存在于内存中，实际不占用磁盘空间。如/etc/cpuinfo存放CPU相关信息 /root Linux超级权限用户root的主目录 /sbin 存放一些系统管理的命令，一般只能由超级权限用户root执行。大多数命令普通用户一般无权执行，如/sbin/ifconfig，普通用户使用绝对路径也可执行，用于查看当前系统网络配置，如/usr/sbin、/usr/local/sbin /tmp 临时文件目录，任何人都可以访问。系统软件或用户运行程序时产生的临时文件存放到这里。此目录数据需要定期清除，重要数据不能放在该目录下，其目录空间也不能过小 /usr: 应用程序存放目录，如命令、帮助文件等。安装Linux软件包时默认安装到/usr/local目录下，如/usr/share/fonts存放系统字体，/usr/share/man存放帮助文档，/usr/include存放软件的头文件等。建议将/usr/local目录单独分区并设置较大的磁盘空间 /var /var/log存放系统日志，/var/lib存放系统库文件。目录内容会经常变动 /sys 与/proc类似，是一个虚拟的文件系统，主要记录与系统核心相关的信息，如系统已经载入的模块信息等，该目录实际不占硬盘容量 网络管理协议 TCP/IP协议 TCP/IP协议体系 TCP/IP协议主要包含传输控制协议（TCP）和网际协议（IP）。 TCP/IP体系是一种分层结构，由基于硬件层次上的4个概念层次构成，从上往下看，即为应用层、传输层、网际互联层和网络接口层。 TCP/IP层次 功能及作用 应用层 为用户提供所需要的各自应用服务，如FTP、Telnet、DNS、SMTP等 传输层 为应用层提供端到端的通信功能，同时提供流量控制，确保数据完整和正确。TCP协议位于该层，提供一种可靠的、面向连接的数据传输服务，对之对应的是UDP协议，提供不可靠的、无连接的数据报传输服务 网际互联层 解决主机到主机之间的通信问题。其主要协议有：网际协议（IP）、地址解析协议（ARP）、反向地址解析协议（RARP）和互联网控制报文协议（ICMP） 网络接口层 为上层提供服务，完成链路控制等功能 包（packet） 包（packet）是网络上传输的数据片段，也称为分组或IP数据报。用户数据按照规定划分为大小适中的若干组，每个组加上包头构成一个包，该过程便称为封装。网络上使用包为单位进行数据传输。 包是一种统称，在不同的层次，包有不同的名字。如TCP/IP中称作帧，而IP层称之为IP数据报，TCP层称之为TCP报文等。 网络字节顺序 TCP/IP协议定义了一种所有机器在互联网分组的二进制字段中必须使用的网络标准字节顺序，与之对应的是主机字节顺序，主机字节顺序和各个主机密切相关。 传输时需遵循以下转换规则：主机字节顺序→网络字节顺序→主机字节顺序。 即发送方将主机字节顺序的整数转换为网络字节顺序后发送出去，接收方收到数据后将网络字节顺序的整数转换为自己的主机字节顺序，然后再进行处理。 地址解析协议（ARP） TCP/IP网络使用IP地址进行寻址，IP包在IP层实现路由选择，但IP包在网络接口层的传输却需要知道设备的物理地址，此时便需要一种IP地址到物理地址的转换协议ARP。 ARP协议是一种在以太网这种有广播能力的网络中解决地址转换问题的方法，该方法允许在不重新编译代码、不需维护一个集中式数据库的情况下，在网络中动态增加新机器。 其原理为：当主机A想转换某一IP地址时，通过向网络中广播一个专门的报文分组，要求具有该IP地址的机器以其物理地址做出应答。所有主机都将收到这个请求，但只有符合条件的主机才辨认该IP地址，同时发回一个包括其物理地址的应答。主机A收到应答时便知道该IP地址对应的物理地址，并使用这个地址将数据分组发过去。 UDP协议 UDP是一种无连接的传输层协议，主要用于不要求分组顺序到达的传输中。其优点为资源消耗小、处理速度快。由于其不提供数据包分组、组装和不能对数据包进行排序的缺点，当报文发送后，无法得知其是否安全完整到达的，因此UDP协议丢包会比较严重。 ICMP协议 ICMP协议是Internet控制报文协议，属于TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制信息。控制信息是指网络是否通畅、主机是否可达、路由是否可用等网络本身的信息，其唯一的功能是报告问题，而不是纠正错误，纠错的任务由发送方完成。 网络管理命令 Ping：检查网络连接速度及网络是否通畅 ping常用于测试与目标主机或域名是否可达。ping的结果通常是可信的（部分服务器设置了禁止ping的除外） ping命令不会自动终止，需要按\"ctrl+c\"终止，或是用参数\"-c\"指定要求完成的回应次数。 在CenOS 7中，ping的常用命令如下： 1234567891011#ping目的ip地址如192.168.3.100ping 192.168.3.100#ping外网域名如www.baidu.comping www.baidu.com#ping目的ip地址n次，下面命令中的n为次数ping -c n 192.168.3.100#以0.01s的时间间隔来ping目的ip地址3次，下面命令中的0.01为指定的时间间隔0.01秒ping -c 3 -i 0.01 192.168.3.100 ifconfig:配置网络或显示当前网络接口状态 ifonfig命令可以用于查看、配置、启用或禁用指定网络接口，如配置网卡的IP地址、掩码、广播地址、网关等。 在CenOS 7中，查看网卡基本信息： 查看指定网络接口ens33的信息： 其中： 第一行：UP表示该网络接口为启用状态。RUNNING表示网卡设备已连接，MULTICAST表示组播，mtu为数据包最大传输单元 第二行：网卡IP、子网掩码、广播地址 第三行：IPv6地址 第四行：ether为网卡的MAC地址，Ethernet表示连接类型 第五行：接收数据包个数、大小统计信息 第六行：异常接收数据包的数量，如丢包量、错误等 第七行：发送数据包个数、大小统计信息 第八行：产生错误数据包的数量，如丢包量，错误等 ifconfig的常用命令如下： 1234567891011121314151617181920212223#关闭ens33网卡ifconfig ens33 down#开启ens33网卡ifconfig ens33 up#配置ip地址ifconfig ens33:1 192.168.100.100#配置ip地址和子网掩码ifconfig ens33:1 192.168.100.100 netmask 255.255.255.0#配置ip地址、子网掩码和广播地址ifconfig ens33:1 192.168.100.100 netmask 255.255.255.0 broadcast 192.168.1.255#删除ip地址ifconfig ens33 del 192.168.1.100#启用arp协议ifconfig ens33 arp#禁用arp协议ifconfig ens33 -arp route：显示添加或修改路由表 route命令用于查看或编辑计算机的IP路由表。 route的常用命令如下： 123456#显示所有路由表route -n#添加一条路由：发往192.168.60.0网段的全部要经过网关192.168.19.1route add -net 192.168.18.0 netmask 255.255.255.0 gw 192.168.18.2#删除一条路由：删除时不需要网关route del -net 192.168.18.0 netmask 255.255.255.0 scp：Linux系统之间复制文件和目录 scp可以将本地文件传送到远程主机或从远程主机拉取文件到本地。注意由于各发行版本不同，scp语法也不同。 scp使用方法如下所示： 1234567891011#将本地/root/lk目录下所有文件传输到远程主机192.168.3.100的/home/lk/cpfile目录下：scp -r /root/lk root@192.168.3.100:/home/lk/cpfile#将远程主机192.168.3.100的/home/lk/目录下所有文件全部复制到本地的/root目录下：scp -r root@192.168.3.100:/home/lk /root#使用端口号4588将本地文件test.py传送至远程主机198.168.3.100的/usr目录下：scp -P 4588 test.py root@192.168.3.100:/usr#使用端口号4588将远程主机198.168.3.100的/etc/1.txt文件复制到本地的/root目录下：scp -P 4588 root@192.168.3.100:/etc/1.txt /root rsync：数据镜像备份工具 rsync是Linux系统下常用的数据镜像备份工具，用于在不同的主机之间同步文件。除了单个文件外，rsync还可以保存整个目录树和文件系统，可以增量同步，并保持文件原来的属性，数据传输过程是加密的，保证数据的安全。 rsync不仅可以远程同步数据，还可以本地同步数据。与cp或scp不同的是，使用rsync备份数据时不会直接覆盖已经存在的数据，而是先判断已经存在的数据和新数据的差异，只有数据不同时才会把不相同的部分覆盖。 rsync使用方法如下所示： 12345#将本地/etc/passwd文件同步到本地的/tmp/目录下，并改名为1.txtrsync -av /etc/passwd /tmp/1.txt#将本地/etc/passwd文件备份到远程主机192.168.3.100的/tmp/目录下，并改名为1.txtrsync -av /etc/passwd 192.168.3.100:/tmp/1.txt netstat：显示网络连接、路由表或接口状态 netstat命令用于监控系统网络配置和工作状况，可以显示内核路由表、活动的网络状态以及每个网络接口有用的统计数字。 netstat的常用命令如下： 12345678910111213141516#显示所有端口，包含UDP和TCP端口netstat -a|head -4#显示所有TCP端口netstat -at#显示所有UDP端口netstat -au#显示所有处于监听状态的端口并以数字方式显示而非服务名netstat -ln#显示所有TCP端口并显示对应的进程名称或进程号netstat -plnt#显示核心路由信息netstat -r#显示网络接口列表netstat -i#统计各个TCP连接的各个状态对应的数量netstat -plinta|sed '1,2d'|awk '&#123;print $6&#125;'|sort|uniq -c traceroute：探测至目的地址的路由信息 traceroute跟踪数据包到达网络主机所经过的路由，其原理是试图以最小的TTL发出探测包来跟踪数据包到达目标主机所经过的网关，然后监听一个来自网关ICMP的应答。 traceroute的常用命令如下： 12345#先检查主机与www.baidu.com之间的网络是否通畅ping www.baidu.com#显示本地主机到www.baidu.com所经过的路由信息traceroute -n www.baidu.com#运行结果的每行记录对应一跳，每跳表示一个网关，最大30跳。每行有3个时间，单位是ms。星号则表示ICMP信息没有返回 telnet：测试、登录或控制远程主机 telnet通常用来远程登录。在客户端使用telnet在程序中输入命令，可以在本地控制服务器。由于telnet采用明文传送报文，安全性较差。telnet可以确定远程服务端口的状态，以便确认服务是否正常。 telnet常用命令如下： 1234#检查198.168.3.100对应的56789端口服务是否正常telnet 198.168.3.100 56789#检查www.pjp.net对应的80端口服务是否正常telnet www.php.net 80 wget：下载网络文件 wget可以断点续传，同时支持FTP或HTTP协议下载，并可以设置代理服务器。 wgett常用命令如下： 123456#下载文件http://ftp.gnu.org/gnu/wget/wget-1.14.tar.gzwget http://ftp.gnu.org/gnu/wget/wget-1.14.tar.gz#断点续传wget -c http://ftp.gnu.org/gnu/wget/wget-1.14.tar.gz#批量下载，其中download.txt文件里是一系列网址wget -i download.txt Linux网络配置 与Linux网络配置相关的文件主要有以下这些： 目录 功能及作用 /etc/hostname 主要用于修改主机名称 /etc/sysconfig/network-scrips/ifcfg-enoN 设置网卡参数的文件，如IP地址、子网掩码、广播地址、网关等，N为一串数字 /etc/resolv.conf 设置DNS相关的信息，用于将域名解析到IP /etc/hosts 计算机IP对应的主机名称或域名对应的IP地址 /etc/nsswitch.conf 规定通过哪些途径、按照什么顺序通过这些途径来查找特定类型的信息。通过修改选项可以选择是DNS解析优先还是本地设置优先 配置Linux系统的IP地址 可以通过终端命令直接设置主机的IP地址，如想设置在系统重启后依然生效，可以通过设置对应的网络端口文件。 123456789101112131415161718192021222324252627oot@localhost admin]# cat /etc/sysconfig/network-scripts/ifcfg-ens33TYPE=\"Ethernet\" #设备连接类型，此处为以太网PROXY_METHOD=\"none\" BROWSER_ONLY=\"no\"BOOTPROTO=\"dhcp\" #使用动态IPDEFROUTE=\"yes\" #是否为默认路由IPV4_FAILURE_FATAL=\"no\"IPV6INIT=\"yes\"IPV6_AUTOCONF=\"yes\"IPV6_DEFROUTE=\"yes\"IPV6_FAILURE_FATAL=\"no\"IPV6_ADDR_GEN_MODE=\"stable-privacy\"NAME=\"ens33\"UUID=\"cc581056-9262-44ab-877f-645d0b306352\"DEVICE=\"ens33\"ONBOOT=\"yes\" #系统启动时是否设置此网络接口 #可以使用命令vim /etc/sysconfig/network-scripts/ifcfg-ens33#将BOOTPROTO=\"dhcp\" 修改为BOOTPROTO=none 后，增加以下字段。按i键即可输入，输入完成后按下Esc键，输入冒号：和wq将更改保存后退出IPADDR0=设定的ip地址PREFIX0=设定的子网掩码GATEWAT0=设定的网关DNS1=DNS服务器地址1DNS2=DNS服务器地址2 设置完接口文件后，需要重启网络服务才能生效，重启后使用ifconfig查看设置是否生效： 1service network restart 同一个网络接口可以使用子接口的方式设置多个IP地址： 12#配置网络接口ens33子接口1的ip地址和子网掩码ifconfig ens33:1 192.168.100.100 netmask 255.255.255.0 当服务器重启或网络服务重启后，子接口的配置将消失。若需要重启后仍生效，可以将配置子接口命令加入/etc/rc.local文件中。 使用hostname设置主机名 主机名是识别某个计算机在网络中的标识。在单机情况下，主机名可任意设置。执行以下命令修改主机名，重新登录后可以发现主机名已改变。 1hostname mycomputername 如要修改重启后依然生效，可以将主机名写入文件/etc/hostname中。 设置默认网关 设置好IP地址后，若要访问其他的子网或Internet，用户还需要设置路由，这里采用设置默认网关的方法来设置路由。 在Linux中，设置默认网关有两种方法： 第一种是直接使用route命令。在设置默认网关之前，先用route -n 命令查看路由表，而后执行下面命令设置网关： 1route add default gw 192.168.10.254 若不想每次开机都执行route命令，则应把要执行的命令写入/etc/rc.d/re.local文件中。 第二种是在/ect/sysconfig/network-scripts/ifcfg-接口文件中添加如下字段： 1GATEWAY=192.168.10.254 然后重启网络服务来使设置生效。 1service network restart 设置DNS服务器 设置DNS服务器只需修改/etc/resolv.conf文件即可： 1234567891011[root@localhost admin]# cat /etc/resolv.conf# Generated by NetworkManagersearch localdomainnameserver 192.168.18.2 #第一名字服务器#如需添加DNS服务器，直接在下面添加nameserver即可，注意nameserver指定的DNS服务器只有前三条生效#resolv.conf文件还有其他参数如下：option rotate #在这DNS server之间轮询option timeout:1 #表示解析超时时间1s（默认为5s）attempts:2 #表示解析域名尝试的次数 FTP服务器 FTP服务概述 FTP文件共享基于TCP/IP协议，是一种通用性比较强的网络文件共享方式。FTP是仅基于TCP的服务，不支持UDP。FTP使用两个端口，一个数据端口和一个命令端口（控制端口）。通常这两个端口是21（命令端口）和20（数据端口）。由于FTP工作方式的不同，数据端口并不总是20，分为主动FTP和被动FTP。 主动FTP 主动模式是从服务器向客户端发起连接。主动模式下，服务端开启的是20和21端口，客户端开启的是1024以上的端口 被动FTP 被动模式是客户端向服务端发起连接。被动模式下，服务端开启的是21命令端口和大于1024的数据连接端口，客户端开启的是大于1024的两个端口 两者的共同点是都使用21端口进行用户验证及管理，差别在于传送数据的方式不同。 vsftp的安装与配置 在Linux系统下，vsftp是一款应用比较广泛的FTP软件，其特点是小巧轻快、安全易用。 vsftp安装 使用yum工具安装vsftp： 123456#使用yum工具下载vsftpyum install -y vsftpd#使用rpm安装vsftprpm -qa|grep vsftp#安装依赖的库文件yum install -y libcap libcap-devel 匿名FTP设置 这种运行匿名用户访问并上传文件，配置文件路径一般为/etc/vsftpd.conf，若是使用rpm包安装，则配置文件位于/etc/vsftpd/vsftpd.conf。 1234567891011121314151617181920212223242526272829303132333435#将默认目录赋予用户ftp权限以便可以上传文件[root@localhost admin]# chown -R ftp.users /var/ftp/pub/#取消配置文件中的注释并显示有效行[root@localhost admin]# grep -v ^# /etc/vsftpd/vsftpd.confanonymous_enable=YES #允许匿名用户登录和上传local_enable=YES write_enable=YES #允许写local_umask=022 dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=NO #是否允许在监听listen_ipv6=YES #是否允许IPv6上的监听pam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YES#配置文件使用vim /etc/vsftpd/vsftpd.conf修改为如下：anonymous_enable=YESlocal_enable=YESwrite_enable=YESlocal_umask=022anon_upload_enable=YESdirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=YESlisten_ipv6=NOpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YES 启动FTP服务 123456#启动vsftpd[root@localhost admin]# systemctl start vsftpd#检查是否启动成功，默认配置文件位于/etc/vsftpd/vsftpd.conf[root@localhost admin]# ps -ef|grep vsftproot 60170 1 0 00:55 ? 00:00:00 /usr/sbin/vsftpd /etc/vsftpd/vsftpd.confroot 60223 54792 0 00:56 pts/0 00:00:00 grep --color=auto vsftp 匿名用户登录测试 1234567891011121314151617181920212223242526272829303132333435#登录ftp[root@localhost admin]# ftp 192.168.18.128 21Connected to 192.168.18.128 (192.168.18.128).220 (vsFTPd 3.0.2)#输入匿名用户名Name (192.168.18.128:root): anonymous331 Please specify the password.#密码为空Password:#登录成功230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; #切换目录ftp&gt; cd pub250 Directory successfully changed.#查看当前目录下的文件ftp&gt; !ls -l总用量 3048drwxr-xr-x. 2 admin admin 6 10月 12 05:13 Desktopdrwxr-xr-x. 2 admin admin 19 11月 16 01:18 Documentsdrwxr-xr-x. 2 admin admin 6 10月 12 05:13 Downloadsdrwxr-xr-x. 2 admin admin 6 10月 12 05:13 Musicdrwxr-xr-x. 2 admin admin 6 10月 12 05:13 Picturesdrwxr-xr-x. 2 admin admin 6 10月 12 05:13 Publicdrwxr-xr-x. 2 admin admin 6 10月 12 05:13 Templatesdrwxr-xr-x. 2 admin admin 6 10月 12 05:13 Videos-rw-r--r--. 1 root root 3118130 8月 5 2012 wget-1.14.tar.gz#上传文件测试ftp&gt; put wget-1.14.tar.gzlocal: wget-1.14.tar.gz remote: wget-1.14.tar.gz227 Entering Passive Mode (192,168,18,128,72,253).553 Could not create file. 上述上传文件时，遇到了553 Could not create file错误。解决方式如下： 输入quit退出vsftpd，在ftp的目录创建一个目录，然后设置权限为777： 123[root@localhost admin]# mkdir /var/ftp/write[root@localhost admin]# chmod -R 777 /var/ftp/write[root@localhost admin]# vim /etc/vsftpd/vsftpd.conf 然后修改位于/etc/vsftpd/vsftpd.conf的配置文件，在文件最后加上以下代码： 1local_root=/var/ftp 杀死vsftpd进程，然后重启vsftpd服务器程序： 12345678910#杀死vsftpd进程[root@localhost admin]# pkill vsftpd#查看是否还有vsftpd进程[root@localhost admin]# pgrep vsftpd#启动vsftpd服务器[root@localhost admin]# /usr/sbin/vsftpd &amp;[1] 61422#查看是否有vsftpd进程[root@localhost admin]# pgrep vsftpd61418 然后再试试登录ftp上传文件： 1234567891011121314#上传文件测试ftp&gt; put wget-1.14.tar.gzlocal: wget-1.14.tar.gz remote: wget-1.14.tar.gz227 Entering Passive Mode (192,168,18,128,122,212).150 Ok to send data.226 Transfer complete.3118130 bytes sent in 0.00845 secs (368834.88 Kbytes/sec)#上传文件成功退出ftpftp&gt; quit221 Goodbye.#查看上传后的文件信息，文件属于ftp用户[root@localhost admin]# ll /var/ftp/pub/总用量 3048-rw-------. 1 ftp ftp 3118130 11月 16 01:29 wget-1.14.tar.gz 实名FTP设置 除了配置匿名FTP服务外，vsftp还可以配置实名FTP服务器，以便实现更精确的权限控制。 实名需要的用户认证信息位于/etc/vsftpd/目录下，用户启动时可以单独指定其他的配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#配置文件使用vim /etc/vsftpd/vsftpd.conf修改为如下：[root@localhost admin]# grep -v ^# /etc/vsftpd/vsftpd.confanonymous_enable=NO #禁止匿名用户登录local_enable=YES #允许本地用户访问，默认为YESwrite_enable=YES #允许写入local_umask=022 #上传后的文件默认的权限掩码anon_upload_enable=NO #匿名用户上传权限 anon_mkdir_write_enable=NO #匿名用户创建目录的同时上传文件anon_other_write_enable=NO #匿名用户删除权限chroot_local_user=YES #禁止本地用户离开自己的ftp主目录chroot_list_enable=NO #禁止ftp用户离开自己的ftp主目录chroot_list_file=/etc/vsftpd.chroot_list #虚拟用户列表，每行一个用户名listen=YESlisten_address=192.168.18.128 #绑定本机ippam_service_name=vsftpd.vu #验证方式local_root=/var/ftp #guest_enable=YES #开启虚拟用户功能guest_username=ftp #虚拟用户的宿主目录virtual_use_local_privs=YES #用户登录后操作主目录和本地用户具有同样的权限user_config_dir=/etc/vsftpd/vconf #虚拟用户主目录设置文件#新建/etc/vsftpd.chroot_list文件[root@localhost admin]# touch /etc/vsftpd.chroot_list#编辑/etc/vsftpd.chroot_list如下，每行一个用户名[root@localhost admin]# vim /etc/vsftpd.chroot_list[root@localhost admin]# cat /etc/vsftpd.chroot_listuser1user2#增加用户并指定主目录[root@localhost admin]# mkdir /data[root@localhost admin]# mkdir /data/user1[root@localhost admin]# mkdir /data/user2[root@localhost admin]# chmod -R 775 /data/user1 /data/user2#设置用户名密码数据库[root@localhost admin]# echo -e \"user1\\npass1\\nuser2\\npass2\"&gt;/etc/vsftpd/vusers.list[root@localhost admin]# cd /etc/vsftpd[root@localhost vsftpd]# db_load -T -t hash -f vusers.list vusers.db[root@localhost vsftpd]# chmod 600 vusers.*#指定认证方式[root@localhost vsftpd]# echo -e \"#%PAM-1.0\\n\\nauth required pam_userdb.so db=/etc/vsftpd/vusers\\naccount required pam_userdb.so db=/etc/vsftpd/vusers\"&gt;/etc/pam.d/vsftpd.vu[root@localhost vsftpd]# mkdir -p /etc/vsftpd/vconf[root@localhost vsftpd]# cd /etc/vsftpd/vconf[root@localhost vconf]# ls[root@localhost vconf]# touch user1[root@localhost vconf]# touch user2[root@localhost vconf]# lsuser1 user2#编辑用户的用户名文件，指定主目录[root@localhost vconf]# vim user1[root@localhost vconf]# cat user1local_root=/data/user1[root@localhost vconf]# vim user2[root@localhost vconf]# cat user2local_root=/data/user2#创建标识文件[root@localhost vconf]# touch /data/user1/user1[root@localhost vconf]# touch /data/user2/user2#若连接ftp显示连接被拒绝，重启vsftpd服务后即可解决[root@localhost vconf]# ftp 192.168.18.128 21Connected to 192.168.18.128 (192.168.18.128).220 (vsFTPd 3.0.2)#输入用户名user1Name (192.168.18.128:root): user1331 Please specify the password.#密码为之前设置的pass1Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.#查看文件ftp&gt; ls227 Entering Passive Mode (192,168,18,128,47,84).150 Here comes the directory listing.-rw-r--r-- 1 0 0 0 Nov 17 01:53 user1226 Directory send OK.#退出vsftpdftp&gt; quit221 Goodbye.#测试用户user2[root@localhost vconf]# ftp 192.168.18.128 21Connected to 192.168.18.128 (192.168.18.128).220 (vsFTPd 3.0.2)Name (192.168.18.128:root): user2331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; ls227 Entering Passive Mode (192,168,18,128,75,91).150 Here comes the directory listing.-rw-r--r-- 1 0 0 0 Nov 17 01:53 user2226 Directory send OK.#退出vsftpdftp&gt; quit221 Goodbye.","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Linux","slug":"Linux","permalink":"http://tangmenjue.top/categories/Linux/"},{"name":"操作系统","slug":"操作系统","permalink":"http://tangmenjue.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"CentOS 7","slug":"CentOS-7","permalink":"http://tangmenjue.top/tags/CentOS-7/"},{"name":"Linux","slug":"Linux","permalink":"http://tangmenjue.top/tags/Linux/"},{"name":"网络管理","slug":"网络管理","permalink":"http://tangmenjue.top/tags/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"}]},{"title":"Vue.js实战之博客页面前端","slug":"Vue.js实战之博客页面前端","date":"2022-11-14T09:33:51.000Z","updated":"2022-11-16T02:12:29.000Z","comments":true,"path":"2022/11/14/Vue.js实战之博客页面前端/","link":"","permalink":"http://tangmenjue.top/2022/11/14/Vue.js%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2%E5%89%8D%E7%AB%AF/","excerpt":"","text":"基于Vue-cli的前端项目初始化 初始化 Vue-cli环境配置详情见前端框架之Vue.js（一）安装小节里的“使用npm安装”内容。 初始化一个新项目，创建文件夹tutorproject作为项目目录，打开一个终端将切换路径到tutorproject，运行代码以创建front-end文件夹： 12345678910PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject&gt; vue create front-end运行结果如下：Vue CLI v5.0.8? Please pick a preset: (Use arrow keys)&gt; first ([Vue 3] babel, eslint) ssecond ([Vue 3] babel, eslint) Default ([Vue 3] babel, eslint) Default ([Vue 2] babel, eslint) Manually select features 使用方向键选中Default ([Vue 2] babel, eslint)选项后按下键盘上的回车键，然后脚手架工具就开始构建项目，并且安装所需的依赖。 将切换路径到front-end，运行代码以启动Vue应用程序： 12PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject&gt; cd front-endPS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\front-end&gt; npm run serve 打开浏览器输入网址http://localhost:8080/，即可看到应用程序： 组件Ping.vue 将\\tutorproject\\front-end\\src\\components目录下的HelloWorld.vue文件删除，并在当前目录下新建文件Ping.vue： 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Ping', data()&#123; return &#123; msg:'Hello,This is Ping.vue component' &#125; &#125;&#125;&lt;/script&gt; 在tutorproject\\front-end\\src目录下新建路由文件夹router，并在router文件夹中新建文件index.js： 123456789101112131415import Vue from 'vue'import Router from 'vue-router'import Ping from '@/components/Ping'Vue.use(Router)export default new Router(&#123; routes:[ &#123; path:'/', name:'Ping', component:Ping &#125; ]&#125;) 修改front-end\\src\\App.vue中&lt;script&gt;...&lt;/script&gt;部分的import代码如下： 12&lt;script&gt;import HelloWorld from './components/Ping.vue' 修改front-end\\vue.config.js文件的代码以关闭语法检查： 12345const &#123; defineConfig &#125; = require('@vue/cli-service')module.exports = defineConfig(&#123; transpileDependencies: true, lintOnSave:false //关闭语法检查&#125;) 此时的代码结构如下： 再次在浏览器中访问http://localhost:8080/，可以看到页面发生了变化： 使用axios与API交互 在cmd中按下ctrl+c停止应用程序，使用以下命令安装axios: 1PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\front-end&gt; cnpm install axios --save 依赖关系自动写进了front-end\\package.json中，在package.json文件的dependencies里可以看到刚安装的axios。 输入npm run serve重新启动Vue。 修改\\front-end\\src\\components\\Ping.vue中&lt;script&gt;...&lt;/script&gt;部分的代码如下： 123456789101112131415161718192021222324252627&lt;script&gt;import axios from 'axios'export default &#123; name: 'Ping', data()&#123; return &#123; msg:'' &#125; &#125;, methods:&#123; getMessage()&#123; const path='http://localhost:5000/api/ping' axios.get(path) .then((res)=&gt;&#123; this.msg=res.data; &#125;) .catch((error)=&gt;&#123; console.error(error); &#125;) &#125; &#125;, created()&#123; this.getMessage() &#125;&#125;&lt;/script&gt; 另外打开一个终端将切换路径到tutorproject\\back-end（博客后端的项目文件），运行代码以运行flask服务端： 12PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; venv\\Scripts\\activate(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; flask run 此时在浏览器中访问http://localhost:8080/，可以看到页面再次发生了变化： 若没有获取到后端API端口的数据pong!，解决方案如下： 停止flask的运行，使用pip安装Flask-Cors包 12(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; pip install flask-Cors(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; pip freeze &gt; requirements.txt 然后修改tutorproject\\back-end\\tutorweb\\__init__.py： 1234567891011121314151617181920212223242526272829from flask import Flaskfrom flask_cors import CORSfrom flask_sqlalchemy import SQLAlchemyfrom flask_migrate import Migratefrom config import Config#定义Flack_SQLAlchemydb=SQLAlchemy()#定义Flack_Migrate migrate=Migrate()def create_app(config_class=Config): app=Flask(__name__) app.config.from_object(config_class) #启用CORS CORS(app) #初始化Flack_SQLAlchemy db.init_app(app) #初始化Flack_Migrate migrate.init_app(app,db) #注册blueprint from tutorweb.api import bp as api_bp app.register_blueprint(api_bp,url_prefix='/api') return app from tutorweb import models 然后再启动flask，访问http://localhost:8080/页面即可。 引入element-UI 使用cnpm命令安装： 1PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\front-end&gt; cnpm install element-ui -S 修改\\front-end\\src\\main.js，引入element-UI样式： 1234567891011121314import &#123; createApp &#125; from 'vue'import Vue from 'vue';import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';import App from './App.vue';Vue.use(ElementUI);new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;);createApp(App).mount('#app') 修改\\front-end\\src\\components\\Ping.vue中&lt;template&gt;...&lt;/template&gt;部分的代码，创建element-UI风格的按钮： 12345&lt;template&gt; &lt;div&gt; &lt;el-button type=\"primary\" round&gt;&#123;&#123;msg&#125;&#125;&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt; 在浏览器中访问http://localhost:8080/，可以看到element-UI风格的按钮pong!： 至此，博客前端的欢迎页面完成，页面的具体样式可以根据自己的喜好自行更改。 博客后续的登录注册等页面，由于代码过多且繁杂，暂且不表，该部分的后续看心情更新。（除非...评论区呼声高，嗯！）","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"前端框架","slug":"前端框架","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://tangmenjue.top/tags/Vue-js/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端框架之Vue.js（六）","slug":"前端框架之Vue.js（六）","date":"2022-11-11T09:20:06.000Z","updated":"2022-12-06T12:41:09.097Z","comments":true,"path":"2022/11/11/前端框架之Vue.js（六）/","link":"","permalink":"http://tangmenjue.top/2022/11/11/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8BVue.js%EF%BC%88%E5%85%AD%EF%BC%89/","excerpt":"","text":"可复用性&amp;组合 混入 基础 混入用于分发Vue组件中是可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。 1234567891011121314151617//定义一个混入对象var myMixin=&#123; created:function()&#123; this.hello() &#125;, methods:&#123; hello:function()&#123; console.log('hello from mixin!') &#125; &#125;&#125;//定义一个使用混入对象的组件var Component=Vue.extend(&#123; mixins:[myMixin]&#125;)var component=new Component()&lt;/script&gt; 选项合并 当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行合并。如数据对象在内部会进行递归合并，并在发生冲突时会以组件数据为优先： 12345678910111213141516171819202122var myMixin=&#123; data:function()&#123; return&#123; message:'hello', foo:'abc' &#125; &#125;&#125;new Vue(&#123; mixins:[myMixin], data:function()&#123; return&#123; message:'goodbye', bar:'def' &#125; &#125;, created:function()&#123; console.log(this.$data) &#125;&#125;)/*合并结果为:&#123; message: \"goodbye\", foo: \"abc\", bar: \"def\" &#125;*/ 同名钩子函数将合并为一个数组，因此都将被调用。混入对象的钩子将在组件自身钩子之前被调用。 1234567891011121314151617var myMixin=&#123; created:function()&#123; console.log('混入对象的钩子被调用') &#125;&#125;new Vue(&#123; mixins:[myMixin], created:function()&#123; console.log('组件钩子被调用') &#125;, created:function()&#123; console.log(this.$data) &#125;&#125;)/*合并结果为：混入对象的钩子被调用组件钩子被调用*/ 值为对象的选项如methods、components和directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对： 12345678910111213141516171819202122232425262728var mixin=&#123; methods:&#123; foo:function()&#123; console.log('foo') &#125;, conflicting:function()&#123; console.log('from mixin') &#125; &#125;&#125;var vm=new Vue(&#123; mixins:[mixin], methods:&#123; bar:function()&#123; console.log('bar') &#125;, conflicting:function()&#123; console.log('from self') &#125; &#125;&#125;)vm.foo()vm.bar()vm.conflicting()/*运行结果如下：foobarfrom self*/ 注意：Vue.extend()也使用同样的策略进行合并 全局混入 混入也可以进行全局注册。一旦使用全局混入，它将影响每一个之后创建的Vue实例。恰当使用时，可以用来为自定义选项注入处理逻辑。 1234567891011121314//为自定义的选项myOption注入一个处理器Vue.mixin(&#123; created:function()&#123; var myOption=this.$options.myOption if(myOption)&#123; console.log(myOption) &#125; &#125;&#125;)new Vue(&#123; myOption:'hello!'&#125;)/*运行结果如下：hello!*/ 自定义选项合并策略 自定义选项合并将使用默认策略，即简单地覆盖已有值。若想让自定义选项以自定义逻辑合并，可以向Vue.config.optionMergeStrategies添加一个函数： 123Vue.config.optionMergeStrategies.myOption=function(toVal,fromVal)&#123; //返回合并后的值&#125; 对于多数值为对象的选项，可以使用与methods相同的合并策略： 12var strategies=Vue.config.optionMergeStrategiesstrategies.myOption=strategies.methods 过滤器 Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道符号”表示： 12345&lt;!-- 在双花括号中 --&gt;&#123;&#123;message | capitalize&#125;&#125;&lt;!-- 在v-bind中 --&gt;&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt; 可以在一个组件的选项中定义本地的过滤器： 1234567filters:&#123; capitalize:function(value)&#123; if(!value) return '' value=value.toString() return value.charAt(0).toUpperCase()+value.slice(1) &#125;&#125; 也可以在创建Vue实例之前全局定义过滤器： 12345678Vue.filters('capitalize',function(value)&#123; if(!value) return '' value=value.toString() return value.charAt(0).toUpperCase()+value.slice(1)&#125;)new Vue(&#123; //...&#125;) 当全局过滤器和局部过滤器重名时，会采用局部过滤器。 过滤器函数总接收表达式的值作为第一个参数。如上述代码中，capitalize过滤器函数将会收到message的值作为第一个参数。 过滤器可以串联： 123&#123;&#123;message&#125;&#125; | filterA | filterB&#125;&#125;&lt;!-- filterA为接收单个参数的过滤器参数，message值将作为参数传入到filterA中然后调用fliterB，将filterA的结果传递到fliterB中 --&gt; 过滤器是JavaScript函数，因此可以接收参数： 123&#123;&#123;message&#125;&#125; | filterA('arg1',arg2)&#125;&#125;&lt;!-- filterA为接收三个参数的过滤器参数message值将作为第一个参数，普通字符串arg1作为第二个参数，表达式arg2的值作为第三个参数 --&gt; 从零开始简单的路由 若只需要非常简单的路由而不想引入一个功能完整的路由库，可以想这样动态渲染一个页面级的组件，结合HTML5 History API，便可以搭建一个客户端路由： 1234567891011121314151617181920const NotFound=&#123;template:'&lt;p&gt;Page not found&lt;/p&gt;'&#125;const Home=&#123;template:'&lt;p&gt;Home Page&lt;/p&gt;'&#125;const About=&#123;template:'&lt;p&gt;About Page&lt;/p&gt;'&#125;const routes=&#123; '/':Home, '/about':About&#125;new Vue(&#123; el:'#app', data:&#123; currentRoute:window.location.pathname &#125;, computed:&#123; ViewComponent()&#123; return routes[this.crruentRoute]||NotFound &#125; &#125;, render(h)&#123;return h(this.ViewComponent)&#125;&#125;) vue-router路由基础 对于大多数单页面应用，推荐使用官方支持的vue-router库。 下载安装 使用npm下载vue-router库： 1npm install vue-router@4 rounter-link 在vue-router里，不是使用常规的&lt;a&gt;标签，而是使用一个自定义组件rounter-link来创建链接。这样Vue Router可以在不重新加载页面的情况下更改URL，处理URL的生成及编码。 rounter-view rounter-view将显示与URL对应的组件，可以将其放在任何地方。 使用Vue Router创建单页应用例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue@3\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/vue-router@4\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;h1&gt;Hello App！&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用router-link组件进行导航 --&gt; &lt;!-- 通过传递to来指定连接 --&gt; &lt;!-- &lt;rounter-link&gt;将呈现以一个带有正确href属性的&lt;a&gt;标签 --&gt; &lt;router-link to=\"/\"&gt;Go to Home&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;Go to About&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;//定义路由组件,也可以从其他文件中导入const Home=&#123;template:'&lt;div&gt;Home&lt;/div&gt;'&#125;const About=&#123;template:'&lt;div&gt;About&lt;/div&gt;'&#125;//定义一些路由.每个路由都需要映射到一个组件中const routes=[ &#123;path:'/',component:Home&#125;, &#123;path:'/about',component:About&#125;,]// 创建路由实例并传递routes配置const router=VueRouter.createRouter(&#123; // 内部提供了history模式的实现,为了简便,这里使用hash模式 history:VueRouter.createWebHashHistory(), routes,//这句为routes:routes的缩写&#125;)// 创建并挂载根示例const app=Vue.createApp(&#123;&#125;)// 确保user路由实例使整个应用支持路由// 在任意组件中能以this.$router的形式访问它,且能以this.$route的形式访问当前路由app.use(router)// 启动应用app.mount('#app')&lt;/script&gt;&lt;/html&gt; 通过调用app.use(router)，可以在任意组件中以this.$router的形式访问它,且能以this.$route的形式访问当前路由： 1234567891011121314151617//Home.vue文件中export default&#123; computed:&#123; username()&#123; return this.$route.params.username &#125;, &#125;, methods:&#123; goToDashboard()&#123; if(isAuthenticated)&#123; this.$router.push('/dashboard') &#125;else&#123; this.$router.push('/login') &#125; &#125;, &#125;,&#125; 要在setup函数中访问路由，则可以调用useRouter或useRoute函数。 动态路由匹配 带参数的动态路由匹配 很多时候需要将给定匹配模式的路由映射到同一个组件中。例如有一个User组件，它应该对所有用户进行渲染，但用户ID不同。在Vue Router中，可以在路径中使用一个动态字段来实现，该字段称之为路径参数： 12345678const User=&#123; template:'&lt;div&gt;User&lt;/div&gt;',&#125;//这些都会传递给createRouterconst routes=[ //动态字段以冒号开始 &#123;path:'/users/:id',component:User&#125;,] 这样不同用户的URL都会映射到同一个路由上。 路径参数用冒号:表示。当一个路由被匹配时，它的params的值将在每个组件中以this.$route.params的形式暴露出来。因此可以通过更新User的模板来呈现当前的用户ID： 123const User=&#123; template:'&lt;div&gt;User&#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;',&#125; 可以在同一个路由中设置有多个路径参数，它们会映射到$route.params上的相应字段上。 匹配模式 匹配路径 $route.params /users/:username /users/eduardo { username: 'eduardo' } /users/:username/posts/:postId /users/eduardo/posts/123 { username: 'eduardo', postId: '123' } 除了$route.params之外，route对象还公开了其他有用的信息，如route.query（若URL中存在参数）、$route.hash等。 相应路由参数的变化 使用带有参数的路由时需要注意的时，当用户从/users/johnny导航到/users/jolyne时，相同的组件实例将会被重复使用，这也意味着组件的生命周期钩子不会被调用。 要对同一个组件中参数的变化做出相应，可以用watch $route对象上的任意属性，如下列代码中是$route.params: 1234567891011const User=&#123; template:'...', created()&#123; this.$watch( ()=&gt;this.$route.params, (toParams,previousParams)=&gt;&#123; //对路由变化做出响应 &#125; ) &#125;,&#125; 或使用beforeRouteUpdate导航守卫，也可以取消导航： 1234567const User=&#123; template:'...', async beforeRouteUpdate(to,from)&#123; //对路由变化做出响应 this.userData=await fetchUser(to,params.id) &#125;,&#125; 捕获所有路由或404 Not found路由 常规参数只匹配url片段之间的字符，用/分隔。若想匹配任意路径，可使用自定义的路径参数正则表达式，在路径参数后面的括号中加入正则表达式： 123456789101112131415const routes=[ //将匹配所有内容并将其放在$route.params.pathMatch下 //pathMatch标记为可选可重复,可以在需要时将path拆分成数组,直接导航到路由 &#123;path:'/:pathMatch(.*)*',name:'NotFound',component:NotFound&#125;, //将匹配以/user-开头的所有内容并将其放在$route.params.afterUser下 &#123;path:'/user-:afterUser(.*)',component:UserGeneric&#125;,]this.$router.push(&#123; name:'NotFound', //保留当前路径并删除第一个字符,以避免目标URL以//开头 params:&#123;pathMatch:this.$route.path.substring(1).split('/')&#125;, //保留现有的查询和hash值 query:this.$route.query, hash:this.$route.hash,&#125;) 高级匹配模式 Vue Router使用自己的路径匹配语法，它支持许多高级匹配模式，如可选的参数，零或多个/一个或多个，甚至是自定义的正则匹配规则。 路由的匹配语法 在参数中自定义正则 当定义像:userId这样的参数时，在内部使用以下正则([^/]+)（至少有一个字符不是斜杠/）来从URL中提取参数。这个方法很好用，除非是需要根据参数的内容来区分两个路由，此时最简单的方法是在路径中添加一个静态部分来区分它们： 123456const routes=[ //匹配/0/3549 &#123;path:'/o/:orderId'&#125;, //匹配/p/books &#123;path:'/p/:productName'&#125;,] 但在一些情况下，并不想添加静态的/o、/p部分。由于orderId总是一个数字，而productName可以是任何东西，因此可以在括号中为参数指定一个自定义的正则： 1234567const routes=[ // /:orderId只匹配数字 //'\\\\dd'是为了确保反斜杠能被转义出来 &#123;path:'/:orderId(\\\\d+)'&#125;, // /:productName匹配其他任何内容 &#123;path:'/:productName'&#125;,] 可重复的参数 若需要匹配具有多个部分的路由，如/first/second/third，则应该使用*（0个或多个）和+（1个或多个）将参数标记为可重复： 123456const routes=[ //匹配1个以上的参数,如/one,/one/two,/one/two/three等 &#123;path:'/:chapters+'&#125;, //匹配0个以上的参数,如/,/one,/one/two,/one/two/three等 &#123;path:'/:chapters*'&#125;,] 这将是提供一个参数数组而不是一个字符串，并且在使用命名路由时也需要传递一个数组： 12345//给定&#123;path:'/:chapters*',name:'chapters'&#125;,router.resolve(&#123;name:'chapters',params:&#123;chapters:[]&#125;&#125;).href//产生路由/router.resolve(&#123;name:'chapters',params:&#123;chapters:['a','b']&#125;&#125;).href//产生路由/a/b//给定&#123;path:'/:chapters+',name:'chapters'&#125;,router.resolve(&#123;name:'chapters',params:&#123;chapters:[]&#125;&#125;).href//chapters为空,抛出错误 这些也可以通过右括号后添加它们与自定义正则结合使用： 123456const routes=[ //只匹配1个以上的数字,如/1,/1/2,/1/2/3等 &#123;path:'/:chapters(\\\\d+)+'&#125;, //匹配0个以上的数字,如/,/1,/1/2,/1/2/3等 &#123;path:'/:chapters(\\\\d+)*'&#125;,] Sensitive与strict路由配置 默认情况下，所有路由是不区分大小写的，且能匹配带有或不带有尾部斜线的路由。这种行为可以通过sensitive和strict选项来修改，它们既可以应用在整个全局路由上，又可以应用在当前路由上： 123456789101112131415const router=createRouter(&#123; history:createWebHistory(), routes:[ //匹配/users/zhangsan /* 当strict:true时,不匹配/users/zhangsan/ 当sensitive:true时,不匹配/Users/zhangsan */ &#123;path:'/users/:id',sensitive:true&#125;, //匹配/users,/Users,以及/users/42,不匹配/users/或users/42/ &#123;path:'/users/:id?'&#125;, ] strict:true,//应用于所有路由 sensitive:true&#125;) 可选参数 也可以通过使用?修饰符（0个或1个）将一个参数标记为可选： 123456const routers=[ //匹配/users和/users/zhangsan &#123;path:'/users/:userId?'&#125;, //匹配/users和/users/42 &#123;path:'/users/:userID(\\\\d)?'&#125;] 命名路由 除了path外，还可以为任何路由提供name。命名路由有以下优点： 没有硬编码的URL params的自动编码/解码 防止在URL中出现打字错误 绕过路径排序（如显示1个） 1234567const route=[ &#123; path:'/user/:username', name:'user', component:User, &#125;,] 链接一个命名路由，可以向router-link组件的to属性传递一个对象： 123456&lt;router-link :to=\"&#123;name:'user',params:&#123;username:'lisi'&#125;&#125;\"&gt;User&lt;/router-link&gt;&lt;!-- 等价于 --&gt;&lt;script&gt; router.push(&#123;name:'user',params:&#123;username:'lisi'&#125;&#125;)&lt;/script&gt;&lt;!-- 两种方法路由都将导航到路径/user/lisi中 --&gt; 嵌套路由 通过Vue Router可以使用嵌套路由配置来对于应用程序的多层嵌套组件结构： 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt;&lt;div id=\"app\"&gt; &lt;!-- 这是一个顶层的router-view,其渲染顶层路由匹配的组件 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;const User=&#123; //被渲染的组件中包含自己嵌套的router-view template:` &lt;div class=\"User\"&gt; &lt;h2&gt;User&#123;&#123;$route.params.id&#125;&#125;&lt;/h2&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `,&#125;//这些传递给createRouterconst routes=[ &#123; //当/user/:id/profile匹配成功时,UserProfile将被渲染到User的router-view内部 path:'/user/:id', component:User, //将组件渲染到嵌套的router-view中 children:[ &#123; path:'profile', component:UserProfile, &#125;, &#123; //当/user/:id/posts匹配成功时,UserPosts将被渲染到User的router-view内部 path:'posts', component:UserPosts, &#125;, ], &#125;,]&lt;/script&gt;&lt;/html&gt; 注意：以/开头的嵌套路径将被视为根路径，这便允许利用组件嵌套而不必使用嵌套URL。 上述代码中children的配置只是另一个路由数组。因此可以根据需要，不断地嵌套视图。 由于没有匹配到嵌套路由，当访问/user/eduardo时，在User的router-view里什么都不会呈现。若想在那里渲染一些东西，可以提供一个空的嵌套路径： 12345678910111213const routes=[ &#123; path:'/user/:id', component:User, children:[ &#123; //当/user/:id匹配成功时,UserHome将被渲染到User的router-view内部 path:'', component:UserHome &#125;, //其他子路由 ], &#125;,] 嵌套命名路由 在处理命名路由时，通常会给子路由命名如下： 12345678910111213const routes=[ &#123; path:'/user/:id', component:User, children:[ &#123; //只有子路由具有名称 path:'', name:'user', component:UserHome &#125;, ], &#125;,] 这将确保导航到/user/:id时始终显示嵌套路由。 若希望导航到命名路由而不导航到嵌套路由，还可以命名父路由，但要注意重新加载页面将始终显示嵌套的子路由，这是以为它被指向路径/users/:id的导航，而不是命名路由： 1234567891011121314const routes=[ &#123; path:'/user/:id', name:'user-parent', component:User, children:[ &#123; path:'', name:'user', component:UserHome &#125;, ], &#125;,] 命名视图 命名视图可以同时展示多个视图而不是嵌套展示。一个界面中可以拥有多个单独命名的视图，而不是只有一个单独的出口。若router-view没有设置名字，则默认为default。 123&lt;router-view class=\"view left-sidebar\" name=\"LeftSidevar\"&gt;&lt;/router-view&gt;&lt;router-view class=\"view main-content\"&gt;&lt;/router-view&gt;&lt;router-view class=\"view right-sidebar\" name=\"RightSidebar\"&gt;&lt;/router-view&gt; 一个视图使用一个组件渲染。因此在同一个路由下，多个视图就需要多个组件： 123456789101112131415const router=createRouter(&#123; history:createWebHashHistory(), routes:[ &#123; path:'/', components:&#123; default:Home, //LeftSidebar:LeftSidebar的缩写 LeftSidebar, //与&lt;router-view&gt;上的name属性相匹配 RightSidebar, &#125;, &#125;, ],&#125;) 嵌套命名视图 当要实现切换路由的同时，其页面下的视图也要从一个UserEmailsSubscriptions切换成两个UserProfile和UserProfilePreview，便应使用命名视图来创建嵌套视图的布局： 123456789/settings/emails /settings/profile+-----------------------------------+ +------------------------------+| UserSettings | | UserSettings || +-----+-------------------------+ | | +-----+--------------------+ || | Nav | UserEmailsSubscriptions | | +------------&gt; | | Nav | UserProfile | || | +-------------------------+ | | | +--------------------+ || | | | | | | | UserProfilePreview | || +-----+-------------------------+ | | +-----+--------------------+ |+-----------------------------------+ +------------------------------+ Nav 是一个常规组件 UserSettings 是一个视图组件 UserEmailsSubscriptions、UserProfile、UserProfilePreview 是嵌套的视图组件 UserSetting组件的&lt;template&gt;部分大致如下： 123456&lt;div&gt; &lt;h1&gt;User Settings&lt;/h1&gt; &lt;NavVar /&gt; &lt;router-view /&gt; &lt;router-view name=\"helper\"/&gt;&lt;/div&gt; 通过这个路由配置来实现上述布局： 12345678910111213141516171819const router=createRouter(&#123; routes:[ &#123; path:'/settings', component:UserSettings, children:[&#123; path:'emails', component:UserEmailsSubscriptions &#125;, &#123; path:'profile', components:&#123; default:UserProfile, helper:UserProfilePreview &#125; &#125;] &#125;, ],&#125;) 编程式导航 使用router.push导航到不同的位置 若想要导航到不同的URL，可以使用router.push方法向history栈添加一个新的记录，当用户点击浏览器后退按钮时，会回到之前的URL。 当点击&lt;router-link&gt;时，内部会调用router.push这个方法。因此点击&lt;router-link :to=\"...\"&gt;便相当于调用router.push(...)： 声明式 编程式 &lt;router-link :to=\"...\"&gt; router.push(...) 注意：在Vue实例中，可以通过$router访问路由实例，因此也可以在实例中调用this.$router.push。 router.push方法的参数可以时一个字符串路径，或者一个描述地址的对象： 1234567891011121314151617181920// 字符串路径router.push('/users/zhangsan')// 带有路径的对象router.push(&#123;path:'/users/zhangsan'&#125;)// 命名的路由，并加上参数，让路由建立url// 注意params不能与path一起使用，若提供了path,params会被忽略，而query不会router.push(&#123;name:'user',params:&#123;username:'zhangsan'&#125;&#125;)// 带查询参数，其结果是/register?plan=privaterouter.push(&#123;path:'/register',query:&#123;plan:'private'&#125;&#125;)// 带hash，其结果是/about#teamrouter.push(&#123;path:'/about',hash:'#team'&#125;)const username='zhangsan'// 可以手动建立url，但必须自己处理编码router.push(`/user/$&#123;username&#125;`)//其结果为/user/zhangsanrouter.push(&#123;path:`/user/$&#123;username&#125;`&#125;)//其结果为/user/zhangsan// 使用name和params从自动url编码中获益router.push(&#123;name:'user',params:&#123;username&#125;&#125;)//其结果为/user/zhangsan//params不能与path一起使用router.push(&#123;path:'/user',params:&#123;username&#125;&#125;)//其结果为/user 当指定params时，可提供string或number参数（或对于可重复从参数可以提供一个数组）。任何其他类型（如undefined、false等）都将被自动字符串化。对于可选参数，可以提供一个空字符串(\"\")来跳过它。 由于属性to与router.push接收的对象种类相同，一次你两者的规则相同。 router.push和所有其他导航方法都会返回一个Promise，等到导航完成后才知道是成功还是失败。 使用router.replace替换当前位置 router.replace与router.push不同的是，router.replace在导航时不会向history添加新记录，它直接取代了当前的条目。 声明式 编程式 &lt;router-link :to=\"...\" replace&gt; router.replace(...) 可以直接使用router.replace，也可以在传递给router.push的routeLocation中增加一个属性replace:true。 123router.replace(&#123;path:'/home'&#125;)//等价于router.push(&#123;path:'/home',replace:true&#125;) 使用router.go横跨历史 router.go采用一个整数作为参数，表示在历史堆栈中前进或后退多少步： 12345678910// 向前移动1条记录，与router.forward()作用相同router.go(1)// 向后移动1条记录，与router.back()作用相同router.go(-1)// 前进3条记录router.go(3)// 若没有那么多记录，静默失败，即不执行也不报错router.go(-100)router.gi(100) 重定向和别名 通过redirect属性实现重定向 通过routes实现重定向： 1234567891011121314151617181920// 将/home重定向到/const routes=[&#123;path:'home',redirect:'/'&#125;]// 重定向的目标也可以是一个命名的路由const routes=[&#123;path:'/home',redirect:&#123;name:'homepage'&#125;&#125;]// 重定向的目标还可以是一个方法，动态返回重定向目标const routes=[ &#123; // 将/search/screens重定向到/search?q=screens path:'search/:searchText', redirect: to=&gt;&#123; //方法接收目标路由作为参数 //return 重定向的字符串路径/路径对象 return &#123;path:'/search',query:&#123;q:to.parpams.searchText&#125;&#125; &#125;, &#125;, &#123; path:'/search', &#125;,] 在写redirect时，可以省略component配置。由于组件从来没有被直接渲染过，因此没有组件要渲染，嵌套路由除外。若一个路由有children和redirect属性，那么它也应该有component属性。 导航守卫没有应用在跳转路由上，仅应用在其目标上。在上述代码中，在/home路由中添加beforeEnter守卫也不会有任何效果。 相对重定向 即重定向到相对位置： 123456789101112const routes=[ &#123; // 将/users/123/posts重定向到/users/123/profile path:'users/:id/posts', redirect: to=&gt;&#123; //方法接收目标路由作为参数 //相对位置不以/开头 return 'profile' //或是return &#123;path:'profile'&#125; &#125;, &#125;,] 使用alias设置别名 将/别名为/home，便意味着当用户访问/home时，URL仍然是/home，但会被匹配为用户正在访问/： 1const routes=[&#123;path:'/',component:Homepage,alias:'/home'&#125;] 通过别名可以自由地将UI结构映射到一个任意的URL，而不受配置的嵌套结构的限制。 别名以/开头，以使嵌套路径中的路径成为绝对路径，也可以用一个数组来提供多个别名： 12345678910const routes=[ &#123; path:'/users', component:UsersLayout, children:[ //为/users、/users/list、/people这3个URL呈现UserList &#123;path:'',component:UserList,alias:['/people','list']&#125;, ], &#125;,] 若路由有参数，则要确保在任何绝对别名中包含它们： 12345678910const routes=[ &#123; path:'/users:id', component:UsersByIdLayout, children:[ //为/users/123、/users/123/profile、/123这3个URL呈现UserDetails &#123;path:'profile',component:UserDetails,alias:['/:id','']&#125;, ], &#125;,] 关于SEO的注意事项：使用别名是，一定要定义规范链接 路由组件传参 将props传递给路由组件 在组件中使用$route会与路由紧密耦合，由于它只能用于特定的URL，这将限制了组件的灵活性。通过配置props来解除这种行为： 123456789101112const User=&#123; template:'&lt;div&gt;User&#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;'&#125;const routes=[&#123;path:'/user/:id',component:User&#125;]//可以通过配置props将代码替换成如下所示const User=&#123; //添加一个与路由参数完全相同的prop名 props:['id'], template:'&lt;div&gt;User&#123;&#123;id&#125;&#125;&lt;/div&gt;'&#125;const routes=[&#123;path:'/user/:id',component:User,props:true&#125;] 这允许在任何地方使用该组件，使得该组件更容易重用和测试。 布尔模式 当props设置为true时，route.params将被设置为组件的props。 命名视图 对于有命名视图的路由，则必须为每个命名视图定义props配置： 1234567const routes=[ &#123; path:'/user/:id', components:&#123;default:User,sidebar:Sidebar&#125;, props:&#123;default:true,sidebar:false&#125; &#125;] 对象模式 当props是一个对象时，它将原样设置为组件props。当组件props是静态时很有用： 1234567const routes=[ &#123; path:'/promotion/from-newsletter', components:Promotion, props:&#123;newsletterPopup:false&#125; &#125;] 函数模式 创建一个返回props的函数，可以将参数转换为其他类型，将静态值与基于路由的值相结合等： 1234567const routes=[ &#123; path:'/search', components:SearchUser, props:route=&gt;(&#123;query:route.query.q&#125;) &#125;] URL/search?q=vue将传递{query:'vue'}作为props传给SearchUser组件。 尽可能保持props函数为无状态的，因此它只会在路由发生变化时起作用。若需要状态来定义props，建议使用包装组件。 不同的历史记录模式 创建路由实例时，允许在不同的历史模式中选中history配置。 Hash模式 hash模式是用createWebHashHistory()创建的： 12345678import&#123;createRouter,createWebHashHistory&#125; from 'vue-router'const router=createRouter(&#123; history:createWebHashHistory(), routes:[ //... ],&#125;) 它在内部传递的实际URL之前使用了一个哈希字符（#）。由于这部分URL从未被发送到服务器中，因此不需要再服务器上进行任何特殊处理。不过它在SEO中确实有不会的影响。若担心这个问题，可以使用HTML5模式。 HTML5模式 用createWebHistory()创建HTML5模式，推荐使用这个模式： 12345678import&#123;createRouter,createWebHistory&#125; from 'vue-router'const router=createRouter(&#123; history:createWebHistory(), routes:[ //... ],&#125;) 当应用是单页的客户端应用时，若没有适当的服务器配置，用户在浏览器中直接访问URL会得到一个404错误。 要想解决这个问题，便是要在服务器上添加一个简单的回退路由。URL不匹配任何静态资源，则应提供与应用程序中index.html相同的页面。 服务器配置实例 假设正在从根目录提供服务。若要部署到子目录中，则应使用Vue CLI的publicPath配置和相关路由的base属性。除此之外还需要调整服务端，使其使用子目录而不是根目录。 如在原生Node.js中，应调整为如下： 12345678910111213141516171819const http=require('http')const fs=require('fs')const httpPort=80http .createServer((req,res)=&gt;&#123; fs.readFile('index.html','utf-8',(err,content)=&gt;&#123; if(err)&#123; console.log('We cannot open \"index.html\" file.') &#125; res.writeHead(200,&#123; 'Content-Type':'text/html;charset=utf-8', &#125;) res.end(content) &#125;) &#125;) .listen(httpPort,()=&gt;&#123; console.log('Server listening on:http://localhost:%s',httpPort) &#125;) 配置完成后，所有未找到的路径都会显示index.html文件，因此应该在Vue应用程序中实现一个万能路由来显示404页面： 1234const router=createRouter(&#123; history:createWebHistory(), routes:[&#123;path:'/:pathMatch(.*)',component:NotFoundComponent&#125;],&#125;) 若使用的是Node.js服务器，则可以通过在服务器端使用路由来匹配URL，若没有匹配到路由，则用404来回应，从而实现回退。 内在 深入响应式原理 Vue最独特的特性之一是其非侵入性的响应式系统。数据模型仅仅是普通的JavaScript对象。当修改它们时，视图会进行更新。 如何追踪变化 当一个普通的JavaScript对象传入Vue实例作为data选项式，Vue将遍历此对象的所有property并使用Object.defineProperty把这些property全部转为getter/setter。这些getter/setter对用户来说是不可见的。但在内部它们能够让Vue追踪依赖，并在property被访问和修改是同时变更。 需要注意的是，不同浏览器在控制台打印数据对象时，对getter/setter的格式化也不同。 每个组件实例都对应一个watcher实例，它会在组件渲染时把“接触”过的数据property记录为依赖，随后依赖项的setter触发时会通知watcher，从而使它关联的组件重新渲染。 检测变化的注意事项 由于JavaScript的限制，Vue不能检测数组和对象的变化。但也还是有一些方法来回避这些限制并保证它们的响应性。 对于对象 Vue无法检测property的添加或移除。由于Vue会在初始化实例时对property执行getter/setter转化，因此property必须在data对象上存在，才能让Vue将他转换为响应式的。 123456789var vm=new Vue(&#123; data:&#123; a:1 &#125;&#125;)//vm.a是响应式的vm.b=2//vm.b是非响应式的 对于已经创建的实例，Vue不允许动态添加根级别的响应式property，但可以使用Vue.set(Object,propertName,value)方法向嵌套对象添加响应式property，如： 1Vue.set(vm.someObject,'b',2) 除此之外还可以使用vm.$set实例方法，也是全局Vue.set方法的别名： 1this.$set(this.someObject,'b',2) 有时需要为已有对象赋值多个新property，若使用Object.assign()或_.extend()，则它们添加到对象上的新property不会触发更新。此时应该用原对象与要混合进入对象的property一起创建一个新的对象： 12// 代替Object.assign(this.someObject,&#123;a:1,b:2&#125;)this.someObject=Object.assign(&#123;&#125;,this.someObject,&#123;a:1,b:2&#125;) 对于数组 Vue不能检测以下数组的变动： 利用索引直接设置一个数组项，如vm.items[indexOfItem]=newValue 修改数组长度，如vm.items.length=newLength 12345678910111213141516171819var vm=new Vue(&#123; data:&#123; items:['a','b','c'] &#125;&#125;)// 非响应式的vm.items[1]='x'vm.items.length=2// 响应式的//Vue.set方法设置数组项Vue.set(vm.items,indexOfItem,newValue)//vm.$set实例方法设置数组项，是Vue.set方法的一个别名vm.$set(vm.items,indexOfItem,newValue)//Array.prototype.splice方法设置数组项vm.items.splice(indexOfItem,1,newValue)//splice方法设置数组长度vm.items.splice(newLength) 声明响应式property 由于Vue不允许动态添加根级响应式property，因此必须要在初始化实例之前声明所有根级响应式property，包括空值： 123456789var vm=new Vue(&#123; data:&#123; //声明message为一个空值字符串 message:'' &#125;, template:'&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;'&#125;)// 给message赋值vm.message='Hello!' 若未在data选项中声明message，Vue将警告渲染函数正在视图访问不存在的property。 异步更新队列 Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。若同一个watcher被多次触发，其也只会被推入到队列中一次。 Vue在缓冲时去除重复数据避免了不必要的计算和DOM操作。然后在下一个事件循环的“tick”中，Vue刷新队列并执行实际（已去重后的）工作。Vue在内部对异步队列尝试使用原生的Promise.then、MutationObserver和setImmediate。若执行环境不支持，则会采用setTimeout(fn,0)代替。 为了在数据变化之后等待Vue完成更新DOM，可以在数据变化之后立即使用Vue.nextTick(callback)，这样回调函数将在DOM更新完成后被调用： 123456789101112131415161718&lt;body&gt;&lt;div id=\"example\"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;var vm=new Vue(&#123; el:'#example', data:&#123; message:'123' &#125;&#125;)vm.message='new message'//更改数据console.log(vm.$el.textContent)//返回123Vue.nextTick(function()&#123; console.log(vm.$el.textContent)//返回new message&#125;) 在组件内使用vm.$nextTick()实例特别方便，因此它不需要全局Vue，且回调函数中的this将自动绑定在当前的Vue实例上： 12345678910111213141516171819202122232425262728293031323334&lt;body&gt;&lt;div id=\"example\"&gt; &lt;example-oi&gt;&lt;/example-oi&gt;&lt;/div&gt; &lt;/body&gt;&lt;script&gt;Vue.component('example-oi',&#123; data:function()&#123; return&#123; message:'未更新' &#125; &#125;, template:` &lt;div&gt; &lt;button v-on:click=\"updateMessage\"&gt;点击我更新文字&lt;/button&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;/div&gt; `, methods:&#123; updateMessage:function()&#123; this.message='已更新' console.log(this.$el.textContent) this.$nextTick(function()&#123; console.log(this.$el.textContent) &#125;) &#125;, &#125;,&#125;)new Vue(&#123; el:'#example'&#125;)&lt;/script&gt; 因为$nextTick()返回一个Promise对象，因此可以使用新的ES2017 async/await 语法来完成相同的事情： 12345678methods:&#123; updateMessage:async function()&#123; this.message='已更新' console.log(this.$el.textContent) await this.$nextTick() console.log(this.$el.textContent) &#125;,&#125; vue-router路由进阶 导航守卫 vue-router提供的导航守卫主要通过跳转或取消的方式来守卫导航。 全局前置守卫 可以使用router.beforeEach注册一个全局前置守卫： 12345678const router=createRouter(&#123; //...&#125;)router.beforeEach((to,from)=&gt;&#123; //... //返回false以取消导航 return false&#125;) 当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫resolve完之前，一直处于等待中。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"前端框架","slug":"前端框架","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://tangmenjue.top/tags/Vue-js/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端框架之Vue.js（五）","slug":"前端框架之Vue.js（五）","date":"2022-11-10T09:20:06.000Z","updated":"2022-11-10T15:51:38.727Z","comments":true,"path":"2022/11/10/前端框架之Vue.js（五）/","link":"","permalink":"http://tangmenjue.top/2022/11/10/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8BVue.js%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"","text":"深入了解组件 动态组件&amp;异步组件 在动态组件上使用keep-alive 之前曾在一个多标签的页面使用is attribute来切换不同的组件： 1&lt;component v-bind:is=\"currentTabComponent\"&gt;&lt;/component&gt; 当这些组件之间来回切换时，会发现原来点击的内容被销毁了，由于 每次切换新标签时，Vue都创建了一个新实例，因此切回去时是不会保留之前选择的选项的。 若想把那些标签的组件实例能够被在它们第一次被创建时缓存下来，可以使用&lt;keep-alive&gt;元素把动态组件包裹起来，如： 1234&lt;!-- 失活的组件将会被缓存 --&gt;&lt;keep-alive&gt; &lt;component v-bind:is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt;&lt;&#x2F;keep-alive&gt; 动态组件及使用keep-alive的例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;body&gt; &lt;div id&#x3D;&quot;example&quot; class&#x3D;&quot;demo&quot;&gt; &lt;button v-for&#x3D;&quot;tab in tabs&quot; v-bind:key&#x3D;&quot;tab&quot; v-on:click&#x3D;&quot;currentTab&#x3D;tab&quot; &gt; &#123;&#123;tab&#125;&#125; &lt;&#x2F;button&gt; &lt;!-- &lt;component v-bind:is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt; --&gt; &lt;!-- 失活的组件将会被缓存 --&gt; &lt;keep-alive&gt; &lt;component v-bind:is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt; &lt;&#x2F;keep-alive&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt;&lt;script&gt;var postOne&#x3D;&#123; id:1, title:&#39;Cat Ipsum&#39;, content:&#39;&lt;p&gt;That is a content of Cat Ipsum &lt;&#x2F;p&gt;&#39;&#125;;var postTwo&#x3D;&#123; id:2, title:&#39;Hipster Ipsum&#39;, content:&#39;&lt;p&gt;That is a content of Hipster Ipsum &lt;&#x2F;p&gt;&#39; &#125;;var postThree&#x3D;&#123; id:3, title:&#39;Cupcake Ipsum&#39;, content:&#39;&lt;p&gt;That is a content of Cupcake Ipsum &lt;&#x2F;p&gt;&#39;&#125;;Vue.component(&#39;tab-posts&#39;,&#123; data:function()&#123; return&#123; posts:[postOne,postTwo,postThree], selectedPost:null &#125; &#125;, template:&#96; &lt;div&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;post in posts&quot; v-bind:key&#x3D;&quot;post.id&quot; v-on:click&#x3D;&quot;selectedPost&#x3D;post&quot; &gt; &#123;&#123;post.title&#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;div&gt; &lt;div v-if&#x3D;&quot;selectedPost&quot;&gt; &lt;div v-html&#x3D;&quot;selectedPost.content&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;strong v-else&gt; Click on a blog title to the left to view it. &lt;&#x2F;strong&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &#96; &#125;)Vue.component(&#39;tab-archive&#39;,&#123; template:&#39;&lt;div&gt;Archive component&lt;&#x2F;div&gt;&#39;&#125;)new Vue(&#123; el:&#39;#example&#39;, data:&#123; currentTab:&#39;Posts&#39;, tabs:[&#39;Posts&#39;,&#39;Archive&#39;] &#125;, computed:&#123; currentTabComponent:function()&#123; return &#39;tab-&#39;+this.currentTab.toLowerCase() &#125; &#125;&#125;)&lt;&#x2F;script&gt; &lt;keep-alive&gt;包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。 若使用v-if也想保留组件内容，可以用&lt;keep-alive&gt;包裹： 1234&lt;keep-alive&gt; &lt;component-a v-if&#x3D;&quot;a&gt;1&quot;&gt;&lt;&#x2F;component-a&gt; &lt;component-b v-else&gt;&lt;&#x2F;component-b&gt;&lt;&#x2F;keep-alive&gt; 若想使用include&amp;exclude属性也保存组件内容，也能用&lt;keep-alive&gt;包裹。其中，与include的值匹配的路由/组件会被缓存，不匹配的不会被缓存： 123&lt;keep-alive include&#x3D;&quot;tab-archive&quot;&gt; &lt;component v-bind:is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt;&lt;&#x2F;keep-alive&gt; 可以通过逗号分隔的字符串形式、正则形式、数组形式进行匹配： 123&lt;keep-alive include=\"['tab-archive','tab-posts']\"&gt; &lt;component v-bind:is=\"currentTabComponent\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 还可以利用&lt;keep-alive&gt;来设计最多可以缓存多少组件实例，一旦这个数字达到了，则在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁： 123&lt;keep-alive max=\"10\"&gt; &lt;component v-bind:is=\"currentTabComponent\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 异步组件 在大型应用中，可能需要将应用分割成小一些的代码块，并且只在需要时才从服务器加载一个模块。 为了简化，Vue允许以一个工厂函数的方式定义组件，这个工厂函数会异步解析组件的定义，只在这个组件需要被渲染时才会触发该工厂函数，并把结果缓存起来供后续重渲染。 12345678Vue.component('async-example',function(resolve,reject)&#123; seTimeout(function()&#123; //向resolve回调传递组件定义 resolve(&#123; template:'&lt;div&gt; I am async! &lt;/div&gt;' &#125;) &#125;,1000)&#125;) 上述代码的工厂函数会收到一个resolve回调，这个回调函数会在从服务器得到组件定义时被调用，也可以调用reject(reason)来表示加载失败。 将异步组件和webpack的code-splitting功能一起配合使用时，可以自动将所构建的代码切割成多个包，这些包会通过Ajax请求加载： 1234Vue.component('async-webpack-example',function(resolve)&#123; //告诉webpack自动切割构建代码 require(['./my-async-component'],resolve)&#125;) 将webpack 2和ES2015语法结合使用动态导入时，可以在工厂中返回一个Promise： 12345Vue.component( 'async-webpack-example', //这个动态导入会返回一个Promise对象 ()=&gt;import('./my-async-component')) 当使用局部注册时，也可以直接提供一个返回Promise的函数： 123456new Vue(&#123; ... components:&#123; 'my-component':()=&gt;import('./my-async-component') &#125;&#125;) 处理加载状态 异步组件工厂函数也可以返回一个如下格式的对象： 1234567const AsyncComponent=()=&gt;(&#123; component:import('./MyComponent.vue'),//需要加载的组件，返回一个promise对象 loading:LoadingComponent,//异步组件加载时使用的组件 error:ErrorComponent,//加载失败时使用的组件 delay:200,//展示加载时组件的延时时间，默认值是200毫秒 timeout:3000//若提供了超时时间且组件也加载超时了，则使用加载失败时使用的组件。默认值是infinity&#125;) 处理边界情况 访问元素&amp;组件 访问根实例 在每个new Vue实例的子组件中，其根示例可以通过$root property进行访问，如this.$root.data。 访问父级组件实例 可以通过$parent property来从一个子组件访问父组件的实例，如this.$parent.getData。 访问子组件实例或子元素 在JavaScript里直接访问一个子组件，可以先通过ref attribute为子组件赋予一个ID引用： 1&lt;base-input ref=\"usernameInput\"&gt;&lt;/base-input&gt; 然后便可以使用this.$refs.usernameInput来访问这个&lt;base-input&gt;实例。 注意：当ref和v-for一起使用时，得到的ref将会是一个包含了对应数据源的子组件数组。 $refs只会在组件渲染完成后生效，且它们不是响应式的，因此应该避免在模板或计算属性中访问$refs。 依赖注入 依赖注入可以将子组件的共用方法拓展到更深层级的嵌套组件上，使得任意后代组件中都能访问该方法，且不需要暴露该组件实例。 依赖注入用到了两个实例选项：provide和inject。 provide选项允许指定想要提供给后代组件的数据/方法。 inject选项用于接收指定的想要添加在实例上的property。 123456provide:function()&#123; return&#123; getMap:this.getMap &#125;&#125;,inject:['getMap'] 程序化的事件侦听器 处理可以被v-on侦听的$emit外，Vue实例还同时在其事件接口提供了其他的方法： $on(eventName,eventHandler)：侦听一个事件 $once(eventName,eventHandler)：一次性侦听一个事件 $off(eventName,eventHandler)：停止侦听一个事件 循环引用 递归组件 组件可以通过name选项在自己的模板中调用自身。当使用Vue.component全局注册一个组件时，全局的ID会自动设置为该组件的name选项。 组件之间的循环引用 有两个组件A和组件B，A依赖B，B又依赖A，两者之间反复进行循环引用，模块系统不知道要如果不经过其中一个组件而完全解析另一个组件而报错。 为了解决这个问题，需要把其中一个组件设为一个点，如将&lt;tree-folder&gt;组件设为哪个点，另一个子组件为&lt;tree-folder-contents&gt;，此时会等到生命周期钩子beforeCreate时去注册它： 123beforeCreate:function()&#123; this.$options.components.TreeFolderContents=require('./tree-folder-contents.vue').default&#125; 或者在本地注册组件时，用webpack的异步import来解决: 123components:&#123; TreeFolderContents:()=&gt;import('./tree-folder-contents.vue')&#125; 模板定义的替代品 内联模板 当子组件中出现inline-template attribute时，这个组件将会使用其里面的内容作为模板，而不是作为被分发的内容： 12345&lt;my-component inline-template&gt; &lt;div&gt; &lt;p&gt;123&lt;/p&gt; &lt;/div&gt;&lt;/my-component&gt; 内联模板需定义在Vue所属的DOM元素内。 X-Template 另一个定义模板的方式是在一个&lt;script&gt;元素中，并为其带上text/x-template的类型，然后通过一个id将模板引用过去： 123&lt;script type=\"text/x-template\" id=\"hello-world-template\"&gt; &lt;p&gt;Hello world &lt;/p&gt;&lt;/script&gt; 控制更新 强制更新 可以使用$forceUpdate来进行强制更新。 通过v-once创建低开销的静态组件 在包括了大量静态内容的组件里，可以在其根元素上添加v-once attribute来确保这些内容只计算一次后缓存起来。 过渡&amp;动画 进入/离开&amp;列表过渡 单元素/组件的过渡 Vue提供了transition封装组件，在以下情形中，可以给任何元素和组件添加进入/离开过渡： 条件渲染（使用v-if） 条件展示（使用v-show） 动态组件 组件根节点 例如： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;button v-on:click=\"show=!show\"&gt;Toggle&lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt;new Vue(&#123; el:'#demo', data:&#123; show:true &#125;&#125;)&lt;/script&gt;&lt;style&gt;.fade-enter-active,.fade-leave-active&#123; transition:opacity .5s;&#125;.fade-enter,.fade-leave-to&#123; opacity: 0;&#125;&lt;/style&gt;&lt;/html&gt; 当插入或删除包含在transition组件中的元素时，Vue将会做以下处理： 自动嗅探目标元素是否应用了CSS过渡或动画，若是，在恰当的时机添加/删除CSS类名 若过渡组件提供了JavaScript钩子函数，这些钩子函数将在恰当的时机被调用 若没有找到JavaScript钩子函数，也没有检测到CSS过渡/动画，DOM操作（插入/删除）在下一帧中立即执行 过渡的类名 在进入/离开的过渡中，会有6个class切换： v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间、延迟和曲线函数。 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除 v-enter-to：定义进入过渡的结束状态。在元素被插入之后下一帧生效，在过渡/动画完成之后移除 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间、延迟和曲线函数。 v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除 v-leave-to：定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效，在过渡/动画完成之后移除 对于在过渡切换的来命名来说，若使用的是没有名字的&lt;transition&gt;，则v-是这些类名的默认前缀。若使用了&lt;transition name=\"my-transition\"&gt;，那么v-enter会替换成my-transition-enter CSS过渡 常用的过渡都是使用CSS过渡。 例如： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;button @click=\"show=!show\"&gt;Toggle render&lt;/button&gt; &lt;transition name=\"slide-fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt;new Vue(&#123; el:'#demo', data:&#123; show:true &#125;&#125;)&lt;/script&gt;&lt;style&gt;.slide-fade-enter-active&#123; transition:all .3s ease;&#125;.slide-fade-leave-active&#123; transition:all .8s cubic-bezier(1.0,0.5,0.8,1.0);&#125;.slide-fade-enter,.slide-fade-leave-to&#123; transform: translateX(10px); opacity: 0;&#125;&lt;/style&gt;&lt;/html&gt; CSS动画 CSS动画用法与CSS过渡相同，其区别是在动画中v-enter类名在节点插入DOM后不会立即删除，而是在animationend时间触发时删除。 例如： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;button @click=\"show=!show\"&gt;Toggle show&lt;/button&gt; &lt;transition name=\"bounce\"&gt; &lt;p v-if=\"show\"&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt;new Vue(&#123; el:'#demo', data:&#123; show:true &#125;&#125;)&lt;/script&gt;&lt;style&gt;.bounce-enter-active&#123; animation: bounce-in .5s;&#125;.bounce-leave-active&#123; animation: bounce-in .5s reverse;&#125;@keyframes bounce-in&#123; 0%&#123; transform: scale(0); &#125; 50%&#123; transform: scale(1.5); &#125; 100%&#123; transform: scale(1); &#125;&#125;&lt;/style&gt;&lt;/html&gt; 自定义过渡的类名 可以通过以下attribute来自定义过渡类名： enter-active-class enter-class enter-to-class leave-active-class leave-class leave-to-class 这些attribute的优先级高于普通的类名，这对Vue的过渡系统和其他第三方CSS动画库的使用十分有用。 1234567891011121314151617181920&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;button @click=\"show=!show\"&gt;Toggle render&lt;/button&gt; &lt;transition name=\"custom-classes-transition\" enter-active-class=\"animated data\" leave-active-class=\"animated bounceOutRight\" &gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt;new Vue(&#123; el:'#demo', data:&#123; show:true &#125;&#125;)&lt;/script&gt; 同时使用过渡和动画 Vue为了知道过渡的完成，必须设置相应的事件监听器。其可以是transitionend或animationend，这取决于给元素应用的CSS规则，若使用其中任何一种，Vue能自动识别类型并设置监听。 若给同一种元素同时设置两种过渡动效时，需要使用type attribute来设置animationend或transitionend来明确声明需要Vue监听的类型。 显性的过渡持续时间 大多数情况下，Vue可以自动得出过渡效果的完成时机。默认情况下，Vue会等待其在过渡效果根元素的第一个transitionend或animationend时间。 也可以使用transition组件上的duration prop来定制一个显性的过渡持续时间（以毫秒为单位）： 123&lt;transition :duration=\"1000\"&gt;...&lt;/transition&gt; &lt;!-- 也可以定制进入和移除的持续时间 --&gt;&lt;transition :duration=\"&#123;enter:500,leave:800&#125;\"&gt;...&lt;/transition&gt; JavaScript钩子 可以在attribute中声明JavaScript钩子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;button @click=\"show=!show\"&gt;Toggle render&lt;/button&gt; &lt;transition v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:after-enter=\"afterEnter\" v-on:enter-cancelled=\"enterCancelled\" v-on:before-leave=\"beforeLeave\" v-on:leave=\"leave\" v-on:after-leave=\"afterLeave\" v-on:leave-cancelled=\"leaveCancelled\" &gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt;new Vue(&#123; el:'#demo', data:&#123; show:true &#125;, methods:&#123; //进入中 beforeEnter:function(el)&#123; //... &#125;, //当与CSS结合使用时，回调函数done是可选的 enter:function(el,done)&#123; //... done() &#125;, afterEnter:function(el)&#123; //... &#125;, enterCancelled:function(el)&#123; //... &#125;, //离开时 beforeLeave:function(el)&#123; //... &#125;, //当与CSS结合使用时，回调函数done是可选的 leave:function(el,done)&#123; //... done() &#125;, afterLeave:function(el)&#123; //... &#125;, leaveCancelled:function(el)&#123; //... &#125;, &#125;&#125;)&lt;/script&gt; 这些钩子函数可以结合CSS transitions/animations使用，也可以单独使用。 当只用JavaScript过渡时，在enter和leave中必须使用done进行回调，否则两者将被同步调用，过渡会立即完成。 对于仅使用JavaScript过渡的元素添加v-bind:css=\"false\",Vue会跳过CSS的检测。这可以避免过渡过程中CSS的影响。 初始渲染的过渡 可以通过appear attribute来设置节点在初始渲染的过渡： 123456789 &lt;!-- 可以自定义CSS类名，也可以自定义JavaScript钩子 --&gt; &lt;transition appear appear-class=\"custom-appear-class\" appear-to-class=\"custom-appear-to-class\"(2.1.8) appear-active-class=\"custom-appear-active-class\" v-on:before-appear=\"customBeforeAppearHook\" v-on:appear=\"customAppearHook\"&gt;&lt;/transition&gt; 多个元素的过渡 对于原生标签可以使用v-if/v-else来实现多个组件的过渡，最常见的多标签过渡是一个列表和描述这个列表为空消息的元素： 12345&lt;transition&gt; &lt;!-- 当有相同标签名的元素切换时，需要通过key attribute来设置唯一的值来标记 --&gt; &lt;buttion v-if=\"isEditing\" key=\"save\"&gt;Save&lt;/buttion&gt; &lt;buttion v-else key=\"edit\"&gt;Edit&lt;/buttion&gt;&lt;/transition&gt; 在一些场景中，也可以通过给同一个元素的key attribute设置不同的状态来代替v-if和v-else： 12345&lt;transition&gt; &lt;buttion v-bind:key=\"isEditing\"&gt; &#123;&#123;isEdting?\"Save\":\"Edit\"&#125;&#125; &lt;/buttion&gt;&lt;/transition&gt; 使用多个v-if的多个元素过渡，可以重写为绑定了动态property的单个元素过渡，如： 123456&lt;transition&gt; &lt;buttion v-if=\"docState==='saved'\" key=\"saved\"&gt;Edit&lt;/buttion&gt; &lt;buttion v-if=\"docState==='edited'\" key=\"edited\"&gt;Save&lt;/buttion&gt; &lt;buttion v-if=\"docState==='editing'\" key=\"editing\"&gt;Cancel&lt;/buttion&gt; &lt;/buttion&gt;&lt;/transition&gt; 可以重写为： 123456789101112131415161718&lt;transition&gt; &lt;button v-bind:key=\"docState\"&gt; &#123;&#123;buttonMessage&#125;&#125; &lt;/button&gt;&lt;/transition&gt;&lt;script&gt;//...computed:&#123; buttonMessage:function()&#123; switch(this.docSate)&#123; case 'saved':return 'Edit' case 'edited':return 'Save' case 'editing':return 'Cancel' &#125; &#125;&#125; &lt;/script&gt; 过渡模式 由于同时生效的进入和离开的过渡不能满足所有要求，因此Vue提供了过渡模式： in-out：新元素先进行过渡，完成之后当前元素过渡离开 out-in：当前元素先进行过渡，完成之后新元素过渡进入 1&lt;transition name=\"fade\" mode=\"out-in\"&gt;&lt;/transition&gt; 多个组件的过渡 只需要使用动态组件便可以使用key attribute： 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;input type=\"radio\" @click=\"view='v-a'\" name=\"view\" checked&gt; &lt;label for=\"a\"&gt;A&lt;/label&gt; &lt;input type=\"radio\" @click=\"view='v-b'\" name=\"view\"&gt; &lt;label for=\"b\"&gt;B&lt;/label&gt; &lt;transition name=\"component-fade\" mode=\"out-in\"&gt; &lt;component v-bind:is=\"view\"&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt;new Vue(&#123; el:'#demo', data:&#123; view:'v-a' &#125;, components:&#123; 'v-a':&#123; template:'&lt;div&gt;Component A&lt;/div&gt;' &#125;, 'v-b':&#123; template:'&lt;div&gt;Component B&lt;/div&gt;' &#125; &#125;&#125;)&lt;/script&gt;&lt;style&gt; .component-fade-enter-active,.component-fade-leave-active&#123; transition:opacity .3s ease; &#125; .component-fade-enter,.component-fade-leave-to&#123; opacity: 0; &#125;&lt;/style&gt; 列表过渡 需要同时渲染整个列表时，使用&lt;transition-group&gt;组件，这个组件的特点如下： 不同于&lt;transition&gt;，它会以一个真实元素呈现：默认为一个&lt;span&gt;，也可以通过tag attribute更换为其他元素 过渡模式不可用 内部元素总是需要提供一个唯一的key attribute CSS过渡的类将会应用在内部的元素中，而不是这个组/容器本身。 列表的进入/离开过渡 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;body&gt; &lt;div id=\"list-demo\" class=\"demo\"&gt; &lt;button v-on:click=\"add\"&gt;Add&lt;/button&gt; &lt;button v-on:click=\"remove\"&gt;Remove&lt;/button&gt; &lt;transition-group name=\"list\" tag=\"p\"&gt; &lt;span v-for=\"item in items\" v-bind:key=\"item\" class=\"list-item\"&gt; &#123;&#123;item&#125;&#125; &lt;/span&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt;new Vue(&#123; el:'#list-demo', data:&#123; items:[1,2,3,4,5,6,7,8,9], nextNum:10 &#125;, methods:&#123; randomIndex:function()&#123; return Math.floor(Math.random()*this.items.length) &#125;, add:function()&#123; this.items.splice(this.randomIndex(),0,this.nextNum++) &#125;, remove:function()&#123; this.items.splice(this.randomIndex(),1) &#125;, &#125;&#125;)&lt;/script&gt;&lt;style&gt;.list-item&#123; display: inline-block; margin-right: 10px;&#125;.list-enter-active,.list-leave-active&#123; transition: all 1s;&#125;.list-enter,.list-leave-to&#123; opacity: 0; transform: translateY(30px);&#125;&lt;/style&gt; 列表的排序过渡 &lt;transition-group&gt;组件不仅可以进入和离开动画，还可以使用v-model class改变定位。对于v-model class，可以通过name attribute来自定义前缀，也可以通过move-class attribute手动设置。 v-model class对于设置过渡的切换时机和过渡曲线非常有用，以下例子使用了一个FLIP的简单动画队列，使用transforms将元素从之前的位置平滑过渡到新位置中： 1234567891011121314151617181920212223242526272829303132333435&lt;head&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"flip-list-demo\" class=\"demo\"&gt; &lt;button v-on:click=\"shuffle\"&gt;Shuffle&lt;/button&gt; &lt;transition-group name=\"flip-list\" tag=\"ul\"&gt; &lt;li v-for=\"item in items\" v-bind:key=\"item\"&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt;new Vue(&#123; el:'#flip-list-demo', data:&#123; items:[1,2,3,4,5,6,7,8,9], &#125;, methods:&#123; shuffle:function()&#123; this.items=_.shuffle(this.items) &#125; &#125;&#125;)&lt;/script&gt;&lt;style&gt;.flip-list-move&#123; transition: transform 1s;&#125;&lt;/style&gt; 将上述代码与列表进入/离开过渡的例子结合，可式列表的一切变动都会有动画过渡： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"list-complete-demo\" class=\"demo\"&gt; &lt;button v-on:click=\"shuffle\"&gt;Shuffle&lt;/button&gt; &lt;button v-on:click=\"add\"&gt;Add&lt;/button&gt; &lt;button v-on:click=\"remove\"&gt;Remove&lt;/button&gt; &lt;transition-group name=\"list-complete\" tag=\"p\"&gt; &lt;span v-for=\"item in items\" v-bind:key=\"item\" class=\"list-complete-item\"&gt; &#123;&#123;item&#125;&#125; &lt;/span&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt;new Vue(&#123; el:'#list-complete-demo', data:&#123; items:[1,2,3,4,5,6,7,8,9], nextNum:10 &#125;, methods:&#123; randomIndex:function()&#123; return Math.floor(Math.random()*this.items.length) &#125;, add:function()&#123; this.items.splice(this.randomIndex(),0,this.nextNum++) &#125;, remove:function()&#123; this.items.splice(this.randomIndex(),1) &#125;, shuffle:function()&#123; this.items=_.shuffle(this.items) &#125; &#125;&#125;)&lt;/script&gt;&lt;style&gt;.list-complete-item&#123; transition: all 1s; display: inline-block; margin-right: 10px;&#125;.list-complete-leave-active&#123; position: absolute;&#125;.list-complete-enter,.list-complete-leave-to&#123; opacity: 0; transform: translateY(30px);&#125;&lt;/style&gt;&lt;/html&gt; 注意：使用FLIP过渡的元素不能设置为display:inline，可以设为display:inline-block或者放置于flex中。 列表的交错过渡 通过data attribute与JavaScript通信，可以实现列表的交错过渡： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"staggered-list-demo\"&gt; &lt;input v-model=\"query\"&gt; &lt;transition-group name=\"staggered-fade\" tag=\"ul\" v-bind:css=\"false\" v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\" &gt; &lt;li v-for=\"(item,index) in computedList\" v-bind:key=\"item.msg\" v-bind:data-index=\"index\" &gt;&#123;&#123;item.msg&#125;&#125;&lt;/li&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt;new Vue(&#123; el:'#staggered-list-demo', data:&#123; query:'', list:[ &#123;msg:'Bruce Lee'&#125;, &#123;msg:'Jackie Chan'&#125;, &#123;msg:'Chuck Norris'&#125;, &#123;msg:'Jet Li'&#125;, &#123;msg:'Kung Fury'&#125;, ] &#125;, computed:&#123; computedList:function()&#123; var vm=this return this.list.filter(function(item)&#123; return item.msg.toLowerCase().indexOf(vm.query.toLowerCase())!==-1 &#125;) &#125; &#125;, methods:&#123; beforeEnter:function(el)&#123; el.style.opacity=0 el.style.height=0 &#125;, enter:function(el,done)&#123; var delay=el.dataset.index*150 setTimeout(function()&#123; Velocity( el, &#123;opacity:1,height:'1.6em'&#125;, &#123;complete:done&#125; ) &#125;,delay) &#125;, leave:function(el,done)&#123; var delay=el.dataset.index*150 setTimeout(function()&#123; Velocity( el, &#123;opacity:0,height:0&#125;, &#123;complete:done&#125; ) &#125;,delay) &#125; &#125;&#125;)&lt;/script&gt;&lt;/html&gt; 可复用的过渡 过渡可以通过Vue的组件系统实现复用。创建一个可复用过渡组件，只需将&lt;transition&gt;或&lt;transition-group&gt;作为根组件，然后将任何子组件放置在其中即可： 动态过渡 在Vue中即使是过渡也是数据驱动的，通过name attribute来绑定动态之是动态过渡最基本的例子： 1&lt;transition v-bind:name=\"transitionName\"&gt;&lt;/transition&gt; 使用Vue的过渡系统来定义CSS过渡/动画在不同过渡间切换会非常有用。 所有过渡attribute都可以动态绑定，不仅只有attribute可以利用，还可以通过事件钩子获取上下文中的所有数据，即可实现根据组件状态不同，JavaScript过渡也会有不同的表现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"dynamic-fade-demo\" class=\"demo\"&gt; Fade In:&lt;input type=\"range\" v-model=\"fadeInDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\"&gt; Fade Out:&lt;input type=\"range\" v-model=\"fadeOutDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\"&gt; &lt;transition v-bind:css=\"false\" v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\" &gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;button v-if=\"stop\" v-on:click=\"stop=false;show=false\" &gt;Start animating&lt;/button&gt; &lt;button v-else v-on:click=\"stop=true\" &gt;Stop it!&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt;new Vue(&#123; el:'#dynamic-fade-demo', data:&#123; show:true, fadeInDuration:1000, fadeOutDuration:1000, maxFadeDuration:1500, stop:true &#125;, mounted:function()&#123; this.show=false &#125;, methods:&#123; beforeEnter:function(el)&#123; el.style.opacity=0 &#125;, enter:function(el,done)&#123; var vm=this Velocity(el, &#123;opacity:1&#125;, &#123; duration:this.fadeInDuration, complete:function()&#123; done() if(!vm.stop) vm.show=false &#125; &#125; ) &#125;, leave:function(el,done)&#123; var vm=this Velocity(el, &#123;opacity:0&#125;, &#123; duration:this.fadeOutDuration, complete:function()&#123; done() vm.show=true &#125; &#125; ) &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 创建动态过渡的最终方案是组件通过接收props来动态修改之前的过渡。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"前端框架","slug":"前端框架","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://tangmenjue.top/tags/Vue-js/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端框架之Vue.js（四）","slug":"前端框架之Vue.js（四）","date":"2022-11-09T09:18:37.000Z","updated":"2022-11-10T15:51:43.641Z","comments":true,"path":"2022/11/09/前端框架之Vue.js（四）/","link":"","permalink":"http://tangmenjue.top/2022/11/09/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8BVue.js%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"深入了解组件 组件注册 组件名 注册一个组件时，要给组件起名，如在全局注册中，组件名就是Vue.component的第一个参数： 1Vue component('my-component-name',&#123;&#125;) 组件名应当遵守W3C规范中的自定义组件名（字母全小写且必须包含一个连字符） 组件名大小写 定义组件名的方式由两种： 使用短横线分隔命名:my-component-name 使用首字母大写命名：MyComponentName 两种命名法都可以使用，但需注意的是，直接在DOM（即非字符串的模板）中使用时，只有短横线分隔命名是有效的。 全局注册 使用全局注册的组件，在它们注册之后可以用在任何新创建的Vue根实例的模板中，在子组件的内部也可以相互使用。 12Vue component('my-component-name',&#123;&#125;)new Vue(&#123;el:'#app'&#125;) 局部注册 若使用webpack这个的构建系统，全局注册所有的组件便意味着即使不再使用这个组件了，它仍然会被包含在最终的构建结果中。此时，可以将组件局部注册： 1234567891011// 通过一个普通的JavaScript对象来定义组件var ComponentA=&#123;&#125;var ComponentB=&#123;&#125;// 在component中定义要使用的组件new Vue(&#123; el:'#app', components:&#123; 'components-a':ComponentA, 'components-b':ComponentB &#125;&#125;) 对于components对象中的每个property来说，其property名就是自定义元素的名字，其property值就是这个组件的选项对象。 局部注册的组件在其子组件中不可用。所希望上述代码中的ComponentA在ComponentB中可用，则要写成： 123456var ComponentA=&#123;&#125;var ComponentB=&#123; components:&#123; 'components-a':ComponentA &#125;&#125; 模块系统 在模块系统中局部注册 若使用了注入Babel和webpack的模块系统，需要创建一个components目录，并将每个组件放置在其各自的文件中，然后在局部注册之前导入每个想使用的组件。如在一个ComponentB.vue文件中使用ComponentA： 123456import ComponentA from './ComponentA.vue'export default&#123; components:&#123; ComponentA &#125;&#125; 在ES2015+中，在对象中放一个类似ComponentA的变量名便是'ComponentsA':ComponentA的缩写，即这个变量名同时是用在模板中的自定义元素的名称，也包含了这个组件选项的变量名。 基础组件的自动化全局注册 当组件中只是包裹了一个输入框或按钮之类的通用元素时，将其称之为基础组件，它们会在各个组件中被频繁地用到。 这往往会导致组件里都会由一个包含基础组件的长列表，但用于模板中的仅是一小部分组件： 12345678910111213141516171819202122&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;BaseInput v-model&#x3D;&quot;searchText&quot; @keydown.enter&#x3D;&quot;search&quot; &#x2F;&gt; &lt;BaseButton @click&#x3D;&quot;search&quot;&gt; &lt;BaseIcon name&#x3D;&quot;search&quot; &#x2F;&gt; &lt;&#x2F;BaseButton&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt;&lt;script&gt;import BaseButton from &#39;.&#x2F;BaseButton.vue&#39;import BaseIcon from &#39;.&#x2F;BaseIcon.vue&#39;import BaseInput from &#39;.&#x2F;BaseInput.vue&#39;export default&#123; components:&#123; BaseButton, BaseIcon, BaseInput &#125;&#125;&lt;&#x2F;script&gt; 若使用webpack（或在内部使用了webpack的Vue CLI 3+），则可以使用require.context只全局注册这些通用的基础组件。如在应用入口文件（如src/main.js）中全局导入基础组件的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;BaseInput v-model&#x3D;&quot;searchText&quot; @keydown.enter&#x3D;&quot;search&quot; &#x2F;&gt; &lt;BaseButton @click&#x3D;&quot;search&quot;&gt; &lt;BaseIcon name&#x3D;&quot;search&quot; &#x2F;&gt; &lt;&#x2F;BaseButton&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt;&lt;script&gt;import Vue from &#39;vue&#39;import upperFirst from &#39;lodash&#x2F;upperFirst&#39;import camelCase from &#39;lodash&#x2F;camelCase&#39;const requireComponent&#x3D;require.context( &#39;.&#x2F;components&#39;,&#x2F;&#x2F;组件目录的相对路径 false,&#x2F;&#x2F;是否查询其子目录 &#x2F;&#x2F;匹配基础组件文件名的正则表达式 &#x2F;Base[A-Z]\\w+\\.(vue|js)$&#x2F;)requireComponent.keys().forEach(fileName&#x3D;&gt;&#123; const componentConfig&#x3D;requireComponent(fileName)&#x2F;&#x2F;获取组件配置 const componentName&#x3D;upperFirst(&#x2F;&#x2F;获取组件的PascalCase命名 camelCase( fileName&#x2F;&#x2F;获取和目录深度无关的文件名 .split(&#39;&#x2F;&#39;) .pop() .replace(&#x2F;\\.\\w+$&#x2F;,&#39;&#39;) ) ) &#x2F;&#x2F;全局注册组件 Vue.component( componentName, &#x2F;&#x2F; 若这个组件选项是通过export default导出的，就优先使用.default，否则回退到使用模块的根 componentConfig.default||componentConfig )&#125;)&lt;&#x2F;script&gt; Prop Prop的大小写 HTML中的attribute名是大小写不敏感的，浏览器会把所有大写字符解释为小写字符。这意味着在使用DOM模板时，驼峰命名的prop名需要使用其等价的短横线分隔来命名： 1234567Vue.component(&#39;blog-post&#39;,&#123; &#x2F;&#x2F;在JavaScript中是驼峰命名 props:&#123;&#39;postTitle&#39;&#125;, template:&#39;&lt;h3&gt;&#123;&#123;postTitle&#125;&#125;&lt;&#x2F;h3&gt;&#39;&#125;)&#x2F;&#x2F; 在HTML中是短横线分隔命名&lt;blog-post post-title&#x3D;&quot;hello!&quot;&gt;&lt;&#x2F;blog-post&gt; 而在字符串模板中便不存在这个限制。 Prop类型 Prop的类型有以下八种： String Number Boolean Array Object Date Function Symbol props的写法（无默认值）： 123456789props:&#123; title:String, likes:Number, isPublished:Boolean, commentIds:Array, author:Object, callback:Function, contactsPromise:promise&#125; 传递静态或动态Prop 任何类型的值都可以传给一个prop，不仅能传入静态的值，还能通过v-bind动态赋值： 12345678&#x2F;&#x2F; 给prop传入静态的值&lt;blog-post title&#x3D;&quot;My journey with Vue&quot;&gt;&lt;&#x2F;blog-post&gt;&#x2F;&#x2F; 通过v-bind动态赋予一个变量的值&lt;blog-post v-bind:title&#x3D;&quot;post.title&quot;&gt;&lt;&#x2F;blog-post&gt;&#x2F;&#x2F; 通过v-bind动态赋予一个复杂表达式的值&lt;blog-post v-bind:title&#x3D;&quot;post.title+&#39;by&#39;+post.author.name&quot;&gt;&lt;&#x2F;blog-post&gt; 传入一个数字 123456&#x2F;&#x2F; 即使42是静态的，但仍需v-bind来告诉Vue&#x2F;&#x2F; 这是一个JavaScript表达式而不是一个字符串&lt;blog-post v-bind:likes&#x3D;&quot;42&quot;&gt;&lt;&#x2F;blog-post&gt;&#x2F;&#x2F; 通过v-bind动态赋予一个变量的值&lt;blog-post v-bind:likes&#x3D;&quot;post.likes&quot;&gt;&lt;&#x2F;blog-post&gt; 传入一个布尔值 123456789&#x2F;&#x2F; 即使prop没有值，结果都是true&lt;blog-post is-published&gt;&lt;&#x2F;blog-post&gt;&#x2F;&#x2F; 即使false是静态的，但仍需v-bind来告诉Vue&#x2F;&#x2F; 这是一个JavaScript表达式而不是一个字符串&lt;blog-post v-bind:is-published&#x3D;&quot;false&quot;&gt;&lt;&#x2F;blog-post&gt;&#x2F;&#x2F; 通过v-bind动态赋予一个变量的值&lt;blog-post v-bind:is-published&#x3D;&quot;post.isPublished&quot;&gt;&lt;&#x2F;blog-post&gt; 传入一个数组 123456&#x2F;&#x2F; 即使数组是静态的，但仍需v-bind来告诉Vue&#x2F;&#x2F; 这是一个JavaScript表达式而不是一个字符串&lt;blog-post v-bind:comment-ids&#x3D;&quot;[234,266,273]&quot;&gt;&lt;&#x2F;blog-post&gt;&#x2F;&#x2F; 通过v-bind动态赋予一个变量的值&lt;blog-post v-bind:comment-ids&#x3D;&quot;post.commentIds&quot;&gt;&lt;&#x2F;blog-post&gt; 传入一个对象 12345678910&#x2F;&#x2F; 即使对象是静态的，但仍需v-bind来告诉Vue&#x2F;&#x2F; 这是一个JavaScript表达式而不是一个字符串&lt;blog-post v-bind:author&#x3D;&quot;&#123; name:&#39;Veronica&#39;, company:&#39;Veridian Dynamics&#39; &#125;&quot;&gt;&lt;&#x2F;blog-post&gt;&#x2F;&#x2F; 通过v-bind动态赋予一个变量的值&lt;blog-post v-bind:author&#x3D;&quot;post.author&quot;&gt;&lt;&#x2F;blog-post&gt; 传入一个对象的所有property 若要将一个对象的所有property都作为prop传入，可以使用不带参数的v-bind来取代v-bind:prop-name 1234567891011121314&#x2F;&#x2F;给定的对象postpost:&#123; id:1, title:&#39;My Journey with Vue&#39;&#125;&#x2F;&#x2F; 通过v-bind动态赋予一个变量的值&lt;blog-post v-bind&#x3D;&quot;post&quot;&gt;&lt;&#x2F;blog-post&gt;&#x2F;&#x2F;等价于&lt;blog-post v-bind:id&#x3D;&quot;post.id&quot; v-bind:title&#x3D;&quot;post.title&quot;&gt;&lt;&#x2F;blog-post&gt; 单向数据流 所有的prop都使得其父子prop之间形成了一个单向下行绑定：父级prop的更新会向下流动到子组件中，但反过来则不行，这样防止了从子组件意外变更父级组件的状态。 每次父级组件发生变更时，子组件中所有的prop都将会刷新为最新的值，因此不应在一个子组件内部改变prop。 若要变更一个prop，可通过以下方法进行变更： 这样prop用来传递一个初始值，子组件希望将其作为一个本地的prop数据来使用。此时最好定义一个本地的data property并将这个prop用作其初始值： 123456props:['initialCounter'],data:function()&#123; return &#123; counter:this.initialCounter &#125;&#125; 这个prop以一种原始的值传入且需要进行转化。此时最好使用这个prop的值来定义一个计算属性： 123456props:['size'],computed:&#123; normalizeSize:function()&#123; return this.size.trim().toLowerCase() &#125;&#125; 注意：在JavaScript中对象和数组是通过引用传入的，所以对于一个数组或对象类型的prop来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。 Prop验证 可以通过在props中的值提供一个带有验证需求的对象，从而指定组件的prop验证方式。即为props设定默认值如下： 1234567891011121314151617181920212223242526272829props:&#123; propA:Number,&#x2F;&#x2F;基础的类型检查 propB:[String,Number],&#x2F;&#x2F;多个可能的类型 &#x2F;&#x2F;必填的字符串 propC:&#123; type:String, required:true &#125;, &#x2F;&#x2F; 带有默认值的数字 propD:&#123; type:Number, default:100 &#125;, &#x2F;&#x2F; 带有默认值的对象 propE:&#123; type:Object, &#x2F;&#x2F; 对象或数组默认值必须从一个工厂函数获取 default:function()&#123; return &#123;message:&#39;hello&#39;&#125; &#125; &#125;, &#x2F;&#x2F; 自定义验证函数 propF:&#123; validator:function(value)&#123; &#x2F;&#x2F; 这个值必须匹配下列字符串中的一个 return [&#39;success&#39;,&#39;warning&#39;,&#39;danger&#39;].indexOf(value)!&#x3D;&#x3D;-1 &#125; &#125;&#125; 当prop验证失败时，Vue将会产生一个控制台的警告。 prop会在组件实例创建之前进行验证，因此实例的property（如data、computed等）在default或validator函数中是不可用的。 类型检查 prop类型除了可以是八种原生类型之外，还可以是自定义的构造函数，并且通过instanceof来进行检查确认： 123456789101112//给定构造函数Personfunction Person (firstName,lastName)&#123; this.firstName=firstName this.lastName=lastName&#125;//验证 author prop的值是否是通过new Person创建的Vue.component('blog-post',&#123; props:&#123; author:Person &#125;&#125;) 非Prop的Attribute 传向一个组件，但组件中没有相应prop定义的attribute称之为非prop的attribute。显式定义的prop适用于向一个子组件传入信息。组件可以接收任意的attribute，而这些attribute会被添加到这个组件的根元素上。 替换/合并已有的Attribute 现有一个Bootstrap插件里使用了第三方组件&lt;bootstrap-date-input&gt;，其模板如下： 1&lt;input type=\"data\" class=\"form-control\"&gt; 若要为这个插件定制一个主体，则需要添加一个特别的类名如下： 1234&lt;bootstrap-date-input data-date-picker=\"activated\" class=\"date-picker-theme-dark\"&gt;&lt;/bootstrap-date-input&gt; 在这种情况下共定义了两个不同的class值： form-control：组件模板内设置好的class date-picker-theme-dark：从组件父级传入的 对于绝大多数attribute来说，从外部提供给组件的值会替换掉组件内部设置好的值，因此若直接传入type=\"text\"就会替换掉type=\"date\"并将其破坏掉。而class和style attribute会将两边的值合起来，从而得到最终值：form-control date-picker-theme-dark。 禁用Attribute继承 若不希望组件的根元素继承attribute，可以在组件的选项中设置inheritAttris:false，配合实例的$attrs property使用，便可以手动决定这些attribute会被赋予哪个元素，常用于撰写基础组件中： 1234567891011121314Vue.component('base-input',&#123; inheritAttrs:false, props:['label','value'], template: ` &lt;label&gt; &#123;&#123;label&#125;&#125; &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on:input=\"$emit('input',$event.target.value)\" &gt; &lt;/label&gt; ` &#125;)xxxxxxxxxx16 1Vue.component('base-input',&#123;2 inheritAttrs:false,3 props:['label','value'],4 template: `5 &lt;label&gt;6 &#123;&#123;label&#125;&#125;7 &lt;input8 v-bind=\"$attrs\"9 v-bind:value=\"value\"10 v-on:input=\"$emit('input',$event.target.value)\"11 &gt;12 &lt;/label&gt;13 ` 14&#125;)Vue.component('my-component',&#123;15 inheritAttrs:false,16&#125;) 其中，inheritAttris:false选项不会影响style和class的绑定。 这个模式允许在使用基础组件时更像是使用原始的HTML元素，而不用担心哪个元素才是真正的根元素。 自定义事件 事件名 不同于组件和prop，事件名不存在任何自动化的大小写转化，触发的事件名需要完全匹配监听这个事件所用的名称。如触发事件名是驼峰式命名的，则监听该名字的短横线分隔命名版本是不会有任何效果的。 不同于组件和prop，事件名不会被用作一个JavaScript变量名或property名，因此不会使用驼峰命名或首字母大写命名。且v-on事件监听器在DOM模板中会被自动转换为全小写，因此推荐事件名使用短横线分隔命名。 自定义组件的v-model 一个组件上的v-model默认会利用名为value的prop和名为input的事件。但像单选框、复选框等类型的输入控件可能会将value attribute用于不同的目的，为避免冲突，可使用model选项： 1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;!-- lovingVue的值将会传如名为checked的prop --&gt; &lt;!-- 当&lt;base-checkbox&gt;触发一个change事件并附带一个新值时，lovingVue的property将会被更新 --&gt; &lt;base-checkbox v-model&#x3D;&quot;lovingVue&quot;&gt;&lt;&#x2F;base-checkbox&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt;&lt;script&gt;Vue.component(&#39;base-checkbox&#39;,&#123; model:&#123; prop:&#39;checked&#39;, event:&#39;change&#39; &#125;, props:&#123; checked:Boolean&#x2F;&#x2F;props里仍需要声明checked这个prop &#125;, template:&#96; &lt;input type&#x3D;&quot;checkbox&quot; v-bind:checked&#x3D;&quot;checked&quot; v-on:change&#x3D;&quot;$emit(&#39;change&#39;,$event.target.checked)&quot; &gt; &#96; &#125;)&lt;&#x2F;script&gt; 将原生事件绑定到组件 若要在一个组件的根元素上直接监听一个原生事件，可以使用v-on的.native修饰符： 1&lt;base-input v-on:focus.native=\"onFocus\"&gt;&lt;/base-input&gt; 当监听一个类似&lt;input&gt;的特定元素时，父级的.native监听器将会静默失败，其不会产生任何报错，但onFocus处理函数也不会被调用。 Vue提供了一个$listeners property来解决这一问题，它是一个对象，里面包含了作用在这个组件上的所有监听器，如： 1234&#123; focus:function(event)&#123;&#125;, input:function(event)&#123;&#125; &#125; 有了$listeners property，再配合v-on=$listeners便可以将所有的事件监听器指向这个组件的某个特定的子元素。 对于希望&lt;input&gt;也能配合v-model工作的组件，应为这些监听器创建一个inputListeners计算属性如下所示： 1234567891011121314151617181920212223242526272829&lt;script&gt;Vue.component(&#39;base-input&#39;,&#123; inheritAttrs:false, props:[&#39;label&#39;,&#39;value&#39;], computed:&#123; inputListeners:function()&#123; var vm&#x3D;this return Object.assign(&#123;&#125;, this.$listeners, &#123; input:function(event)&#123; vm.$emit(&#39;input&#39;,event.target.value) &#125; &#125; ) &#125; &#125;, template: &#96; &lt;label&gt; &#123;&#123;label&#125;&#125; &lt;input v-bind&#x3D;&quot;$attrs&quot; v-bind:value&#x3D;&quot;value&quot; v-on&#x3D;&quot;inputListeners&quot; &gt; &lt;&#x2F;label&gt; &#96; &#125;)&lt;&#x2F;script&gt; 此时&lt;base-input&gt;组件是一个完全透明的包裹器了，即它可以像一个普通的&lt;input&gt;元素一样使用。所有跟&lt;base-input&gt;组件相同的attribute和监听器都可以工作，不必再使用.native监听器来监听事件。 .sync修饰符 若需要对一个prop进行”双向绑定“时，可以用update:myPropName的模式触发事件来处理。 如在一个包含title prop的组件中： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;script&gt;Vue.component(&#39;text-document&#39;,&#123; props:[&#39;title&#39;], template: &#96; &lt;div&gt; 我是子节点 &lt;button @click&#x3D;&quot;handleClick&quot;&gt;点击我改变父级Title&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &#96;, methods:&#123; handleClick()&#123; this.count+&#x3D;1; newTitle&#x3D;this.title+this.count;&#x2F;&#x2F;对title赋新值 this.$emit(&#39;update:childTitle&#39;,newTitle) &#125; &#125;, data()&#123; return&#123; count:0 &#125; &#125;,&#125;)const app&#x3D;new Vue(&#123; el:&#39;#example&#39;, data:&#123; parentTitle:&quot;我是父级title&quot;, &#125;, &#x2F;&#x2F;父组件可以监听那个事件并根据需要更新一个本地的数据property template: &#96; &lt;div&gt; 我是父级节点 &lt;text-document v-bind:title&#x3D;&quot;parentTitle&quot; v-on:update:title&#x3D;&quot;parentTitle&#x3D;$event&quot; &gt;&lt;&#x2F;text-document&gt; &#123;&#123;parentTitle&#125;&#125; &lt;&#x2F;div&gt; &#96; &#x2F;&#x2F;上述代码可用.sync修饰符缩写为 &#x2F;&#x2F;&lt;text-document :title&#x3D;&quot;parentTitle&quot; :title.sync&#x3D;&quot;parentTitle&quot;&gt;&lt;&#x2F;text-document&gt; &#125;)&lt;&#x2F;script&gt; 注意带有.sync修饰符的v-bind不能和表达式一起使用（如v-bind:title.sync=\"doc.title+'!'\"是无效的），只能提供想绑定的property名，如v-model。 当用一个对象同时设置多个prop时，也可以将.sync修饰符和v-bind配合使用： 1&lt;text-document v-bind.sync&#x3D;&quot;doc&quot;&gt;&lt;&#x2F;text-document&gt; 这样会把doc对象中的每个property都作为一个独立的prop传进去，然后各自添加用于更新的v-on监听器。 注意：将v-bind.sync用在一个字面量的对象上（如整数、浮点数及字符串等）时是无法正常工作的，如v-bind.sync=\"{title:doc.title}\"。 插槽 在Vue2.6.0版本中引入了具名插槽和作用域插槽的因语法v-slot指令，它取代了slot和slot-scope这两个已被废除但未被移除的attribute。 插槽内容 Vue实现了一套内容分发的API，其将&lt;slot&gt;元素作为承载分发内容的出口。 它允许像这样合成组件： 123&lt;navigation-link url=\"/profile\"&gt; Your Profile&lt;/navigation-link&gt; 其中，&lt;/navigation-link&gt;的模板如下： 123&lt;a v-bind:href=\"url\" class=\"nav-link\"&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/a&gt; 当组件渲染时，&lt;slot&gt;&lt;/slot&gt;将会被替换为Your Profile的内容。插槽内可以包含任何模板代码，包括HTML或是它的组件： 1234567891011&lt;navigation-link url&#x3D;&quot;&#x2F;profile&quot;&gt; &lt;!-- 添加一个Font Awesome图标 --&gt; &lt;span class&#x3D;&quot;fa fa-user&quot;&gt;&lt;&#x2F;span&gt; Your Profile&lt;&#x2F;navigation-link&gt; &lt;navigation-link url&#x3D;&quot;&#x2F;profile&quot;&gt; &lt;!-- 添加一个图标的组件 --&gt; &lt;font-awesome-icon name&#x3D;&quot;user&quot;&gt;&lt;&#x2F;font-awesome-icon&gt; Your Profile&lt;&#x2F;navigation-link&gt; 若&lt;navigation-link&gt;的template中没有包含一个&lt;slot&gt;元素，则该组件起始标签和结束标签之间的内容都会被抛弃。 编译作用域 当想在一个插槽中使用数据时，该插槽跟模板其他地方一样可以访问相同的实例property，而不能访问&lt;navigation-link&gt;的作用域： 1234567&lt;navigation-link url&#x3D;&quot;&#x2F;profile&quot;&gt; &lt;!-- user.name的数据能正常访问 --&gt; Logged in as &#123;&#123;user.name&#125;&#125; &lt;!-- 这里的url的值是undefined --&gt; &lt;!-- 因为该插槽的内容是传递给&lt;navigation-link&gt;的而不是在其组件内部定义的 --&gt; Clicking here will send you to:&#123;&#123;url&#125;&#125;&lt;&#x2F;navigation-link&gt; 父级模板里的所有内容都是在父级作用域中编译的，子模板里的所有内容都是在子作用域中编译的。 后备内容 为一个插槽设置具体的后备内容（即默认内容）是很有必要的，它只会在没有提供内容的时候被渲染。 1234&lt;button type&#x3D;&quot;submit&quot;&gt; &lt;!-- button绝大多数都渲染文本Submit --&gt; &lt;slot&gt;Submit&lt;&#x2F;slot&gt;&lt;&#x2F;button&gt; 此时若在父级组件中使用&lt;submit-button&gt;且不提供任何插槽内容时，后备内容“Submit”将会被渲染；若提供内容时，在这个提供的内容将会取代后备内容被渲染 具名插槽 有时在一个模板里需要多个插槽时，可以使用&lt;slot&gt;元素中的name attribute，其可以用来定义额外的插槽： 123456789101112&lt;div class&#x3D;&quot;container&quot;&gt; &lt;header&gt; &lt;slot name&#x3D;&quot;header&quot;&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;header&gt; &lt;main&gt; &lt;!-- 不带name的&lt;slot&gt;，会默认带有一个隐含的名字default --&gt; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;main&gt; &lt;footer&gt; &lt;slot name&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;footer&gt;&lt;&#x2F;div&gt; 在向具名插槽提供内容时，可以在一个&lt;template&gt;元素上使用v-slot指令，并以v-slot参数的形式提供其名称： 123456789101112&lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;&#x2F;h1&gt; &lt;&#x2F;template&gt; &lt;p&gt;A paragraph for the main content.&lt;&#x2F;p&gt; &lt;p&gt;And another one.&lt;&#x2F;p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Here&#39;s some contact info&lt;&#x2F;p&gt; &lt;&#x2F;template&gt;&lt;&#x2F;base-layout&gt; 现在&lt;template&gt;元素中的所有内容都将会被传入相应的插槽，任何没有被包裹在带有v-slot的&lt;template&gt;中的内容都会被视为默认插槽的内容。 即上述代码等价于： 1234567891011121314&lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;&#x2F;h1&gt; &lt;&#x2F;template&gt; &lt;template v-slot:default&gt; &lt;p&gt;A paragraph for the main content.&lt;&#x2F;p&gt; &lt;p&gt;And another one.&lt;&#x2F;p&gt; &lt;&#x2F;template&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Here&#39;s some contact info&lt;&#x2F;p&gt; &lt;&#x2F;template&gt;&lt;&#x2F;base-layout&gt; 注意：v-slot只能添加在&lt;template&gt;上。 作用域插槽 有时会让插槽内容能够访问子组件中才有的数据。如这里有个组件&lt;current-user&gt;： 123&lt;span&gt; &lt;slot&gt;&#123;&#123;user.lastName&#125;&#125;&lt;&#x2F;slot&gt;&lt;&#x2F;span&gt; 若想换掉备用内容，用名来显示，直接将组件中的user.lastName换成user.firstName是不行的： 123&lt;current-user&gt; &#123;&#123;user.firstName&#125;&#125;&lt;&#x2F;current-user&gt; 由于只有&lt;current-user&gt;组件可以访问到user，而所提供的内容是在父级渲染的。因此为了让user在父级的插槽内容中可用，将user作为&lt;slot&gt;元素的一个attribute绑定上去： 123&lt;span&gt; &lt;slot v-bind:user&#x3D;&quot;user&quot;&gt;&#123;&#123;user.lastName&#125;&#125;&lt;&#x2F;slot&gt;&lt;&#x2F;span&gt; 绑定在&lt;slot&gt;元素上的attribute被称为插槽prop。在父级作用域中，可以使用带值的v-slot来定义所提供插槽prop的名字： 123456&lt;current-user&gt; &lt;!-- slotProps为包含所有插槽prop的对象 --&gt; &lt;template v-slot:default&#x3D;&quot;slotProps&quot;&gt; &#123;&#123;slotProps.user.firstName&#125;&#125; &lt;&#x2F;template&gt; &lt;&#x2F;current-user&gt; 独占默认插槽的缩写语法 当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。此时可以把v-slot直接用在组件上： 123&lt;current-user v-slot:default&#x3D;&quot;slotProps&quot;&gt; &#123;&#123;slotProps.user.firstName&#125;&#125; &lt;&#x2F;current-user&gt; 由于不带参数的v-slot被假定为对应默认的插槽，因此还有更简化的写法： 123&lt;current-user v-slot&#x3D;&quot;slotProps&quot;&gt; &#123;&#123;slotProps.user.firstName&#125;&#125; &lt;&#x2F;current-user&gt; 默认插槽的缩写写法不能和具名插槽混用，这会导致作用域不明确。 只要出现多个插槽，则始终要为所有的插槽使用完整的基于&lt;template&gt;的语法： 123456789&lt;current-user&gt; &lt;template v-slot:default&#x3D;&quot;slotProps&quot;&gt; &#123;&#123;slotProps.user.firstName&#125;&#125; &lt;&#x2F;template&gt; &lt;template v-slot:other&#x3D;&quot;otherSlotProps&quot;&gt; ... &lt;&#x2F;template&gt; &lt;&#x2F;current-user&gt; 解析插槽Prop 作用域插槽的内部工作原理是将插槽内容包裹在一个拥有单个参数的函数里： 123function(slotProps)&#123; //插槽内容&#125; 这意味着v-slot的值实际上可以是任何能够作为函数定义中参数的JavaScript表达式。因此在支持的环境下（单文件组件或现代浏览器），也可以使用ES2015解构来传入具体的插槽prop： 123&lt;current-user v-slot&#x3D;&quot;&#123;user&#125;&quot;&gt; &#123;&#123;user.firstName&#125;&#125; &lt;&#x2F;current-user&gt; 这样可以在该插槽提供了多个prop时让代码更简洁。它同样开启了prop重命名等功能，如把user重命名为person： 123&lt;current-user v-slot&#x3D;&quot;&#123;user:person&#125;&quot;&gt; &#123;&#123;person.firstName&#125;&#125; &lt;&#x2F;current-user&gt; 还可以定义后备内容，用于插槽prop是undefined的情形： 123&lt;current-user v-slot&#x3D;&quot;&#123;user&#x3D;&#123;firstName:&#39;Guest&#39;&#125;&#125;&quot;&gt; &#123;&#123;user.firstName&#125;&#125; &lt;&#x2F;current-user&gt; 动态插槽名 动态指令参数也可以用在v-slot上，来定义动态的插槽名： 12345&lt;base-layout&gt; &lt;template v-slot:[dynamicSlotName]&gt; ... &lt;&#x2F;template&gt;&lt;&#x2F;base-layout&gt; 具名插槽的缩写 与v-on和v-bind一样，v-slot也有缩写，即把参数之前的所有内容（v-slot:）替换为字符#： 123456789101112&lt;base-layout&gt; &lt;template #header&gt; &lt;h1&gt;Here might be a page title&lt;&#x2F;h1&gt; &lt;&#x2F;template&gt; &lt;p&gt;A paragraph for the main content.&lt;&#x2F;p&gt; &lt;p&gt;And another one.&lt;&#x2F;p&gt; &lt;template #footer&gt; &lt;p&gt;Here&#39;s some contact info&lt;&#x2F;p&gt; &lt;&#x2F;template&gt;&lt;&#x2F;base-layout&gt; 与其他指令相同，该缩写只在其有参数时才可用。若希望无参数时也能使用缩写的话，就必须始终明确插槽名： 123&lt;current-user #default&#x3D;&quot;&#123;user&#125;&quot;&gt; &#123;&#123;user.firstName&#125;&#125; &lt;&#x2F;current-user&gt; 其他实例 插槽prop允许将插槽转换为可复用的模板，这些模板可以基于输入的prop渲染出不同的内容。这在设计封装数据逻辑的同时允许父级组件自定义部分布局的可复用组件是最有用的。 如要实现一个&lt;todo-list&gt;组件，它是一个列表且包含布局和过滤逻辑： 12345678&lt;ul&gt; &lt;li v-for&#x3D;&quot;todo in filteredTodos&quot; v-bind:key&#x3D;&quot;todo.id&quot; &gt; &#123;&#123;todo.text&#125;&#125; &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 可以考虑将每个todo作为父级组件的插槽，以此通过父级组件对其进行控制，然后将todo作为一个插槽prop进行绑定： 1234567891011&lt;ul&gt; &lt;li v-for&#x3D;&quot;todo in filteredTodos&quot; v-bind:key&#x3D;&quot;todo.id&quot; &gt; &lt;!-- 为每个todo准备了插槽，将todo对象作为一个插槽的prop传入 --&gt; &lt;slot name&#x3D;&quot;todo&quot; v-bind:todo&#x3D;&quot;todo&quot;&gt; &#123;&#123;todo.text&#125;&#125; &lt;&#x2F;slot&gt; &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 现在使用&lt;itodo-list&gt;组件时，可以选择为todo定义一个不一样的&lt;template&gt;作为替代方案，并且可以从子组件中获取数据： 123456&lt;todo-list v-bind:todo&#x3D;&quot;todos&quot;&gt; &lt;template v-slot:todo&#x3D;&quot;&#123;todo&#125;&quot;&gt; &lt;span v-if&#x3D;&quot;todo.isComplete&quot;&gt;&lt;&#x2F;span&gt; &#123;&#123;todo.text&#125;&#125; &lt;&#x2F;template&gt;&lt;&#x2F;todo-list&gt;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"前端框架","slug":"前端框架","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://tangmenjue.top/tags/Vue-js/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Vue.js实战之todolist待办项目","slug":"Vue.js实战之todolist待办项目","date":"2022-11-05T09:33:51.000Z","updated":"2022-11-14T07:41:37.000Z","comments":true,"path":"2022/11/05/Vue.js实战之todolist待办项目/","link":"","permalink":"http://tangmenjue.top/2022/11/05/Vue.js%E5%AE%9E%E6%88%98%E4%B9%8Btodolist%E5%BE%85%E5%8A%9E%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"初始化一个新项目 要初始化一个新项目，创建一个文件夹test作为项目目录，打开一个终端将切换路径到test，运行代码： 12345678910PS C:\\Users\\Administrator\\Desktop\\test&gt; vue create test运行结果如下： Your connection to the default yarn registry seems to be slow. Use https://registry.npmmirror.com for faster installation? (Y/n)输入Y回车 Vue CLI v5.0.8? Please pick a preset: (Use arrow keys)&gt; Default ([Vue 3] babel, eslint) Default ([Vue 2] babel, eslint) Manually select features 使用方向键选择“ Manually select features”（手动选择）选项后按下键盘上的回车键继续。 12345678910111213Vue CLI v5.0.8? Please pick a preset: Manually select features? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection, and&lt;enter&gt; to proceed)&gt;(*) Babel ( ) TypeScript ( ) Progressive Web App (PWA) Support ( ) Router ( ) Vuex ( ) CSS Pre-processors (*) Linter / Formatter ( ) Unit Testing ( ) E2E Testing 可以看到第一个菜单允许选择想要包含在项目中的功能，确保“Babel”和“Linter / Formatter”这两项是被选中的。若它们没有被选中，使用方向键切换，按空格键来选中它们，若它们被选中，按下回车键继续。 123456Vue CLI v5.0.8? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Linter? Choose a version of Vue.js that you want to start the project with (Use arrow keys)&gt; 3.x 2.x 接下来为选择Vue.js版本，使用方向键选中3.x选项后按下键盘上的回车键继续。 123456789Vue CLI v5.0.8? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Linter? Choose a version of Vue.js that you want to start the project with 3.x? Pick a linter / formatter config: (Use arrow keys)&gt; ESLint with error prevention only ESLint + Airbnb config ESLint + Standard config ESLint + Prettier 接下来为linter / formatter选择一个配置，使用方向键选中\"ESLint with error prevention only\"选项后按下键盘上的回车键继续。这样可以辅助我们捕获常见的错误。 123456789Vue CLI v5.0.8? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Linter? Choose a version of Vue.js that you want to start the project with 3.x? Pick a linter / formatter config: Basic? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection, and &lt;enter&gt; toproceed)&gt;(*) Lint on save ( ) Lint and fix on commit 接下来选择需要哪种自动化的Lint，使用方向键选中\"Lint on save\"选项后按下键盘上的回车键继续。 123456789Vue CLI v5.0.8? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Linter? Choose a version of Vue.js that you want to start the project with 3.x? Pick a linter / formatter config: Basic? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection, and &lt;enter&gt; toproceed)&gt;(*) Lint on save ( ) Lint and fix on commit 接下来选择把配置文件放在哪里。\"In dedicated config files\"这个选项会把配置文件单独放在一个文件里，另一个选项\"In package.json\"会把配置文件放仅项目文件package.json里。选择\"In dedicated config files\"选项后按下键盘上的回车键继续。 123456789Vue CLI v5.0.8? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Linter? Choose a version of Vue.js that you want to start the project with 3.x? Pick a linter / formatter config: Basic? Pick additional lint features: Lint on save? Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys)&gt; In dedicated config files In package.json 最后选择是否把这次的选择作为未来的预设配置。输入y后按下键盘上的回车键后输入保存的配置名称。然后脚手架工具就开始构建项目，并且安装所需的依赖。 12345678Vue CLI v5.0.8? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Linter? Choose a version of Vue.js that you want to start the project with 3.x? Pick a linter / formatter config: Basic? Pick additional lint features: Lint on save? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files? Save this as a preset for future projects? (y/N) 项目结构 如果前面的步骤都顺利执行的话，脚手架工具已经在项目中创建了一系列的文件和目录，其项目结构如下： eslintrc.js：是eslint的配置文件，可以通过它来管理校验规则 babel.config.js：是Babel的配置文件，可以在开发中使用JavaScript的新特性，并且将其转换为在生成环境中可以跨浏览器运行的旧语法代码，也可以在这里配置额外的babel插件 .browserslistrc：是Browserslist的配置文件，可以通过它来控制需要对哪些浏览器进行支持和优化 public：该目录包含一些在Webpack编译过程中没有架构处理过的文件（index.html除外） favicon.ico：项目的图标，当前是一个Vue的logo index.html：应用模板文件，Vue应用会通过这个HTML页面来运行，也可以通过lodash这种模板语法在这个文件里插值 src：Vue应用的核心代码目录 main.js：应用的入口文件。目前它会初始化Vue应用并指定将应用挂载到index.html文件中的哪个HTML元素上。通常还会做一些注册全局组件或者添加额外的Vue库的操作 App.vue：Vue应用的根节点组件 components：用来存放自定义组件的目录，当前里面会有一个示例组件 assets：用来存放如CSS、图片这类的静态资源，可以用webpack来操作和处理 根据创建项目时的配置项不同，可能会有一些其他的预设目录，比如选择了路由配置，会看到一个views文件夹。 .vue文件（单文件组件） 组件是构建Vue应用中非常重要的一部分，其可以把一个很大的应用程序拆分为独立创建和管理的不相干区块，然后彼此按需传递数据。 在其他框架鼓励把模板、逻辑和样式的代码区分成不同文件时，Vue提倡使用单文件组件，把模板、相关脚本和CSS整合到一起放在.vue结尾的单文件中。这些文件最终会通过JS打包工具（如Webpack）处理。 使用Vue CLI创建的项目被配置为开箱即用的情况下，可以在CLI创建项目中的src文件夹里看到第一个.vue文件：App.vue。 App.vue 打开App.vue文件，可以看到有&lt;template&gt;、&lt;script&gt;和&lt;style&gt;三部分组成，分别包含了组件的模板、脚本和样式相关的内容。所有单文件组件内的结构都是这种类似的结构。 &lt;tamplate&gt;包含了所有的标记结构和组件的展示逻辑。tamplate可以包含任何合法的HTML以及Vue特点的语法。如通过设置&lt;tamplate lang=\"pug\"&gt;可以使用Pug模板来替代标准HTML。 &lt;script&gt;包含组件中所有的非显示逻辑，&lt;script&gt;标签默认导出一个JS对象。该对象用于在本地注册组件、定义属性、处理本地状态、定义方法等地方。在构建阶段这个包含&lt;tamplate&gt;的对象会被处理和转换成为一个有render()函数的Vue组件。 对于App.vue，默认导出将组件的名称设置为app，并通过将HelloWorld组件添加到components属性中来注册它。以这种方式注册组件时，意味着就是在本地注册，本地注册的组件只能在注册它们的组件内部使用，因此需要将其导入并注册到使用它们的每个组件文件中。 1234567891011&lt;script&gt;import HelloWorld form './components/Helloworld.vue' export default&#123; name:'app', components:&#123; //在这里本地注册组件 HelloWorld&#125;&#125;&lt;/script&gt; 若想要使用TypeScript语法，可以将&lt;script&gt;标签的lang属性设置为&lt;script lang='ts'&gt;。 组件的CSS应写在&lt;style&gt;标签里，若添加了&lt;scoped&gt;属性（如&lt;style scoped&gt;)，Vue会把样式的范围显示在单文件组件的内容里。设置类似于CSS-in-JS的解决方案，只不过是允许书写纯粹的CSS。 注意：若通过CLI创建项目是选择了CSS预处理器，则可以将lang属性添加到&lt;style&gt;标签中，以便Webpack可以在构建时处理内容。如&lt;style lang=\"scss\"&gt;将允许在样式信息中使用SCSS语法。 本地运行程序 Vue CLI带有内置的开发服务器，因此可以无需自己配置服务器便可在本地运行并测试应用程序。CLI会以npm脚本的形式将serve命令添加到项目的package.json文件中，因此可以轻松地运行它。 在终端中，切换到项目所在的路径，输入npm run serve或者yarn run serve即可运行服务器，此时的终端应输出以下类似的内容： 12345678910111213141516171819202122232425262728293031PS C:\\Users\\Administrator\\Desktop\\test\\test&gt; npm run serve&gt; test@0.1.0 serve&gt; vue-cli-service serve INFO Starting development server... DONE Compiled successfully in 1995ms 14:28:36 App running at: - Local: http://localhost:8080/ - Network: http://10.17.212.3:8080/ Note that the development build is not optimized. To create a production build, run yarn build. WAIT Compiling... 14:28:36Compiling... DONE Compiled successfully in 70ms 14:28:36 App running at: - Local: http://localhost:8080/ - Network: http://10.17.212.3:8080/ 若在浏览器中打开http://localhost:8080/或http://10.17.212.3:8080/，便可以看到应用程序。当前它应该包含欢迎信息、Vue文档的链接、使用CLI初始化应用程序时添加的插件链接，以及指向Vue社区和生态系统的其他有用链接。 改动应用 对应用做出第一步改动，删除Vue logo。打开App.vue文件，在template部分删除&lt;img&gt;元素 1&lt;img alt=\"Vue logo\" src=\"./assets/logo.png\"&gt; 服务器仍在正常运行时，可以看到logo是即时从之前渲染的页面中消失。接下来再把HelloWorld组件也删掉。 首先删除下面这一行： 1import HelloWorld from './components/HelloWorld.vue' 若这时候保存App.vue文件，渲染好的应用会因为找不到HelloWorld组件而抛出一个错误。 在&lt;script&gt;中将引入和注册组件的那几行删掉： 123components: &#123; HelloWorld&#125; 此时渲染好的应用不再显示错误了，只有一个空页面。 接下来来创建一个任务清单的应用。打开App.vue文件，将下列代码删除： 1&lt;HelloWorld msg=\"Welcome to Your Vue.js App\"/&gt; 编写代码如下，在&lt;div id=\"app\"&gt;中新增一个&lt;h1&gt;标签，并将标题文案设为\"To-Do List\"： 12345&lt;template&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;h1&gt;To-Do List&lt;&#x2F;h1&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 此时服务器会展示To-Do List标题。 小结 学习至此，我们已经为示例应用程序创建了一些脚手架，使其可以运行，检查并进行了一些初步更改。后续将进一步研究并构建示例应用程序。使之允许存储项目列表，完成后将其选中，并按所有、已完成和未完成待办事项来过滤。 创建第一个Vue组件 Vue组件是由管理应用程序数据的JavaScript对象和映射到基础DOM结构的基于HTML语法的模板语法组成的。接下来要创建一个组件来表示待办事项列表中的每一个项目。 创建一个ToDoItem组件 ToDoItem组件将用来显示单一的待办事项，用它来建立待办事项列表。 在test/srx/components目录下，创建一个ToDoItem.vue的新文件并打开 在文件顶部添加&lt;template&gt;&lt;/template&gt;部分来创建组件中的模板部分 在模板部分下面创建一个&lt;script&gt;&lt;/script&gt;部分。在&lt;script&gt;标签内，添加一个默认导出对象export default{}作为组件对象: 1234&lt;template&gt; &lt;&#x2F;template&gt;&lt;script&gt; export default&#123;&#125;;&lt;&#x2F;script&gt; 现在加上为ToDoItem添加实际内容。Vue模板目前只允许一个根元素--一个元素需要包裹模板内的所有内容，因此要为该根元素使用一个&lt;div&gt;。 在组件模板中添加一个空的&lt;div&gt; 在&lt;div&gt;里添加一个checkbox和一个对应的label。给复选框添加一个id，并添加一个for属性，将复选框映射到标签上。 123456&lt;template&gt; &lt;div&gt; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;todo-item&quot; checked&#x3D;&quot;false&quot; &#x2F;&gt; &lt;label for&#x3D;&quot;todo-item&quot;&gt;My Todo Item&lt;&#x2F;label&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 在应用程序中使用TodoItem组件 ​","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"前端框架","slug":"前端框架","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://tangmenjue.top/tags/Vue-js/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端框架之Vue.js（三）","slug":"前端框架之Vue.js（三）","date":"2022-11-04T09:53:16.000Z","updated":"2022-11-10T15:51:46.894Z","comments":true,"path":"2022/11/04/前端框架之Vue.js（三）/","link":"","permalink":"http://tangmenjue.top/2022/11/04/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8BVue.js%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"Vue.js基础 列表渲染 用v-for把一个数组对应为一组元素 基于一个数组来渲染列表可以使用v-for指令。v-for指令需要通过item in items形式的特殊语法，其中items是源数据数组，而item是被迭代的数组元素的别名。 123456789101112131415161718&lt;body&gt;&lt;ul id&#x3D;&quot;example-1&quot;&gt; &lt;li v-for&#x3D;&quot;item in items&quot; :key&#x3D;&quot;item.message&quot;&gt; &#123;&#123;item.message&#125;&#125; &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; &lt;&#x2F;body&gt;&lt;script&gt; var example1&#x3D;new Vue(&#123; el:&#39;#example-1&#39;, data:&#123; items:[ &#123;message:&#39;First&#39;&#125;, &#123;message:&#39;Second&#39;&#125; ] &#125; &#125;)&lt;&#x2F;script&gt; 运行结果如下： 在v=for块中，可以访问所有父作用域的property。v-for还支持一个可选的第二个参数，即当前项的索引。 123456789101112131415161718&lt;ul id&#x3D;&quot;example-2&quot;&gt; &lt;li v-for&#x3D;&quot;(item,index) in items&quot;&gt; &#123;&#123;parentMessage&#125;&#125;-&#123;&#123;index&#125;&#125;-&#123;&#123;item.message&#125;&#125; &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;body&gt;&lt;script&gt; var example2&#x3D;new Vue(&#123; el:&#39;#example-2&#39;, data:&#123; parentMessage:&#39;Parent&#39;, items:[ &#123;message:&#39;First&#39;&#125;, &#123;message:&#39;Second&#39;&#125; ] &#125; &#125;)&lt;&#x2F;script&gt; 运行结果如下： 其中，也可以用of替代in作为分隔符，if更接近Javascript迭代器的语法： 1&lt;div v-for=\"item of items\"&gt;&lt;/div&gt; 在v-for里使用对象 遍历一个对象的property可以用v-for指令： 12345678910111213141516171819&lt;body&gt;&lt;ul id&#x3D;&quot;v-for-object&quot; class&#x3D;&quot;demo&quot;&gt; &lt;li v-for&#x3D;&quot;value in object&quot;&gt; &#123;&#123;value&#125;&#125; &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;body&gt;&lt;script&gt; new Vue(&#123; el:&#39;#v-for-object&#39;, data:&#123; object:&#123; title:&#39;How to do lists in Vue&#39;, author:&#39;ZhangSan&#39;, publicshedAt:&#39;2022-11-04&#39; &#125; &#125; &#125;)&lt;&#x2F;script&gt; 运行结果如下： 也可以提供第二个参数为property名称（即键名）： 1234567&lt;body&gt;&lt;ul id&#x3D;&quot;v-for-object&quot; class&#x3D;&quot;demo&quot;&gt; &lt;li v-for&#x3D;&quot;(value,name) in object&quot;&gt; &#123;&#123;name&#125;&#125;:&#123;&#123;value&#125;&#125; &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;body&gt; 运行结果如下： 还可以用第三个参数作为索引： 1234567&lt;body&gt;&lt;ul id&#x3D;&quot;v-for-object&quot; class&#x3D;&quot;demo&quot;&gt; &lt;li v-for&#x3D;&quot;(value,name,index) in object&quot;&gt; &#123;&#123;index&#125;&#125;:&#123;&#123;name&#125;&#125;:&#123;&#123;value&#125;&#125; &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;body&gt; 运行结果如下： 在遍历对象时，会按Object.keys()的结果遍历，但不能保证它的结果在不同的JavaScript引擎下都一致。 维护状态 当Vue正在更新使用v-for渲染的元素列表时，默认使用“就地更新”的策略。若数据项的顺序被改变，Vue将不会移动DOM元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个默认模式只适用于不依赖子组件状态或临时DOM状态的列表渲染输出（如表单输入值）。 为了给Vue一个提示以便它能够跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一的key attribute： 123&lt;div v-for=\"item in items\" v-bind:key=\"item.id\"&gt; &lt;!--内容--&gt;&lt;/div&gt; 尽可能在使用v-for时提供key attribute，除非遍历输出的DOM内容非常简单，或是刻意依赖默认行为以获取性能上的提升。由于它是Vue识别节点的一个通用机制，key并不仅与v-for特别关联。 不要使用对象或数组之类的非基本类型值作为v-for的key，要用字符串或数值类型的值。 数组更新检测 变更方法 Vue将被侦听的数组的变更方法进行了包裹，因此它们也将会触发视图更新。 这些被包裹过的方法有： push() pop() shift() unshift() splice() sort() reverse() 替换数组 变更方法会变更调用了这些方法的原始数组。相比之下，也有非变更方法。如filter()、concat()和slice()。它们不会变更原始数组，而是总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组。 123example.items=example.items.filter(function (item)&#123; return item.message.match(/Foo/)&#125;) 注意：由于JavaScript的限制，Vue不能检测数组和对象的变化。 显示过滤/排序后的结果 若要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据，可以通过创建一个计算属性来返回过滤或排序后的数组： 1234567891011121314151617181920&lt;body&gt;&lt;div id&#x3D;&quot;test&quot;&gt; &lt;li v-for&#x3D;&quot;n in evenNumbers&quot;&gt;&#123;&#123;n&#125;&#125;&lt;&#x2F;li&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; new Vue(&#123; el:&#39;#test&#39;, data:&#123; numbers:[1,2,3,4,5] &#125;, computed:&#123; evenNumbers:function()&#123; return this.numbers.filter(function (number)&#123; return number %2&#x3D;&#x3D;&#x3D;0 &#125;) &#125; &#125; &#125;)&lt;&#x2F;script&gt; 注意：v-for指令不能在根节点使用！ 在嵌套v-for循环中不适应计算属性的情况下，可以使用一个方法： 12345678910111213141516171819202122&lt;body&gt;&lt;div id&#x3D;&quot;test&quot;&gt; &lt;ul v-for&#x3D;&quot;set in sets&quot;&gt; &lt;li v-for&#x3D;&quot;n in even(set)&quot;&gt;&#123;&#123;n&#125;&#125;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; new Vue(&#123; el:&#39;#test&#39;, data:&#123; sets:[[1,2,3,4,5],[6,7,8,9,10]] &#125;, methods:&#123; even:function(numbers)&#123; return numbers.filter(function (number)&#123; return number %2&#x3D;&#x3D;&#x3D;0 &#125;) &#125; &#125; &#125;)&lt;&#x2F;script&gt; 在v-for里使用值范围 v-for也可以接收整数。在这种情况下，它会把模板重复对应次数： 123456789&lt;div id&#x3D;&quot;test&quot;&gt; &lt;span v-for&#x3D;&quot;n in 10&quot;&gt;&#123;&#123;n&#125;&#125;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; new Vue(&#123; el:&#39;#test&#39; &#125;)&lt;&#x2F;script&gt; 在&lt;template&gt;上是使用v-for 与v-if类似，也可以利用带有v-for的&lt;template&gt;来循环渲染一段包含多个元素的内容： 123456&lt;ul&gt; &lt;template v-for=\"item in items\"&gt; &lt;li&gt;&#123;&#123;item.msg&#125;&#125;&lt;/li&gt; &lt;li class=\"divider\" role=\"presentation\"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 在组件上使用v-for 在自定义组件上，可以像在任何普通元素上一样使用v-for： 1&lt;my-component v-for=\"item in items\" :key=\"item.id\"&gt;&lt;/my-component&gt; 在Vue2.2.0+的版本里，在组件上使用v-for时，key是必须的。 由于组件有自己独立的作用域，任何数据都不会被自动传递到组件里。使用prop把迭代数据传递到组件里： 1234&lt;my-component v-for=\"(item,index) in items\" v-bind:item=\"item\" v-bind:index=\"index\" v-bind:key=\"item.id\"&gt;&lt;/my-component&gt; 若是自动将item注入到组件里，会使得组件与v-for的运行紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。 下面是个简单的todo列表的完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;todo-list-example&quot;&gt; &lt;form v-on:submit.prevent&#x3D;&quot;addNewTodo&quot;&gt; &lt;label for&#x3D;&quot;new-todo&quot;&gt;Add a todo&lt;&#x2F;label&gt; &lt;input v-model&#x3D;&quot;newTodoText&quot; id&#x3D;&quot;new-todo&quot; placeholder&#x3D;&quot;E.g. Feed the cat&quot;&gt; &lt;button&gt;Add&lt;&#x2F;button&gt; &lt;&#x2F;form&gt; &lt;ul&gt; &lt;!--这里的is&#x3D;&quot;todo-item&quot; attribute在使用DOM模板时是十分必要的。 在&lt;ul&gt;元素内只有&lt;li&gt;元素会被看作有效内容。 这样做实现的效果与&lt;todo-item&gt;相同，但可以避开一些潜在的浏览器解析错误--&gt; &lt;li is&#x3D;&quot;todo-item&quot; v-for&#x3D;&quot;(todo,index) in todos&quot; v-bind:key&#x3D;&quot;todo.id&quot; v-bind:title&#x3D;&quot;todo.title&quot; v-on:remove&#x3D;&quot;todos.splice(index,1)&quot;&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; Vue.component(&#39;todo-item&#39;,&#123; template:&#39;\\ &lt;li&gt;\\ &#123;&#123; title &#125;&#125;\\ &lt;button v-on:click&#x3D;&quot;$emit(\\&#39;remove\\&#39;)&quot;&gt;Remove&lt;&#x2F;button&gt;\\ &lt;&#x2F;li&gt;\\ &#39;, props:[&#39;title&#39;] &#125;) new Vue(&#123; el:&#39;#todo-list-example&#39;, data:&#123; newTodoText:&#39;&#39;, todos:[ &#123; id:1, title:&#39;Do the dishes&#39;, &#125;, &#123; id:2, title:&#39;Take out the trash&#39;, &#125;, &#123; id:3, title:&#39;Mow the lawn&#39; &#125; ], nextTodoId:4 &#125;, methods:&#123; addNewTodo:function()&#123; this.todos.push(&#123; id:this.nextTodoId++, title:this.newTodoText &#125;) this.newTodoText&#x3D;&#39;&#39; &#125; &#125; &#125;)&lt;&#x2F;script&gt;&lt;&#x2F;html&gt; 运行结果如下： 事件处理 使用v-on监听事件 可以用v-on指令监听DOM事件，并在触发时运行一些JavaScriptdiamond： 1234567891011121314&lt;body&gt;&lt;div id&#x3D;&quot;example-1&quot;&gt; &lt;button v-on:click&#x3D;&quot;counter+&#x3D;1&quot;&gt;Add 1&lt;&#x2F;button&gt; &lt;p&gt;The button above has been clicked &#123;&#123;counter&#125;&#125; times.&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;var example1&#x3D;new Vue(&#123; el:&#39;#example-1&#39;, data:&#123; counter:0 &#125;&#125;)&lt;&#x2F;script&gt; 运行结果如下： 使用v-on指令有几个好处： 看一眼HTML模板就可以定位在JavaScript代码里对应的方法 由于无需在JavaScript里手动绑定事件，因此所编写的ViewModel代码是纯粹的逻辑，与DOM完全解耦，更易于测试 当一个ViewModel被销毁时，所有的事件处理器都会自动被删除，无需额外清理。 事件处理方法 由于许多事件处理逻辑会更为复杂，因此直接把JavaScript代码写在v-on指令中是不可行的，v-on还可以接收一个需要调用的方法名称： 12345678910111213141516171819202122232425&lt;body&gt;&lt;div id&#x3D;&quot;example-2&quot;&gt; &lt;!--greet是定义的方法名--&gt; &lt;button v-on:click&#x3D;&quot;greet&quot;&gt;Greet&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;var example2&#x3D;new Vue(&#123; el:&#39;#example-2&#39;, data:&#123; name:&#39;Vue.js&#39; &#125;, &#x2F;&#x2F;在methods对象中定义方法 methods:&#123; greet:function(event)&#123; &#x2F;&#x2F;this在方法里指向当前Vue示例 alert(&#39;Hello &#39;+this.name+&#39;!&#39;) &#x2F;&#x2F;event是原生DOM事件 if(event)&#123; alert(event.target.tagName) &#125; &#125; &#125;&#125;)&lt;&#x2F;script&gt; 运行结果如下： 与此同时，也可以在F12的JavaScript控制台里使用example2.greet()直接调用方法。 内联处理器中的方法 除了直接绑定到一个方法，也可以在内联JavaScript语句中调用方法： 12345678910111213141516&lt;body&gt;&lt;div id&#x3D;&quot;example-3&quot;&gt; &lt;button v-on:click&#x3D;&quot;say(&#39;hi&#39;)&quot;&gt;Say hi&lt;&#x2F;button&gt; &lt;button v-on:click&#x3D;&quot;say(&#39;what&#39;)&quot;&gt;Say what&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;new Vue(&#123; el:&#39;#example-3&#39;, methods:&#123; say:function(message)&#123; alert(message) &#125; &#125;&#125;)&lt;&#x2F;script&gt; 运行结果如下： 若需要在内联语句处理器中访问原始的DOM事件，可以使用特殊变量$event把它传入方法中： 1234567891011121314151617181920&lt;body&gt;&lt;div id&#x3D;&quot;example-3&quot;&gt; &lt;button v-on:click&#x3D;&quot;warn(&#39;Form cannot be submitted yet.&#39;,$event)&quot;&gt; Submit&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;new Vue(&#123; el:&#39;#example-3&#39;, methods:&#123; warn:function(message, event)&#123; &#x2F;&#x2F;现在可以访问原生事件对象 if(event)&#123; event.preventDefault() &#125; alert(message) &#125; &#125;&#125;)&lt;&#x2F;script&gt; 运行结果如下： 事件修饰符 比在事件处理程序中调用event.preventDefault()或event.stopPropagation()更好的方式是：方法只有纯粹的数据逻辑，而不是去处理DOM事件细节。 Vue.js为v-on提供了事件修饰符，修饰符由点开头的指令后缀来表示： .stop：阻止事件向上级DOM元素传递 .prevent：阻止默认事件的发生 .capture：添加事件侦听器时使用事件捕获模式 .self：将事件绑定到自身，只有自身才能触发 .once：设置事件只能触发一次 .passive：启动被动监听器，默认行为会立即触发。添加了.passive 表示不会在监听函数里添加 preventDefault()来阻止默认行为。 12345678910111213141516171819202122232425&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent&#x3D;&quot;doThat&quot;&gt;&lt;&#x2F;a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;&#x2F;form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture&#x3D;&quot;doThis&quot;&gt;...&lt;&#x2F;div&gt;&lt;!-- 只当在event.target是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self&#x3D;&quot;doThat&quot;&gt;...&lt;&#x2F;div&gt;&lt;!--点击事件将只会触发一次--&gt;&lt;a v-on:click.once&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;&lt;!--滚动事件的默认行为将会立即触发，而不会等待onScroll完成--&gt;&lt;div v-on:scroll.passive&#x3D;&quot;onScroll&quot;&gt;...&lt;&#x2F;div&gt; 使用修饰符时要注意顺序，相应的代码会以同样的顺序产生。因此用v-on:click.prevent.self会阻止所有的点击，而v-on:click.self.prevent只会阻止对元素本身的点击。 不像其他只能对原生的DOM事件起作用的修饰符，.once修饰符还能被用到自定义的组件事件上。 注意：不要把.passive和.prevent一起使用，因为.prevent将会被忽略，同时浏览器可能会展示一个警告。.passive会告诉浏览器不阻止事件的默认行为。 按键修饰符 在监听键盘事件时，经常需要检查详细的按键。Vue允许为v-on在监听键盘事件时添加按键修饰符： 12&lt;!--处理函数vm.submit()只会在$event.key被Enter时（即按下回车键）被调用--&gt;&lt;input v-on:keyup.enter=\"submit\"&gt; 也可以直接将KeyboardEvent.key暴露的任意有效按键名转换为kebab-case来作为修饰符： 12&lt;!--处理函数只会在$event.key等于PageDown时被调用--&gt;&lt;input v-on:keyup.page-down=\"onPageDown\" 按键码 注：keyCode的事件用法已经被废弃了，可能不会被最新的浏览器支持。 使用keyCodeattribute的形式如下： 1&lt;input v-on:keyup.13=\"submit\"&gt; 为了在必要的情况下支持旧浏览器，Vue提供了绝大多数常用的按键码别名： 回车：.enter 换行：.tab 删除：.delete（捕获删除和退格键） 退出：.esc 空格：.space 上：.up 下：.down 左：.left 右：.right 有一些按键（如.esc以及所有的方向键）在IE9中有不同的key值。若想要支持IE9，首选这些内置的别名。 除此之外，还可以通过全局config.keyCodes对象自定义按键修饰符别名： 12//可以使用v-on:keyup.f1Vue.config.keyCodes.f1=112 系统修饰键 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器： .ctrl .alt .shift .meta 注意：在注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。 12345&lt;!-- Alt+C --&gt;&lt;input v-on:keyup.alt.76=\"clear\"&gt;&lt;!-- Ctrl+Click --&gt;&lt;div v-on:click.ctrl=\"doSomething\"&gt;Do something&lt;/div&gt; 修饰键与常规按键不同，在和keyup事件一起用时，事件触发时修饰键必须处于按下状态。即只有在按住ctrl的情况下释放其他按键，才会触发keyup.ctrl。而单单释放ctrl也不会触发事件。若想这样做，请为ctrl换用keyCode:keyup.17。 .exact修饰符 使用.exact修饰符可以精确地控制由系统修饰符组合触发的事件： 12345678&lt;!-- 非ctrl独有，即使是Alt和Shift一起按下时，也会触发 --&gt;&lt;button v-on:click.ctrl=\"onClick\"&gt;A&lt;/button&gt;&lt;!-- 当且仅当Ctrl被按下时才触发 --&gt;&lt;button v-on:click.ctrl.exact=\"onCtrlClick\"&gt;A&lt;/button&gt;&lt;!-- 没有任何系统修饰符被按下时才触发 --&gt;&lt;button v-on:click.exact=\"onClick\"&gt;A&lt;/button&gt; 鼠标按钮修饰符 以下修饰符会限制处理函数仅响应特定的鼠标按钮： 鼠标左键：.left 鼠标右键：.right 鼠标中键：.middle 表单输入绑定 v-model基础用法 可以使用v-model指令在表单&lt;input&gt;、&lt;textarea&gt;及&lt;select&gt;元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。v-model还可以在自定义的输入组件中使用。 v-model指令本质上是语法糖，负责监听用户的输入事件以更新数据，并对一些极端场景进行特殊处理。 v-model会忽略所有表单元素的value、checked、selected attribute 的初始值，并将Vue示例的数据作为数据来源。不过可以通过在JavaScript在组件的data选项中声明初始值。 v-model在内部为不同的输入元素使用不同的preperty并抛出不同的事件： text和textarea元素使用value property和input事件 checkbox和radio使用checked property和change事件 select字段将value作为prop并将change作为事件 注意：v-model不会在输入法组合文字过程中得到更新。若想处理这个过程，可以使用input事件处理。 文本 v-model用于表单中输入文本并绑定值时： 1234567891011121314&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;input v-model&#x3D;&quot;message&quot; placeholder&#x3D;&quot;edit me&quot;&gt; &lt;p&gt;Message is:&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;new Vue(&#123; el:&#39;#example&#39;, data:&#123; message:&#39;&#39; &#125;&#125;)&lt;&#x2F;script&gt; 运行结果如下： 多行文本 v-model用于表单中输入多行文本textarea并绑定值时： 12345678910111213141516&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;span&gt;Multiline message is :&lt;&#x2F;span&gt; &lt;p style&#x3D;&quot;white-space:pre-line;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt; &lt;br &#x2F;&gt; &lt;textarea v-model&#x3D;&quot;message&quot; placeholder&#x3D;&quot;add multiple lines&quot;&gt;&lt;&#x2F;textarea&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;new Vue(&#123; el:&#39;#example&#39;, data:&#123; message:&#39;&#39; &#125;&#125;)&lt;&#x2F;script&gt; 运行结果如下： 注意：在文本区域插值(&lt;textarea&gt;&lt;/textarea&gt;)并不会生效，要用v-model来代替。 复选框 单个复选框，将值绑定到布尔值： 1234567891011121314&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;checked&quot;&gt; &lt;label for&#x3D;&quot;checkbox&quot;&gt;&#123;&#123;checked&#125;&#125;&lt;&#x2F;label&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;new Vue(&#123; el:&#39;#example&#39;, data:&#123; checked:&#39;&#39; &#125;&#125;)&lt;&#x2F;script&gt; 运行结果如下： 多个复选框，将值绑定到同一个数组： 1234567891011121314151617181920&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;jack&quot; value&#x3D;&quot;Jack&quot; v-model&#x3D;&quot;checkedNames&quot;&gt; &lt;label for&#x3D;&quot;jack&quot;&gt;Jack&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;john&quot; value&#x3D;&quot;John&quot; v-model&#x3D;&quot;checkedNames&quot;&gt; &lt;label for&#x3D;&quot;john&quot;&gt;John&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;mike&quot; value&#x3D;&quot;Mike&quot; v-model&#x3D;&quot;checkedNames&quot;&gt; &lt;label for&#x3D;&quot;mike&quot;&gt;Mike&lt;&#x2F;label&gt; &lt;br &#x2F;&gt; &lt;span&gt;Checked names:&#123;&#123;checkedNames&#125;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;new Vue(&#123; el:&#39;#example&#39;, data:&#123; checkedNames:[] &#125;&#125;)&lt;&#x2F;script&gt; 运行结果如下： 单选按钮 12345678910111213141516171819&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;one&quot; value&#x3D;&quot;one&quot; v-model&#x3D;&quot;picked&quot;&gt; &lt;label for&#x3D;&quot;one&quot;&gt;One&lt;&#x2F;label&gt; &lt;br &#x2F;&gt; &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;two&quot; value&#x3D;&quot;Two&quot; v-model&#x3D;&quot;picked&quot;&gt; &lt;label for&#x3D;&quot;two&quot;&gt;Two&lt;&#x2F;label&gt; &lt;br &#x2F;&gt; &lt;span&gt;Picked:&#123;&#123;picked&#125;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;new Vue(&#123; el:&#39;#example&#39;, data:&#123; picked:&#39;&#39; &#125;&#125;)&lt;&#x2F;script&gt; 运行结果如下： 选择框 需要单选时代码如下： 12345678910111213141516171819&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;select v-model&#x3D;&quot;selected&quot;&gt; &lt;option disabled value&#x3D;&quot;&quot;&gt;请选择&lt;&#x2F;option&gt; &lt;option&gt;A&lt;&#x2F;option&gt; &lt;option&gt;B&lt;&#x2F;option&gt; &lt;option&gt;C&lt;&#x2F;option&gt; &lt;&#x2F;select&gt; &lt;span&gt;Selected:&#123;&#123;selected&#125;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;new Vue(&#123; el:&#39;#example&#39;, data:&#123; selected:&#39;&#39; &#125;&#125;)&lt;&#x2F;script&gt; 运行结果如下： 若v-model表达式的初始值未能匹配任何选项，&lt;select&gt;元素将被渲染为未选中的状态。在iOS中这会使用户无法选择第一个选项。因此推荐提供一个值为空的禁用选项。 多选时即将值绑定到一个数组中： 123456789101112131415161718&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;select v-model&#x3D;&quot;selected&quot; multiple style&#x3D;&quot;width:50px;&quot;&gt; &lt;option&gt;A&lt;&#x2F;option&gt; &lt;option&gt;B&lt;&#x2F;option&gt; &lt;option&gt;C&lt;&#x2F;option&gt; &lt;&#x2F;select&gt; &lt;span&gt;Selected:&#123;&#123;selected&#125;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;new Vue(&#123; el:&#39;#example&#39;, data:&#123; selected:[] &#125;&#125;)&lt;&#x2F;script&gt; 运行结果如下： 配合v-for渲染的动态选项，其代码如下： 1234567891011121314151617181920212223&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;select v-model&#x3D;&quot;selected&quot;&gt; &lt;option v-for&#x3D;&quot;option in options&quot; v-bind:value&#x3D;&quot;option.value&quot;&gt; &#123;&#123;option.text&#125;&#125; &lt;&#x2F;option&gt; &lt;&#x2F;select&gt; &lt;span&gt;Selected:&#123;&#123;selected&#125;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;new Vue(&#123; el:&#39;#example&#39;, data:&#123; selected:&#39;A&#39;, options:[ &#123;text:&#39;One&#39;,value:&#39;A&#39;&#125;, &#123;text:&#39;Two&#39;,value:&#39;B&#39;&#125;, &#123;text:&#39;Three&#39;,value:&#39;C&#39;&#125; ] &#125;&#125;)&lt;&#x2F;script&gt; 运行结果如下： 值绑定 对于单选按钮、复选框及选择框的选项，v-model绑定的值通常是静态字符串（对于复选框来说是布尔值）： 12345678910&lt;!-- 当选中时，picked字符串为a --&gt;&lt;input type&#x3D;&quot;radio&quot; v-model&#x3D;&quot;picked&quot; value&#x3D;&quot;a&quot;&gt;&lt;!-- toggle为true或false --&gt;&lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;toggle&quot;&gt;&lt;!-- 当选中第一个选项时，selected为字符串abc --&gt;&lt;select v-model&#x3D;&quot;selected&quot;&gt; &lt;option value&#x3D;&quot;abc&quot;&gt;ABC&lt;&#x2F;option&gt; &lt;&#x2F;select&gt; 当想把值绑定到Vue实例的一个动态property上时，可以使用v-bind实现，且这个property的值可以不是字符串。 复选框 123456&lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;toggle&quot; true-value&#x3D;&quot;yes&quot; false-value&#x3D;&quot;no&quot;&gt;&lt;!-- 当选中时 --&gt;vm.toggle&#x3D;&#x3D;&#x3D;&#39;yes&#39;&lt;!-- 当没有选中时 --&gt;vm.toggle&#x3D;&#x3D;&#x3D;&#39;no&#39; 由于浏览器在提交表单时并不会包含未被选中的复选框，因此这里的true-value和false-value attribute并不会影响输入控件的value attribute。若要确保表单中这两个值中的一个能够被提交，则要换用单选按钮。 单选按钮 1234&lt;input type&#x3D;&quot;radio&quot; v-model&#x3D;&quot;pick&quot; v-bind:value&#x3D;&quot;a&quot;&gt;&lt;!-- 当选中时 --&gt;vm.pick&#x3D;&#x3D;&#x3D;vm.a 选择框的选项 123456789&lt;select v-model&#x3D;&quot;selected&quot;&gt; &lt;option v-bind:value&#x3D;&quot;&#123;number:123&#125;&quot;&gt;123&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&lt;!-- 当选中时 --&gt;typeof vm.selected&lt;!-- vm.selected的类型为object--&gt;vm.selected.number&lt;!-- selected.number的值为123--&gt; 修饰符 .lazy 在默认情况下，v-model在每次input事件触发后将输入框的值与数据进行同步。若将其转为在change事件之后进行同步，可以添加.lazy修饰符： 12&lt;!--在change时更新，而不是在input时--&gt;&lt;input v-model.lazy&#x3D;&quot;msg&quot;&gt; .number 即使在type=\"number\"时，HTML输入元素的值也总会返回字符串。若这个值无法被parseFloat()解析，则会返回原始的值。 若想自动将用户的输入值转为数值类型，可以给v-model添加number修饰符： 1&lt;input v-model.number&#x3D;&quot;age&quot; type&#x3D;&quot;number&quot;&gt; .trim 若想要自动过滤用户输入的首尾空白字符，可以给v-model添加trim修饰符： 1&lt;input v-model.trim&#x3D;&quot;msg&quot;&gt; 组件基础 基本实例 一个Vue组件的实例如下： 12345678910111213141516171819&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;button-counter&gt;&lt;&#x2F;button-counter&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;&#x2F;&#x2F;定义了一个名为button-counter的新组件 Vue.component(&#39;button-counter&#39;,&#123; data:function()&#123; return &#123; count:0 &#125; &#125;, template:&#39;&lt;button v-on:click&#x3D;&quot;count++&quot;&gt;You clicked me &#123;&#123;count&#125;&#125; times.&lt;&#x2F;button&gt;&#39;&#125;)new Vue(&#123; el:&#39;#example&#39;&#125;)&lt;&#x2F;script&gt; 因为组件是可复用的Vue实例，所有它与new Vue接收相同的选项，如data、computed、watch、methods以及生命周期钩子等，像el这种根特例特有的选项除外。 组件的复用 组件可以进行任意次数的复用： 12345678&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;button-counter&gt;&lt;&#x2F;button-counter&gt; &lt;button-counter&gt;&lt;&#x2F;button-counter&gt; &lt;button-counter&gt;&lt;&#x2F;button-counter&gt; &lt;button-counter&gt;&lt;&#x2F;button-counter&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt; 由于每用一次组件，就由一个组件的新实例被创建，因此当点击按钮时，每个组件都会各自独立维护自己的count。 data必须是一个函数 在定义组件的过程中，data并不是直接提供一个对象或是变量的值。组件的data选项必须是一个函数，因此每个实例可以维护一份独立的被返回的拷贝： 12345data:function()&#123; return &#123; count:0 &#125;&#125; 组件的组织 通常一个应用会以一颗嵌套的组件树的形式来组织，一个应用由各类组件组成。 为了能在模板中使用，这些组件必须先注册以便Vue能够识别。 组件的注册类型有两种：全局注册和局部注册。 组件通过Vue.component来进行全局注册： 123Vue.component('component-name',&#123; //options&#125;) 全局注册的组件可以用在其被注册之后的任何通过new Vue新创建的Vue根实例，包括其组件树种的左右子组件的模板。 通过Prop向子组件传递数据 通过Prop可以在组件上注册一些自定义attribute。当一个值传递给一个prop attribute时会变成那个组件实例的一个property。 1234567891011121314151617&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;post-counter title&#x3D;&quot;Blogging with Vue&quot;&gt;&lt;&#x2F;post-counter&gt; &lt;post-counter title&#x3D;&quot;Hello world&quot;&gt;&lt;&#x2F;post-counter&gt; &lt;post-counter title&#x3D;&quot;Zhangsan&quot;&gt;&lt;&#x2F;post-counter&gt; &lt;post-counter title&#x3D;&quot;My journey with Vue&quot;&gt;&lt;&#x2F;post-counter&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;Vue.component(&#39;post-counter&#39;,&#123; props:[&#39;title&#39;], template:&#39;&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;h3&gt;&#39;&#125;)new Vue(&#123; el:&#39;#example&#39;&#125;)&lt;&#x2F;script&gt; 一个组件默认可以拥有任意数量的prop，任何值都可以传递给任何prop。 一个prop被注册后，就可以把数据作为一个自定义attribute传递到子组件中。 与此同时，也可以使用v-bind来动态传递prop： 12345678910111213141516171819202122&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;post-counter v-for&#x3D;&quot;post in posts&quot; v-bind:key&#x3D;&quot;post.id&quot; v-bind:title&#x3D;&quot;post.title&quot;&gt;&lt;&#x2F;post-counter&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;Vue.component(&#39;post-counter&#39;,&#123; props:[&#39;title&#39;], template:&#39;&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;h3&gt;&#39;&#125;)new Vue(&#123; el:&#39;#example&#39;, data:&#123; posts:[ &#123;id:1,title:&#39;Blogging with Vue&#39;&#125;, &#123;id:2,title:&#39;Hello world&#39;&#125;, &#123;id:3,title:&#39;Zhangsan&#39;&#125;, &#123;id:4,title:&#39;My journey with Vue&#39;&#125; ] &#125;&#125;)&lt;&#x2F;script&gt; 单个根元素 当构建一个post-counter组件时，模板里最终包含的东西远不止一个标题信息，至少会包含正文的信息： 12&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;h3&gt;&lt;div v-html&#x3D;&quot;content&quot;&gt;&lt;&#x2F;div&gt; 但在模板中这样写时，Vue会显示一个错误说每个组件必须只有一个根元素。因此需要将模板中的内容包裹在一个父元素&lt;div&gt;内，如： 1234&lt;div class&#x3D;&quot;post-counter&quot;&gt; &lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;h3&gt; &lt;div v-html&#x3D;&quot;content&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; 当不满足于标题和内容信息时，组件会变得越来越复杂。此时为每个相关的信息都定义一个prop会变得很麻烦。故此时需要重构组件，让组件变成接收一个单独的post prop： 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;post-counter v-for&#x3D;&quot;post in posts&quot; v-bind:key&#x3D;&quot;post.id&quot; v-bind:post&#x3D;&quot;post&quot;&gt;&lt;&#x2F;post-counter&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;Vue.component(&#39;post-counter&#39;,&#123; props:[&#39;post&#39;], template:&#96; &lt;div class&#x3D;&quot;post-counter&quot;&gt; &lt;h3&gt;&#123;&#123;post.title&#125;&#125;&lt;&#x2F;h3&gt; &lt;div v-html&#x3D;&quot;post.content&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &#96;&#125;)new Vue(&#123; el:&#39;#example&#39;, data:&#123; posts:[ &#123;id:1,title:&#39;Blogging with Vue&#39;&#125;, &#123;id:2,title:&#39;Hello world&#39;&#125;, &#123;id:3,title:&#39;Zhangsan&#39;&#125;, &#123;id:4,title:&#39;My journey with Vue&#39;&#125; ] &#125;&#125;)&lt;&#x2F;script&gt; 无论何时为post对象添加新的property，都能自动地在重构后的组件内可用。 监听子组件事件 在开发组件时，其一些功能可能要求和父级组件进行沟通。如引入一个辅助功能来放大博文部分的字号，同时让页面的其他部分保持默认的字号。 则可以在父组件中添加一个postFontSize数据 property： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;!-- 在模板中用来控制所有博文的字号 --&gt; &lt;div :style&#x3D;&quot;&#123;fontSize:postFontSize+&#39;em&#39;&#125;&quot;&gt; &lt;!-- 增加监听器，父级组件可通过v-on监听子组件实例的事件，可接收该事件并刷新对应的值 --&gt; &lt;post-counter v-for&#x3D;&quot;post in posts&quot; v-bind:key&#x3D;&quot;post.id&quot; v-bind:post&#x3D;&quot;post&quot; v-on:enlarge-text&#x3D;&quot;postFontSize+&#x3D;0.1&quot; &gt;&lt;&#x2F;post-counter&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt;&lt;script&gt;Vue.component(&#39;post-counter&#39;,&#123; props:[&#39;post&#39;], &#x2F;&#x2F;添加一个放大字号的按钮,通过调用$emit方法并传入事件名称类触发一个事件 template:&#96; &lt;div class&#x3D;&quot;post-counter&quot;&gt; &lt;h3&gt;&#123;&#123;post.title&#125;&#125;&lt;&#x2F;h3&gt; &lt;button v-on:click&#x3D;&quot;$emit(&#39;enlarge-text&#39;)&quot;&gt; Enlarge text &lt;&#x2F;button&gt; &lt;div v-html&#x3D;&quot;post.content&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &#96;&#125;)new Vue(&#123; el:&#39;#example&#39;, data:&#123; posts:[ &#123;id:1,title:&#39;Blogging with Vue&#39;&#125;, &#123;id:2,title:&#39;Hello world&#39;&#125;, &#123;id:3,title:&#39;Zhangsan&#39;&#125;, &#123;id:4,title:&#39;My journey with Vue&#39;&#125; ], postFontSize:1&#x2F;&#x2F;添加postFontSize数据property &#125;&#125;)&lt;&#x2F;script&gt; 使用事件抛出一个值 用一个事件来抛出一个特定的值是非常实用的。如上面例子中，想让post-counter组件自行决定它的文本要放大多少，就是使用$emit的第二个参数来提供这个值： 123&lt;button v-on:click=\"$emit('enlarge-text')\"&gt; Enlarge text&lt;/button&gt; 当父级组件监听这个事件时，可以通过$emit访问到被抛出的这个值： 1v-on:enlarge-text=\"postFontSize+=$event\" 若事件处理函数是一个方法，则这个值将会作为第一个参数传入这个方法： 123456789101112&lt;post-counter v-for&#x3D;&quot;post in posts&quot; v-bind:key&#x3D;&quot;post.id&quot; v-bind:post&#x3D;&quot;post&quot; v-on:enlarge-text&#x3D;&quot;onEnlargeText&quot;&gt;&lt;&#x2F;post-counter&gt;methods:&#123; onEnlargeText:function(enlargeAmount)&#123; this.postFontSize+&#x3D;enlargeAmount &#125;&#125; 在组件上使用v-model 自定义事件也可以用于创建支持v-model的自定义输入组件。 123456&lt;input v-model&#x3D;&quot;searchText&quot;&gt;&lt;!-- 等价于 --&gt;&lt;input v-bind:value&#x3D;&quot;searchText&quot; v-on:input&#x3D;&quot;searchText&#x3D;$event.target.value&quot;&gt; 当用在组件上时，v-model则会变成这样： 1234&lt;custom-input v-bind:value&#x3D;&quot;searchText&quot; v-on:input&#x3D;&quot;searchText&#x3D;$event&quot;&gt;&lt;&#x2F;custom-input&gt; 为了使v-model能够正常工作，这个组件内的&lt;input&gt;必须将其value attribute绑定到名叫value的prop上，并在其input事件被触发时，将新的值通过自定义的input事件抛出，即： 123456789101112131415&lt;body&gt; &lt;!--调用组件--&gt; &lt;custom-input v-model&#x3D;&quot;searchText&quot;&gt;&lt;&#x2F;custom-input&gt;&lt;&#x2F;body&gt;&lt;script&gt;Vue.component(&#39;custom-input&#39;,&#123; props:[&#39;value&#39;], template:&#96; &lt;input v-bind:value&#x3D;&quot;value&quot; v-on:input&#x3D;&quot;$emit(&#39;input&#39;,$event.target.value)&quot; &gt; &#96;&#125;)&lt;&#x2F;script&gt; 通过插槽分发内容 Vue自定义的&lt;slot&gt;元素可以向一个组件传递内容，只要在需要的地方加入插槽就行： 12345678Vue.component(&#39;alert-box&#39;,&#123; template:&#96; &lt;div class&#x3D;&quot;demo-alert-box&quot;&gt; &lt;strong&gt;Error!&lt;&#x2F;strong&gt; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt; &#96;&#125;) 动态组件 可以通过Vue的&lt;component&gt;元素加一个特殊的is attribute实现在不同组件之间进行动态切换，如在一个多标签的页面里实现无跳转切换标签： 12&lt;!-- 组件会在currentTabComponent改变时改变 --&gt;&lt;component v-bind:is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt; 其中，currentTabComponent可以包括已注册组件的名字或是一个组件的选项对象。 这个attribute可以用于常规HTML元素，但这些元素将被视为组件，即所有的attribute都会作为DOM attribute被绑定。若想让其正常工作，则需要使用.prop修饰器。 解析DOM模板时的注意事项 对于一些HTML元素如&lt;ul&gt;、&lt;ol&gt;、&lt;table&gt;和&lt;select&gt;，哪些可以出现在其内部是由严格限制的。而另一些HTML元素如&lt;li&gt;、&lt;tr&gt;和&lt;option&gt;，只能出现在其其他某些特定的元素内部。 123456789&lt;!--自定义组件blog-post-row会被作为无效内容--&gt;&lt;table&gt; &lt;blog-post-row&gt;&lt;&#x2F;blog-post-row&gt;&lt;&#x2F;table&gt;&lt;!--使用is attribute可以让自定义组件不会被作为无效内容--&gt;&lt;table&gt; &lt;tr is&#x3D;&quot;blog-post-row&quot;&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; 若是从以下来源使用模板则没有这个限制： 字符串 单文件组件（.vue） &lt;script type=\"text/x-template\"&gt;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"前端框架","slug":"前端框架","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://tangmenjue.top/tags/Vue-js/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端框架之Vue.js（二）","slug":"前端框架之Vue.js（二）","date":"2022-11-04T08:25:59.000Z","updated":"2022-11-10T15:51:50.382Z","comments":true,"path":"2022/11/04/前端框架之Vue.js（二）/","link":"","permalink":"http://tangmenjue.top/2022/11/04/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8BVue.js%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"Vue.js基础 模板语法 Vue.js使用了基于HTML的模板语法，允许开发者声明式地将DOM绑定至底层Vue实例的数据。所有的Vue.js模板都是合法的HTML。 插值 文本 数据绑定最常见的形式就是使用\"Mustache\"语法（双大括号）的文本插值： 123&lt;div id=\"app\"&gt; &lt;span&gt;message:&#123;&#123;message&#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456var app=new Vue(&#123; el:'#app', data:&#123; message:'Hello Vue!' &#125;&#125;) Mustache标签将会被替代为对应数据对象上msg property的值。当绑定的数据对象上msg property发生了改变，插值的内容都会更新。 使用v-once指令，可以执行一次性地插值。当数据改变时，插值处的内容不会更新，但这会影响到该节点上的其他数据绑定： 123&lt;div id=\"app\"&gt;&lt;span v-once&gt;本句话将不会改变：&#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;/div&gt; 1app.message='nihao' 原始HTML 双大括号会将数据解释为普通文本，并非是HTML代码。使用v-html指令可以输出HTML代码： 12&lt;p&gt;Using mushaches:&#123;&#123;rewHtml&#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive:&lt;span v-html=\"rewHtml\"&gt;&lt;/span&gt;&lt;/p&gt; 1234567var app=new Vue(&#123; el:'#app', data:&#123; message:'Hello Vue!', rewHtml:'&lt;span style=\"color:red\"&gt;This should be red.&lt;/span&gt;' &#125;&#125;) 这个span的内容将会被替换成为property值rawHtml，忽略解析property值中的数据绑定后，直接作为HTML。注意不能使用v-html来复合局部模板。 在站点上动态渲染任意的HTML可能会非常危险，其很容易导致XSS攻击。因此要只对可信内容使用HTML插值，不要对用户提供的内容使用插值。 Attribute Mustache语法不能作用在HTML attribute上，此时应该使用v-bind指令： 123&lt;div v-bind:id=\"dynamicId\"&gt; &lt;button v-bind:disabled=\"isButtonDisabled\"&gt;Button&lt;/button&gt;&lt;/div&gt; 123456var app=new Vue(&#123; el:'#dynamicId', data:&#123; isButtonDisabled:true &#125;&#125;) 若isButtonDisabled的值是null、undefined或false，则disableattribute是不会被包含在渲染出来的&lt;button&gt;元素中。 使用JavaScript表达式 对于所有的数据绑定，Vue.js提供了完全的JavaScript表达式支持。 1234567891011121314151617&lt;body&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;p&gt;number:&#123;&#123;number+1&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;ok:&#123;&#123;ok?&#39;YES&#39;:&#39;NO&#39;&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;&#123;&#123;message.split(&#39;&#39;).reverse().join(&#39;&#39;)&#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var app&#x3D;new Vue(&#123; el:&#39;#app&#39;, data:&#123; number:123, ok:&#39;1&gt;2&#39;, message:&#39;hello&#39;, &#125; &#125;)&lt;&#x2F;script&gt;xxxxxxxxxx17 1&lt;body&gt;2 &lt;div id&#x3D;&quot;app&quot;&gt;3 &lt;p&gt;number:&#123;&#123;number+1&#125;&#125;&lt;&#x2F;p&gt;4 &lt;p&gt;ok:&#123;&#123;ok?&#39;YES&#39;:&#39;NO&#39;&#125;&#125;&lt;&#x2F;p&gt;5 &lt;p&gt;&#123;&#123;message.split(&#39;&#39;).reverse().join(&#39;&#39;)&#125;&#125;&lt;&#x2F;p&gt;6 &lt;&#x2F;div&gt;7&lt;&#x2F;body&gt;8&lt;script&gt;9 var app&#x3D;new Vue(&#123;10 el:&#39;#app&#39;,11 data:&#123;12 number:123,13 ok:&#39;1&gt;2&#39;,14 message:&#39;hello&#39;,15 &#125;16 &#125;)17&lt;&#x2F;script&gt; 上述表达式会在所属Vue实例的数据作用域下作为JavaScript被解析。注意：每个绑定都只能包含单个表达式。因此下面的例子不会生效： 1234&lt;!--这是语句，不是表达式--&gt;&#123;&#123;var a&#x3D;1&#125;&#125;&lt;!--流控制也不会生效，请使用三元表达式--&gt;&#123;&#123;if (ok)&#123; return message &#125;&#125;&#125; 模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如Math和Date。不要在模板表达式中视图访问用户定义的全局变量。 指令 指令是带有v-前缀的特殊attribute。指令attribute的值预期是单个JavaScript表达式（v-for除外）指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM，如： 1&lt;p v-if=\"seen\"&gt;现在可以看到我&lt;/p&gt; 在这里，v-if指令将根据表达式seen值的真假来插入/移除&lt;p&gt;元素。 参数 一些指令能够接收一个“参数”，在指令名称之后以冒号表示。如v-bind指令可以用于响应式地更新HTML attribute: 1&lt;a v-bind:href=\"url\"&gt;...&lt;/a&gt; 在这里，href是参数，告知v-bind指令将该元素的href attribute与表达式url的值绑定。 另一个v-on指令可用于监听DOM事件： 1&lt;a v-on:click=\"doSomething\"&gt;...&lt;/a&gt; 在这里参数是监听的事件名。 动态参数 从Vue2.6.0开始，可以用方括号括起来的JavaScript表达式作为一个指令的参数： 1&lt;a v-bind:[attributeName]=\"url\"&gt;...&lt;/a&gt; 这里的attributeName会被作为一个JavaScript表达式进行动态求值，求得的值将会作为最终的参数来使用。如，若Vue实例中有一个名为attributeName的dataproperty，其值为href，则上面的语句等价于v-bind:href=\"url\"。 动态参数可以为一个动态的事件名绑定处理函数： 1&lt;a v-on:[eventName]=\"doSomething\"&gt;...&lt;/a&gt; 在这里，当eventName的值为\"focus\"时，v-on:{eventName}将等价于v-on:focus。 对动态参数值的约束： 动态函数预期会求出一个字符串，异常情况下值为null。这个特殊的null值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。 对动态参数表达式的约束： 动态参数表达式有一些语法约束，如空格和引号，放在HTML attribute名里是无效的。因此使用没有空格或引号的表达式，或使用计算属性来替代这种复杂表达式。 在DOM中使用模板时（即直接在HTML文件里撰写模板），由于浏览器会把attribute名全部强制转为小写，还要避免使用大写字符来命名键名。 修饰符 修饰符是以半角句号.指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。如.prevent修饰符告诉v-on指令对于触发的事件调用event.preventDefault()： 1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;...&lt;/form&gt; 缩写 v-前缀作为一种视觉提示，用来识别模板中Vue特定的attribute。v-前缀有助于为现有标签添加动态行为，但在一些频繁用到的指令以及构建由Vue管理所有模板的单页面应用程序里，v-前缀的作用不大。 v-bind缩写 123456&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 --&gt;&lt;a :[key]=\"url\"&gt;...&lt;/a:&gt; v-on缩写 123456&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 --&gt;&lt;a @[event]=\"doSomething\"&gt;...&lt;/a:&gt; 计算属性和侦听器 计算属性 对于任何复杂逻辑，应当使用计算属性。 基础例子 12345678910111213141516171819&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;p&gt;Original message:&quot;&#123;&#123;message&#125;&#125;&quot;&lt;&#x2F;p&gt; &lt;p&gt;Computed reversed message:&quot;&#123;&#123;reversedMessage&#125;&#125;&quot;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var vm&#x3D;new Vue(&#123; el:&#39;#example&#39;, data:&#123; message:&#39;Hello&#39; &#125;, computed:&#123; reversedMessage:function()&#123; return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125; &#125; &#125;)&lt;&#x2F;script&gt; 在这里声明了一个计算属性reversedMessage，提供的函数将用作propertyvm.reversedMessage的getter函数。 打开F12中的JavaScript控制台，输入以下JavaScript代码： 123456console.log(vm.reversedMessage)//返回olleHvm.message='Goodbye'//返回'Goodbye'console.log(vm.reversedMessage)//返回eybdooG 可以看到，vm.reversedMessage的值始终取决于vm.message的值。 vm.reversedMessage依赖于vm.message，因此当vm.message发生改变时，所有依赖vm.reversedMessage的绑定也会更新。由于已经以声明的方式创建了这种依赖关系，因此计算属性的getter函数是没有副作用的。 计算属性缓存 vs 方法 通过在表达式中调用方法也可以达到与基础例子同样的效果，将同一函数定义为一个方法而不是一个计算属性： 123456789101112131415161718&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;p&gt;Reverssed message:&quot;&#123;&#123;reversedMessage()&#125;&#125;&quot;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var vm&#x3D;new Vue(&#123; el:&#39;#example&#39;, data:&#123; message:&#39;hello&#39; &#125;, methods:&#123; reversedMessage:function()&#123; return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125; &#125; &#125;)&lt;&#x2F;script&gt; 打开F12中的JavaScript控制台，输入以下JavaScript代码： 123456console.log(vm.reversedMessage())//返回ollehvm.message='exam'//返回'exam'console.log(vm.reversedMessage())//返回maxe 可以看到这两种方式的最终结果是相同的。不同的是计算属性是基于响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。也就是说，只要message还没有发生改变，多次访问reversedMessage计算属性会立即返回之前的计算结果，而不必再次执行函数。但这也意味着下面的计算属性将不再更新，因为其不是响应式依赖： 12345computed:&#123; now:function()&#123; return Date.now() &#125;&#125; 而每次触发重新渲染时，调用方法总会再次执行函数。 计算属性 vs 侦听属性 Vue的侦听属性可以用来观察和响应Vue实例上的数据变动。当有一些数据需要随着其他数据变动而变动时，很容易会滥用watch。通常更好的做法是使用计算数学而不是命令是的watch回调。 watch回调版本的代码： 1234567891011121314151617181920212223&lt;body&gt; &lt;div id&#x3D;&quot;demo&quot;&gt; &#123;&#123;fullName&#125;&#125; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var vm&#x3D;new Vue(&#123; el:&#39;#demo&#39;, data:&#123; firstName:&#39;Foo&#39;, lastName:&#39;Bar&#39;, fullName:&#39;Foo Bar&#39; &#125;, watch:&#123; firstName:function(val)&#123; this.fullName&#x3D;val+&#39; &#39;+this.lastName &#125;, lastName:function(val)&#123; this.fullName&#x3D;this.firstName+&#39; &#39;+val &#125; &#125; &#125;)&lt;&#x2F;script&gt; 计算属性版本的代码： 12345678910111213141516171819&lt;body&gt; &lt;div id&#x3D;&quot;demo&quot;&gt; &#123;&#123;fullName&#125;&#125; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var vm&#x3D;new Vue(&#123; el:&#39;#demo&#39;, data:&#123; firstName:&#39;Foo&#39;, lastName:&#39;Bar&#39; &#125;, computed:&#123; fullName:function()&#123; return this.fullName&#x3D;this.firstName+&#39; &#39;+this.lastName &#125; &#125; &#125;)&lt;&#x2F;script&gt; 由此可见计算属性版本的代码比watch回调版本的代码好多了。 计算属性的setter 计算属性默认只有getter，但在需要时也可以提供一个setter： 1234567891011121314computed:&#123; fullName:&#123; //getter get:function()&#123; return this.firstName+' '+this.lastName &#125;, //setter set:function(newValue)&#123; var names=newValue.split(' ') this.firstName=names[0] this.lastName=names[names.length-1] &#125; &#125;&#125; 打开F12中的JavaScript控制台，运行vm.fullName='zhangsan'时，setter会被调用，vm.firstName和vm.lastName也会随之更新。 侦听器 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。当需要在数据变化时执行异步或开销较大的操作时，自定义侦听器的方式是最有用的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;axios@0.12.0&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;lodash@4.13.1&#x2F;lodash.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div id&#x3D;&quot;watch-example&quot;&gt; &lt;p&gt;Ask a yes&#x2F;no question: &lt;input v-model&#x3D;&quot;question&quot;&gt; &lt;&#x2F;p&gt; &lt;p&gt;&#123;&#123;answer&#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var watchExampleVM&#x3D;new Vue(&#123; el:&#39;#watch-example&#39;, data:&#123; question:&#39;&#39;, answer:&#39;I cannot give you an answer until you ask a question!&#39; &#125;, watch:&#123; question:function(newQuestion,oldQuestion)&#123; this.answer&#x3D;&#39;Waiting for you to stop typing...&#39; this.debouncedGetAnswer() &#125; &#125;, created:function()&#123; this.debouncedGetAnswer&#x3D;_.debounce(this.getAnswer,500) &#125;, methods:&#123; getAnswer:function()&#123; if(this.question.indexOf(&#39;?&#39;)&#x3D;&#x3D;&#x3D;-1)&#123; this.answer&#x3D;&#39;Questions usually contain a question mark. ;-)&#39; return &#125; this.answer&#x3D;&#39;Thinking...&#39; var vm&#x3D;this axios.get(&#39;https:&#x2F;&#x2F;yesno.wtf&#x2F;api&#39;) .then(function(response)&#123; vm.answer&#x3D;_.capitalize(response.data.answer) &#125;) .catch(function(error)&#123; vm.answer&#x3D;&#39;Error! Could not reach the API. &#39;+error &#125;) &#125; &#125; &#125;)&lt;&#x2F;script&gt;&lt;&#x2F;html&gt; 在这个示例中，使用watch选项执行异步操作（访问一个API），限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 Class与Style绑定 操作元素的class列表和内联样式是数据绑定的常见需求。由于它们都是attribute，因此可以用v-bind来处理它们。将v-bind用于class和style时，表达式结果的类型除了字符串之外，还可以是对象或数组。 绑定HTML Class 对象语法 动态地切换class可以传给v-bind:class一个对象： 1&lt;div v-bind:class=\"&#123;active:isActive&#125;\"&gt;Hello Vue!&lt;/div&gt; 上面的代码表示active这个class存在与否将取决于数据property isActive的truthiness。 可以在对象中传入更多字段来动态切换多个class。v-bind:class指令也可以与普通的class attribute共存： 1234567891011121314&lt;body&gt; &lt;div class&#x3D;&#39;static&#39; v-bind:class&#x3D;&quot;&#123;active:isActive,&#39;text-danger&#39;:hasError&#125;&quot; &gt;Hello Vue!&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var tes&#x3D;new Vue(&#123; data:&#123; isActive:true, hasError:false &#125; &#125;)&lt;&#x2F;script&gt; 渲染后就等价于 1&lt;div class='static active'&gt;Hello Vue!&lt;/div&gt; 当isActive或者hasError变化时，class列表将相应地更新。若hasError的值为true，则class列表将变为class='static active text-danger'。 绑定的数据对象不必内联定义在模板里： 12345678910111213&lt;body&gt; &lt;div v-bind:class&#x3D;&quot;classObject&quot;&gt;Hello Vue!&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var tes&#x3D;new Vue(&#123; data:&#123; classObject:&#123; active:true, &#39;text-danger&#39;:false &#125; &#125; &#125;)&lt;&#x2F;script&gt; 其渲染结果和上面是一样的。也可以在这里绑定一个返回对象的计算属性，这是一个常用的模式： 12345678910111213141516171819&lt;body&gt; &lt;div id&#x3D;&#39;test&#39; v-bind:class&#x3D;&quot;classObject&quot;&gt;Hello Vue!&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var tes&#x3D;new Vue(&#123; data:&#123; isActive:true, error:null &#125;, computed:&#123; classObject:function()&#123; return &#123; active:this.isActive &amp;&amp; !this.error, &#39;text-danger&#39;:this.error &amp;&amp; this.error.type&#x3D;&#x3D;&#x3D;&#39;fatal&#39; &#125; &#125; &#125; &#125;)&lt;&#x2F;script&gt; 数组语法 应用一个class列表可以把一个数组传给v-bind:class： 1234567891011&lt;body&gt; &lt;div v-bind:class&#x3D;&quot;[activeClass, errorClass]&quot;&gt;Hello Vue!&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var tes&#x3D;new Vue(&#123; data:&#123; activeClass:&#39;active&#39;, errorClass:&#39;text-danger&#39; &#125; &#125;)&lt;&#x2F;script&gt; 渲染后就等价于 1&lt;div class='active text-danger'&gt;Hello Vue!&lt;/div&gt; 若想根据条件切换列表中的class，可以用三元表达式： 1&lt;div v-bind:class=\"[isActive ? activeClass:'',errorClass]\"&gt;Hello Vue!&lt;/div&gt; 这样便是始终添加errorClass，但只有在isActive是truthy时才添加activeClass。 注意：truthy是指再布尔值上下文中，转换后的值为'true'，其不是true。 当有多个条件class时这样写有些繁琐，因此在数组语法中也可以使用对象语法： 12&lt;div v-bind:class=\"[&#123;active:isActive&#125;,errorClass]\"&gt;Hello Vue!&lt;/div&gt; 用在组件上 当在一个自定义组件上使用class property时，这些class将被追加到该组件的根元素上面，已存在的class不会被覆盖。 若这有一组件声明如下： 123Vue component('my-component',&#123; template:'&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'&#125;) 使用它时添加一些class： 1&lt;my-component class=\"text\"&gt;&lt;/my-component&gt; HTML将被渲染为： 123&lt;p class=\"foo bar text\"&gt; Hi&lt;/p&gt; 对于带数据绑定的class也同样适用： 12345&lt;my-component v-bind:class=\"&#123;active:isActive&#125;\"&gt;&lt;/my-component&gt;&lt;!--当isActive为truthy时，HTML将被渲染为--&gt;&lt;p class=\"foo far active\"&gt; Hi&lt;/p&gt; 绑定内联样式 对象语法 v-bind:style的对象语法看起来非常像CSS，但实际上是个JavaScript对象。CSS property名可以用驼峰式（camelCase）或短横线分隔（kebab-case，记得用括号括起来）来命名： 1234567891011&lt;body&gt; &lt;div id&#x3D;&#39;test&#39; v-bind:style&#x3D;&quot;&#123;color:activeColor,fontSize:fontSize+&#39;px&#39;&#125;&quot;&gt;Hello Vue!&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var tes&#x3D;new Vue(&#123; el:&#39;#test&#39;, data:&#123; activeColor:&#39;red&#39;, fontSize:30 &#125; &#125;) 通常直接绑定到一个样式对象，让模板更清晰： 1234567891011121314&lt;body&gt; &lt;div id&#x3D;&#39;test&#39; v-bind:style&#x3D;&quot;styleObject&quot;&gt;Hello Vue!&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var tes&#x3D;new Vue(&#123; el:&#39;#test&#39;, data:&#123; styleObject:&#123; color:&#39;red&#39;, fontSize:&#39;13px&#39; &#125; &#125; &#125;)&lt;&#x2F;script&gt; 对象语法常会结合返回对象的计算熟悉使用。 数组语法 v-bind:style的数组书法可以将多个样式对象应用到同一个元素上： 1&lt;div id='test' v-bind:style=\"[baseStyles,overridingStyles]\"&gt;Hello Vue!&lt;/div&gt; 自动添加前缀 当v-bind:style需要使用添加浏览器引擎前缀的CSS property时，如tranform，Vue.js会自动侦测并添加相应的前缀。 多重值 从Vue2.3.0版本起，可以为style绑定中的property提供一个包含多个值的数组，常用于提供多个带前缀的值： 1&lt;div :style=\"&#123;display:['-webkit-box','-ms-flexbox','flex']&#125;\"&gt;Helo&lt;/div&gt; 上述代码只会渲染数组中最后一个被浏览器支持的值。若浏览器支持不带浏览器前缀的flexbox，那么就只会渲染display:flex。 条件渲染 v-if v-if指令用于条件性地渲染一块内容。这块内容只会再指令的表达式返回truthy值时被渲染： 1&lt;h1 v-if=\"awesome\"&gt;Vue is awesome!&lt;/h1&gt; 也可以用v-else添加一个\"else\"块： 12&lt;h1 v-if=\"awesome\"&gt;Vue is awesome!&lt;/h1&gt;&lt;h1 v-else&gt;Oh no!!!&lt;/h1&gt; 在&lt;template&gt;元素上使用v-if条件渲染分组 由于v-if是一个指令，所以必须将它添加到一个元素上。若想要切换多个元素时，可以把一个&lt;template&gt;元素当作不可见的包裹元素并在&lt;template&gt;元素上使用v-if，最终的渲染结果将不包含&lt;template&gt;。 12345&lt;template v-if=\"ok\"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;paragraph 2&lt;/p&gt;&lt;/template&gt; v-else 可以用v-else指令来表示v-if的\"else\"块： 123456789101112131415&lt;body&gt;&lt;div id&#x3D;&quot;test&quot;&gt; &lt;div v-if&#x3D;&quot;Math.random()&gt;0.5&quot;&gt; Now you see me! &lt;&#x2F;div&gt; &lt;div v-else&gt; Now you can not see me! &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var tes&#x3D;new Vue(&#123; el:&#39;#test&#39; &#125;)&lt;&#x2F;script&gt; v-else元素必须紧跟在带v-if或v-else-if的元素后面，否则它将不会被之别。 v-else-if v-else-if指令表示v-if的\"else-if\"块，可以连续使用： 12345678910111213141516&lt;body&gt;&lt;div id&#x3D;&quot;test&quot;&gt; &lt;div v-if&#x3D;&quot;type&#x3D;&#x3D;&#x3D;&#39;A&#39;&quot;&gt;A&lt;&#x2F;div&gt; &lt;div v-else-if&#x3D;&quot;type&#x3D;&#x3D;&#x3D;&#39;B&#39;&quot;&gt;B&lt;&#x2F;div&gt; &lt;div v-else-if&#x3D;&quot;type&#x3D;&#x3D;&#x3D;&#39;c&#39;&quot;&gt;C&lt;&#x2F;div&gt; &lt;div v-else&gt;Not A&#x2F;B&#x2F;c&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var tes&#x3D;new Vue(&#123; el:&#39;#test&#39;, data:&#123; type:&#39;D&#39; &#125; &#125;)&lt;&#x2F;script&gt; 类似于v-else，v-else-if也必须紧跟在带v-if或v-else-if的元素之后。 用key管理可复用的元素 Vue通常会复用已有元素而不是从头开始渲染。这样除了让Vue变得非常快之外，还有其他一些好处。如允许用户在不同的登录方式之间切换： 1234567891011121314151617181920212223242526&lt;body&gt;&lt;div id&#x3D;&quot;test&quot;&gt; &lt;template v-if&#x3D;&quot;loginType&#x3D;&#x3D;&#x3D;&#39;username&#39;&quot;&gt; &lt;label&gt;Username&lt;&#x2F;label&gt; &lt;input placeholder&#x3D;&quot;Enter your username&quot; &gt; &lt;&#x2F;template&gt; &lt;template v-else&gt; &lt;label&gt;Email&lt;&#x2F;label&gt; &lt;input placeholder&#x3D;&quot;Enter your email address&quot; &gt; &lt;&#x2F;template&gt; &lt;button v-on:click&#x3D;&quot;changeMessage&quot;&gt;Toggle login type&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var tes&#x3D;new Vue(&#123; el:&#39;#test&#39;, data:&#123; loginType:&#39;zhangsan&#39; &#125;, methods:&#123; changeMessage:function()&#123; return this.loginType&#x3D;this.loginType&#x3D;&#x3D;&#x3D;&#39;username&#39;?&#39;eamil&#39;:&#39;username&#39; &#125; &#125; &#125;)&lt;&#x2F;script&gt; 运行结果如下： 在输入框输入一些文本，然后按下切换按钮。可以看到用户输入在输入框的内容是不变的。 这意味着在上面的代码中切换loginType将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，&lt;input&gt;不会被替换掉，仅只是替换了它的placeholder。 Vue还提供一种方式来表达“这两个元素是完全独立的，不要复用它们”，只需要添加一个具有唯一值的key attribute即可： 1234567891011121314151617181920212223242526&lt;body&gt;&lt;div id&#x3D;&quot;test&quot;&gt; &lt;template v-if&#x3D;&quot;loginType&#x3D;&#x3D;&#x3D;&#39;username&#39;&quot;&gt; &lt;label&gt;Username&lt;&#x2F;label&gt; &lt;input placeholder&#x3D;&quot;Enter your username&quot; key&#x3D;&quot;username-input&quot;&gt; &lt;&#x2F;template&gt; &lt;template v-else&gt; &lt;label&gt;Email&lt;&#x2F;label&gt; &lt;input placeholder&#x3D;&quot;Enter your email address&quot; key&#x3D;&quot;email-input&quot;&gt; &lt;&#x2F;template&gt; &lt;button v-on:click&#x3D;&quot;changeMessage&quot;&gt;Toggle login type&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt; var tes&#x3D;new Vue(&#123; el:&#39;#test&#39;, data:&#123; loginType:&#39;zhangsan&#39; &#125;, methods:&#123; changeMessage:function()&#123; return this.loginType&#x3D;this.loginType&#x3D;&#x3D;&#x3D;&#39;username&#39;?&#39;eamil&#39;:&#39;username&#39; &#125; &#125; &#125;)&lt;&#x2F;script&gt; 运行代码后，再次在输入框输入一些文本，然后按下切换按钮。可以看到每次切换时，输入框都将被重新渲染。 需要注意的是：这里的&lt;label&gt;仍然会被高效得复用，因为它们没有添加keyattribute。 v-show 另一个用于根据条件展示元素的选项是v-show指令： 1&lt;h1 v-show=\"ok\"&gt;Hello!&lt;/h1&gt; 与v-if不同的是，v-show的元素始终会被渲染并保留在DOM中，其只是简单地切换元素的CSS property display。 注意：v-show不支持&lt;template&gt;元素，也不支持`v-else。 v-if VS v-show v-if 是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 是惰性的：若在初始渲染时条件为假，则什么也不做。直至条件第一次变为真时，才会开始渲染条件块。 而v-show不管初始条件是什么，元素总是会被渲染，并且只是简单地基于CSS进行切换。 一般来说，v-if 有更高的切换开销，v-show有更高的初始渲染开销。因此若需要非常频繁地切换，则使用v-show；若在运行时条件很少改变，则使用v-if 。 v-if 与v-for一起使用 不推荐同时使用v-if 和v-for。 当v-if 和v-for一起使用时，v-for 具有比v-if 更高的优先级。这意味着v-if将分别重复运行于每个v-for循环中。当只想为部分项渲染节点时，这种优先节点十分有用： 1&lt;li v-for=\"todo in todos\" v-if=\"!todo.isComplete\"&gt;&#123;&#123;todo&#125;&#125;&lt;/li&gt; 上面的代码只渲染未完成的todo。 而若是想要有条件地跳过循环的执行，则可以将v-if置于外层元素（或&lt;template&gt;）上： 1234&lt;ul v-if=\"todos.length\"&gt; &lt;li v-for=\"todo in todos\"&gt;&#123;&#123;todo&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No todos left!&lt;/p&gt;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"前端框架","slug":"前端框架","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://tangmenjue.top/tags/Vue-js/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端框架之Vue.js（一）","slug":"前端框架之Vue.js（一）","date":"2022-11-03T03:30:59.000Z","updated":"2022-11-10T15:51:35.717Z","comments":true,"path":"2022/11/03/前端框架之Vue.js（一）/","link":"","permalink":"http://tangmenjue.top/2022/11/03/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8BVue.js%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"Vue.js基础 Vue是一套用于构建用户界面的渐进式框架。与其他大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，易于上手且便于与第三方库或既有项目结合。 Vue不支持IE8及以下的版本，它支持所有兼容ECMA Script 5的浏览器。 安装 直接用&lt;script&gt;引入 若要在现有站点中使用Vue，可以通过&lt;script&gt;元素在页面中使用。 开发环境版本，包含了有帮助的命令行警告： 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; 生产环境版本，优化了尺寸和速度。在站点上包含Vue时要指定版本号： 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2\"&gt;&lt;/script&gt; 使用npm安装 直接用&lt;script&gt;引入vue的方法有一些局限性，若要构建更复杂的应用程序，需要使用npm软件包和脚手架CLI。在此之前，需要安装node.js 8.11及以上的版本，安装有包管理器npm。 在cmd里使用node.js的npm命令安装Vue： 1npm install vue 在cmd里使用node.js的npm命令安装脚手架CLI： 123npm install --global @vue/cli若安装不上使用下面命令进行安装cnpm install -g @vue/cli 注意：不推荐新手直接使用vue-cli，尤其是还不熟悉基于Node.js的构建工具时。 Vue Devtools 在使用vue时，推荐在浏览器上安装 Vue Devtools。它允许在一个更友好的界面中审查和调试 Vue 应用。 声明式渲染 Vue.js的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进DOM系统。 新建一个html文件，编写以下代码后运行，即可创建第一个Vue应用： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var app=new Vue(&#123; el:'#app', data:&#123; message:'Hello Vue!' &#125; &#125;)&lt;/script&gt;&lt;/html&gt;&lt;!--运行结果如下：--&gt;Hello Vue! 创建应用的过程看起来与渲染一个字符串模板类似。现在数据和DOM已经被建立了管理，所有东西都是响应式的。 在运行代码的浏览器上按F12打开开发人员工具，选择控制台（后续简称为JavaScript控制台），修改app.message的值，即可看到浏览器中也会及时更新显示的值： 一个Vue应用会将其挂载到一个DOM元素上（上述代码中是#app），然后对其进行完全控制。 除了文本插值，还可以绑定元素attribute如下所示： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;div id=\"app-2\"&gt; &lt;span v-bind:title=\"message\"&gt; 鼠标悬停几秒查看此处动态绑定的提示信息！ &lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var app=new Vue(&#123; el:'#app', data:&#123; message:'Hello Vue!' &#125; &#125;) var app2=new Vue(&#123; el:'#app-2', data:&#123; message:'页面加载于 '+new Date().toLocaleString() &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 这里的v-bind attribute被称为指令。指令带有前缀v-以表示它们是Vue提供的特殊attribute。它们会在渲染的DOM上应用特殊的响应式行为。在上述代码中，该实例的意思是：将这个元素节点的title atrribute和Vue实例的message property保持一致。 若再次打开JavaScript控制台，输入app2.message='新消息'，就会再次看到这个绑定了title attribute的HTML已经进行了更新。 条件与循环 可以利用条件判断来控制切换一个元素是否显示： 123&lt;div id=\"app-3\"&gt; &lt;p v-if=\"seen\"&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt; 123456var app3=new Vue(&#123; el:'#app-3', data:&#123; seen:true &#125;&#125;) 若打开JavaScript控制台，输入app3.seen=false，就会再次看到之前显示的消息消失了。 上述例子演示了不仅可以把数据绑定到DOM文本或attribute，还可以绑定到DOM结构。除此之外，Vue也提供了一个强大的过渡效果系统，可以在Vue插入/更新/移除元素时自动应用过渡效果。 还有很多其他指令，每个都有特殊的功能，如v-for指令可以绑定数组的数据来渲染一个项目列表： 1234567&lt;div id=\"app-4\"&gt; &lt;ol&gt; &lt;li v-for=\"todo in todos\"&gt; &#123;&#123;todo.text&#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910var app4=new Vue(&#123; el:'#app-4', data:&#123; todos:[ &#123; text:'学习 JavaScript'&#125;, &#123; text:'学习 Vue'&#125;, &#123; text:'搞个项目'&#125; ] &#125;&#125;) 在控制台里，输入app4.todos.push({ text: '新项目'})，会发现列表最后添加了一个新项目。 处理用户输入 为了让用户和应用进行交互，可以用v-on指令添加一个事件监听器，通过它调用在Vue实例中定义的方法： 1234&lt;div id=\"app-5\"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"reverseMessage\"&gt;反转信息&lt;/button&gt;&lt;/div&gt; 1234567891011var app5=new Vue(&#123; el:'#app-5', data:&#123; message:'Hello Vue.js!' &#125;, methods:&#123; reverseMessage:function()&#123; this.message=this.message.split('').reverse().join('') &#125; &#125;&#125;) 注意：在reverseMessage方法中，虽然更新了应用状态，但没有触碰DOM，所有的DOM操作都有Vue来处理。 Vue还提供了v-model指令，可以实现表单输入和应用状态之间的双向绑定： 1234&lt;div id=\"app-6\"&gt; &lt;p&gt;&#123;&#123; message&#125;&#125;&lt;/p&gt; &lt;input v-model=\"message\"&gt;&lt;/div&gt; 123456var app6=new Vue(&#123; el:'#app-6', data:&#123; message:'Hello Vue!' &#125;&#125;) 组件化应用创建 组件系统是Vue的另一个重要概念。它是一种抽象，允许使用小型、独立和通常可复用的组件构建大型应用。因此任意类型的应用界面都可以抽象为一个组件树。 在Vue里，一个组件本质上是一个拥有预定义选项的一个Vue实例。其中使用 v-bind 指令将待办项传到循环输出的每个组件中： 12345678&lt;div id=\"app-7\"&gt; &lt;ol&gt; &lt;!--使用v-bind指令将待办项传到循环输出的每个组件中--&gt; &lt;!--为每个todo-item提供todo对象--&gt; &lt;!--todo对象是变量，其内容是动态的。同时也需要为每个组件提供一个\"key\"--&gt; &lt;todo-item v-for=\"item in groceryList\" v-bind:todo=\"item\" v-bind:key=\"item.id\"&gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt; 1234567891011121314151617&lt;script&gt; Vue.component('todo-item',&#123; //todo-item组件接收一个名为todo的prop，类似于一个自定义attribute props:['todo'], template:'&lt;li&gt;&#123;&#123;todo.text&#125;&#125;&lt;/li&gt;' &#125;) var app7=new Vue(&#123; el:'#app-7', data:&#123; groceryList:[ &#123; id:0,text:'蔬菜'&#125;, &#123; id:1,text:'奶酪'&#125;, &#123; id:2,text:'薯条'&#125; ] &#125; &#125;)&lt;/script&gt; 上述代码中，将应用分割成了两个更小的单元。子单元通过prop接口与负担也进行了良好的解耦，后续可以进一步改进&lt;todo-item&gt;组件，提供更为复杂的模板和逻辑，而不会影响到父单元。在一个大型应用中，将整个应用程序划分为组件是有必要的。 组件与自定义元素的关系 Vue组件是Web组件规范的一部分，其与自定义元素十分类似，但还是有关键的差别： Web Components规范已完成并通过，但未被所有浏览器原生实现。相比之下，Vue组件不需要任何polyfill，且在所有支持的浏览器中表现一致。必要时，Vue组件也可以包装与原生自定义元素之内 Vue组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。 因此，虽然Vue内部没有使用自定义元素，但在应用使用自定义元素或以自定义元素发布时，仍然有着很好的操作性。Vue CLI脚手架 也支持将Vue组件构建成为原生的自定义元素。 Vue实例 创建一个Vue实例 每个Vue应用都是通过用Vue函数创建一个新的Vue实例开始的： 123var vm&#x3D;new Vue(&#123; &#x2F;&#x2F;选项&#125;) 在文档中经常会使用vm这个变量名表示Vue实例。当创建一个实例时，可以传入一个选项对象。 一个Vue应用由一个通过new Vue创建的根Vue实例，以及可选的嵌套的、可复用的组件树组成。所有的Vue组件都是Vue实例，并且接受相同的选项对象。 数据与方法 当一个Vue实例被创建时，它将data对象中的所有property加入到Vue的响应式系统中。当这些property的值发生改变时，视图将会产生响应， 即匹配更新为新的值。 123456789101112 var data=&#123;a:1&#125;//数据对象 var vm=new Vue(&#123;//该对象被加入到一个Vue实例中 data:data &#125;) //获得这个实例上的property,返回源数据中对应的字段 vm.a==data.a//设置property会影响到原始数据 vm.a=2 data.a//返回2//反过来也一样 data.a=3 vm.a//返回3 当这些数据改变时，视图会进行重渲染。只有当实例被创建时就已经存在与property才是响应式的。若后面才添加一个新的property 1vm.b='h1' 那么对b的改动将不会触发任何视图的更新。若是知道后续是需要一个property，但一开始时它为空或不存在，则需要设置一些初始值以保证视图能同步更新： 1234567data&#123; newTodoText:'', visitVount:0, hideCompletedTodos:false, todos:[], error:null&#125; 使用Object.freeze()会阻止修改现有的property，也意味着响应系统无法再追踪其变化： 12345&lt;div id=\"app-8\"&gt; &lt;p&gt;&#123;&#123;foo&#125;&#125;&lt;/p&gt; &lt;!--这里的foo不会更新！--&gt; &lt;button v-on:click=\"foo = 'baz'\"&gt;Change it &lt;/button&gt;&lt;/div&gt; 123456789 var obj=&#123; foo:'bar' &#125;Object.freeze(obj) var app8=new Vue(&#123; el:'#app-8', data:obj &#125;) 除了数据property，Vue实例还暴露了一些有用的实例property与方法。它们都有前缀$，以便与用户定义的property区分开来： 123456vm.$data===data//返回truevm.$el===document.getElementById('example')//返回true$watch是一个实例方法vm.$watch('a',function(newValue,oldValue)&#123; //这个回调将在'vm.a'改变后调用&#125;) 实例生命周期钩子 每个Vue实例在被创建时都要经过一系列的初始化过程，如设置数据监听、编译模板、将实例挂载到DOM并在数据变化时更新DOM等。同时在这个过程中也会运行一些名为生命周期钩子的函数。 如created钩子可以用来在一个实例被创建之后执行代码： 123456789 new Vue(&#123; data:&#123; a:1 &#125;, created:function()&#123; console.log('a is: '+this.a) &#125; &#125;)//返回a is: 1 也有一些其他的钩子，在实例生命周期的不同阶段被调用，如mounted、updated和destroyed。生命周期钩子的this上下文指向调用它的Vue实例。 注意：不要在选项property或回调上使用箭头函数，如created:()=&gt;console.log(this.a)或是vm.$watch('a',newValue=&gt;this.myMethod())。因为箭头函数并没有this，this作为变量一直向上级词法作用域查找，直至找到为止，经常会报错。 生命周期图示","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"前端框架","slug":"前端框架","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://tangmenjue.top/tags/Vue-js/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端三件套之JavaScript（三）","slug":"前端三件套之JavaScript（三）","date":"2022-11-01T09:33:51.000Z","updated":"2022-11-10T15:49:20.837Z","comments":true,"path":"2022/11/01/前端三件套之JavaScript（三）/","link":"","permalink":"http://tangmenjue.top/2022/11/01/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97%E4%B9%8BJavaScript%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"标准对象 在JavaScript的世界里，一切皆是对象。但某些对象与其他对象不太一样。为了区分对象的类型，通常用typeof操作符获取对象的类型： 123456789101112131415161718192021console.log(typeof 123);console.log(typeof NaN);console.log(typeof 'str');console.log(typeof true);console.log(typeof undefined);console.log(typeof Math.abs);console.log(typeof null);console.log(typeof []);console.log(typeof &#123;&#125;);/*运行结果如下：numbernumberstringbooleanundefinedfunctionobjectobjectobject*/ 注意，null、Array的类型都是object，若用typeof将无法区分出null、Array和object。 包装对象 除了这些类型外，JavaScript还提供了包装对象。Number、boolean和string都有包装对象。包装对象用new创建： 1234567891011var n=new Number(123);var b=new Boolean(true);var s=new String('str');console.log(n);console.log(b);console.log(s);/*运行结果如下：Number (123)Boolean (true)String ('str')*/ 虽然包装对象看上去和原来的值一样，但类型已经变为object了，用===与原始值比较会返回false： 1234567891011var n=new Number(123);var b=new Boolean(true);var s=new String('str');console.log(n===123);console.log(b===true);console.log(s==='str');/*运行结果如下：falsefalsefalse*/ 因此，要注意以下几点： 不要使用new Number()、new Boolean()、new String()创建包装对象 用parseInt()或parseFloat()来转换任意类型的number 用Sting()来转换任意类型到string，或直接调用某个对象的toString()方法，只有null和undedined没有toString()方法，number对象调用toString()要写成：123..toString();或(123).toStirng(); 通常不用把任意类型转换为boolean再判断 用typeof可以判断出number、boolean、string、function和undefined 判断Array要用Array.isArray(arr) 判断null要用myvar===null 判断某个全局变量是否存在用typeof window.myvar==='undefined' 函数内部判断某个变量是否存在用typeof myvar==='undefined' Date 在JavaScript里，Date对象用来表示日期和时间。 用Date获取系统时间： 123456789101112131415161718192021222324var now=new Date();console.log(now);//显示当前的时间console.log(now.getFullYear());//显示今年console.log(now.getMonth());//显示这个月，月份范围是0~11，10表示11月console.log(now.getDate());//显示今天多少号console.log(now.getDay());//显示今天星期几console.log(now.getHours());//显示现在几时，24小时制console.log(now.getMinutes());//显示现在是多少分钟console.log(now.getSeconds());//显示现在是多少秒console.log(now.getMilliseconds());//显示现在是多少毫秒console.log(now.getTime());//以number形式表示的时间戳/*运行结果如下：Tue Nov 01 2022 11:01:14 GMT+0800 (中国标准时间)20221012111142171667271674217*/ 当前时间是浏览器从本机操作系统获取的时间所以不一定准确。 若要创建一个指定日期和时间的Date对象，可以用： 12345var d=new Date(2015,5,19,20,15,30,123);console.log(d);/*运行结果如下：Fri Jun 19 2015 20:15:30 GMT+0800 (中国标准时间)*/ 第二种创建一个指定日期和时间的方法是解析一个符号ISO 8601格式的字符串： 12345678var d=Date.parse('2015-06-24T19:49:22.875+08:00');console.log(d);//返回时间戳var dd=new Date(d)//时间戳转Dateconsole.log(dd);/*运行结果如下：1435146562875Wed Jun 24 2015 19:49:22 GMT+0800 (中国标准时间)*/ 时区 Date对象表示的时间总是按浏览器所在时区显示的，不过既可以显示本地时间，也可以显示调整后的UTC时间： 12345678910var d=Date.parse('2015-06-24T19:49:22.875+08:00');console.log(d);var dd=new Date(d)console.log(dd.toLocaleString());//显示的字符串与操作系统设定的格式有关console.log(dd.toUTCString());//UTC时间与本地时间相差8小时/*运行结果如下：14351465628752015/6/24 19:49:22Wed, 24 Jun 2015 11:49:22 GMT*/ 获取当前时间戳： 12345678if(Date.now)&#123; console.log(Date.now());&#125;else&#123;//老版本IE没有now()方法 console.log(new Date().getTime());&#125;/*运行结果如下：1667272652007*/ 练习题 小明为了和女友庆祝情人节，特意制作了网页，并提前预定了法式餐厅。小明打算用JavaScript给女友一个惊喜留言,结果女友并未出现。小明非常郁闷，请你帮忙分析他的JavaScript代码有何问题： 1234var today = new Date();if (today.getMonth() === 2 &amp;&amp; today.getDate() === 14) &#123; alert('亲爱的，我预定了晚餐，晚上6点在餐厅见！');&#125; 修改后的代码如下： 12345//分析：JavaScript中getMonth() 实际时间为0~11，数值为2时，实际月份为3。var today = new Date();if (today.getMonth() === 1 &amp;&amp; today.getDate() === 14) &#123; alert('亲爱的，我预定了晚餐，晚上6点在餐厅见！');&#125; RegExp JavaScript有两种方式创建一个正则表达式： 第一种是直接通过/正则表达式/写出来，第二种是通过new RegExp(正则表达式)创建一个RegExp对象。 12345678var re1=/ABC\\-001/;var re2=new RegExp('ABC\\\\-001');console.log(re1);console.log(re2);/*运行结果如下：/ABC\\-001//ABC\\-001/*/ 判断正则表达式是否匹配： 123456789var re=/^\\d&#123;3&#125;\\-\\d&#123;3,8&#125;$/;console.log(re.test('010-12345'));console.log(re.test('010-1234x'));console.log(re.test('010 12345'));/*运行结果如下：truefalsefalse*/ 切分字符串 用正则表达式切分字符串： 1234console.log('a b c , ; ; d'.split(/[\\s\\,\\;]+/));/*运行结果如下：(4) ['a', 'b', 'c', 'd']*/ 分组 正则表达式用()表示要提取的分组，可以提取子串。若正则表达式种定义了组，就可以在RegExp对象上用exec()方法提取出子串来： 1234567var re=/^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$/;console.log(re.exec('010-12345'));console.log(re.exec('010 12345'));/*运行结果如下：(3) ['010-12345', '010', '12345', index: 0, input: '010-12345', groups: undefined]null*/ exec()方法在匹配成功后会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。在匹配失败是返回null。 正则表达式可以直接识别合法的世界，但无法做到完全识别日期： 12345678var re1=/^(0[0-9]|1[0-9]|2[0-3]|[0-9])\\:(0[0-9]|1[0-9]|2[0-0]|3[0-9]|4[0-9]|5[0-9]|[0-9])\\:(0[0-9]|1[0-9]|2[0-0]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;console.log(re1.exec('11:43:59'));var re2=/^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/;console.log(re2.exec('2-30'));//2-30号不存在，应该返回null/*运行结果如下：(4) ['11:43:59', '11', '43', '59', index: 0, input: '11:43:59', groups: undefined](3) ['2-30', '2', '30', index: 0, input: '2-30', groups: undefined]*/ 贪婪匹配 正则匹配默认是贪婪匹配。在需要培贪婪匹配的语句后加问号?，可以让该语句采用非贪婪匹配。 全局搜索 JavaScript的正则表达式有几个特殊的标志，最常用的是全局匹配g： 1234567891011121314151617181920212223242526var s='JavaScript,VBScript,JScript and ECMAScript';var re=/[a-zA-Z]+Script/g;//使用全局匹配console.log(re.exec(s));console.log(re.lastIndex);console.log(re.exec(s));console.log(re.lastIndex);console.log(re.exec(s));console.log(re.lastIndex);console.log(re.exec(s));console.log(re.lastIndex);console.log(re.exec(s));//直至结束都没有匹配到/*运行结果如下：(1) ['JavaScript', index: 0, input: 'JavaScript,VBScript,JScript and ECMAScript', groups: undefined]10(1) ['VBScript', index: 11, input: 'JavaScript,VBScript,JScript and ECMAScript', groups: undefined]19(1) ['JScript', index: 20, input: 'JavaScript,VBScript,JScript and ECMAScript', groups: undefined]27(1) ['ECMAScript', index: 32, input: 'JavaScript,VBScript,JScript and ECMAScript', groups: undefined]42null*/ JavaScript的正则表达式还可以指定i标志，表示忽略大小写；m标志表示执行多行匹配。 练习题 请尝试写一个验证Email地址的正则表达式。版本一应该可以验证出类似的Email： 12345678910111213141516171819202122232425262728var re = /^([a-z\\.0-9])+@+([a-z0-9]+\\.+[a-z]&#123;3&#125;)$/;// 测试:var i, success = true, should_pass = ['someone@gmail.com', 'bill.gates@microsoft.com', 'tom@voyager.org', 'bob2015@163.com'], should_fail = ['test#gmail.com', 'bill@microsoft', 'bill%gates@ms.com', '@voyager.org'];for (i = 0; i &lt; should_pass.length; i++) &#123; if (!re.test(should_pass[i])) &#123; console.log('测试失败: ' + should_pass[i]); success = false; break; &#125;&#125;for (i = 0; i &lt; should_fail.length; i++) &#123; if (re.test(should_fail[i])) &#123; console.log('测试失败: ' + should_fail[i]); success = false; break; &#125;&#125;if (success) &#123; console.log('测试通过!');&#125;/*运行结果如下：测试成功!*/ 版本二可以验证并提取出带名字的Email地址： 12345678910111213var re = /^&lt;?([a-zA-Z]+\\s?[a-zA-Z]+)&gt;?\\s?([a-zA-Z]*@[a-zA-Z]+\\.[a-zA-Z]+)$/;// 测试:var r = re.exec('&lt;Tom Paris&gt; tom@voyager.org');if (r === null || r.toString() !== ['&lt;Tom Paris&gt; tom@voyager.org', 'Tom Paris', 'tom@voyager.org'].toString()) &#123; console.log('测试失败!');&#125;else &#123; console.log('测试成功!');&#125;/*运行结果如下：测试成功!*/ JSON JSON是一种数据交换格式，字符集必须是UTF-8。为了统一解析，JSON的字符串规定必须用双引号\"\"，Object的键也必须用双引号\"\"。 JavaScript内置了JSON的解析，把任何JavaScript对象序列化成一个JSON格式的字符串，才能通过网络传递给其他计算机。 序列化 用JSON.stringify()把JavaScript对象序列化成JSON格式的字符串： 12345678910111213var person=&#123; name:'zhangsan', age:18, gender:true, height:1.65, grade:null, 'middel-school':'No.1 Middle School', skills:['JavaScript','Java','Python','Lisp']&#125;;var s=JSON.stringify(person);console.log(s);/*运行结果如下：&#123;\"name\":\"zhangsan\",\"age\":18,\"gender\":true,\"height\":1.65,\"grade\":null,\"middel-school\":\"No.1 Middle School\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]&#125;*/ JSON.stringify()还可以通过参数来控制按缩进输出 1234567891011121314151617var s=JSON.stringify(person,null,' ');console.log(s);/*运行结果如下：&#123; \"name\": \"zhangsan\", \"age\": 18, \"gender\": true, \"height\": 1.65, \"grade\": null, \"middel-school\": \"No.1 Middle School\", \"skills\": [ \"JavaScript\", \"Java\", \"Python\", \"Lisp\" ]&#125;*/ 其第二个参数用于控制如何筛选对象的键值，如： 123456789101112var s=JSON.stringify(person,['name','skills'],' ');console.log(s);/*运行结果如下：&#123; \"name\": \"zhangsan\", \"skills\": [ \"JavaScript\", \"Java\", \"Python\", \"Lisp\" ]&#125;*/ 还可以往第二个参数里传入一个函数，使得对象的每个键值对都会被函数先处理： 123456789101112131415161718192021222324function convert(key,value)&#123; if(typeof value==='string')&#123; return value.toUpperCase(); &#125; return value;&#125;var s=JSON.stringify(person,['name','skills'],' ');console.log(s);/*运行结果如下：E:\\node.exe .\\test.js&#123; \"name\": \"ZHANGSAN\", \"age\": 18, \"gender\": true, \"height\": 1.65, \"grade\": null, \"middel-school\": \"NO.1 MIDDLE SCHOOL\", \"skills\": [ \"JAVASCRIPT\", \"JAVA\", \"PYTHON\", \"LISP\" ]&#125;*/ 除此之外，还可以给person对象定义一个toJSON()的方法，直接返回序列化数据： 12345678910111213141516171819var person=&#123; name:'zhangsan', age:18, gender:true, height:1.65, grade:null, 'middel-school':'No.1 Middle School', skills:['JavaScript','Java','Python','Lisp'], toJSON:function()&#123; return&#123; 'Name':this.name, 'Age':this.age &#125;; &#125;&#125;;var s=JSON.stringify(person);console.log(s);/*运行结果如下：&#123;\"Name\":\"zhangsan\",\"Age\":18&#125;*/ 反序列化 把一个JSON格式的字符串，用JSON.parse()把它变成一个JavaScript对象： 123456789console.log(JSON.parse('[1,2,3,true]'));console.log(JSON.parse('&#123;\"name\":\"zhangsan\",\"age\":14&#125;'));console.log(JSON.parse('true'));console.log(JSON.parse('123.45'));/*运行结果如下：(4) [1, 2, 3, true]&#123;name: 'zhangsan', age: 14&#125;true123.45*/ JSON.parse()还可以接收一个函数，用来转换解析出的属性： 123456789var obj=JSON.parse('&#123;\"name\":\"zhangsan\",\"age\":14&#125;',function(key,value)&#123; if (key==='name')&#123; return value+' classmate'; &#125; return value;&#125;);console.log(JSON.stringify(obj));/*运行结果如下：&#123;\"name\":\"zhangsan classmate\",\"age\":14&#125;*/ 面向对象编程 在JavaScript种不区分类和实例的概念，而是通过原型(prototype)来实现面向对象编程。所谓的继承关系是把对象的原型指向另一个对象。 以下是创建原型继承的一种方法： 123456789101112131415161718var Student=&#123; name:'Robot', heighe:1.2, run:function()&#123; console.log(this.name+' is running...'); &#125;&#125;;function createStudent(name)&#123; var s=Object.create(Student); s.name=name; return s;&#125;var zhangsan=createStudent('ZhangSan');zhangsan.run();console.log(zhangsan.__proto__===Student);/*运行结果如下：ZhangSan is running...true*/ 创建对象 除了直接用{...}创建一个对象外，JavaScript还可以用构造函数的方法来创建对象： 1234567891011121314//定义构造函数function Student(name)&#123; this.name=name; this.hello=function()&#123; console.log('Hello, '+this.name+'!'); &#125;&#125;//调用构造函数，返回一个对象var zhangsan=new Student('ZhangSan');console.log(zhangsan.name);zhangsan.hello();/*运行结果如下：ZhangSanHello, ZhangSan!*/ 注意：若不写new，student就是一个普通函数，它返回undefined，若写了new，student就是一个构造函数，它绑定的this指向新创建的对象，并默认返回this。 用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身： 12345678console.log(zhangsan.constructor===Student.prototype.constructor);console.log(Student.prototype.constructor===Student);console.log(Object.getPrototypeOf(zhangsan)===Student.prototype);/*运行结果如下：truetruetrue*/ 上述代码主要描述以下关系： 若要让通过构造函数创建的对象共享一个hello函数，将函数放到这些对象共同的原型Student.prototype上即可： 1234567891011function Student(name)&#123; this.name=name;&#125;Student.prototype.hello=function()&#123; console.log('Hello, '+this.name+'!');&#125;;var zhangsan=new Student('ZhangSan');zhangsan.hello();/*运行结果如下：Hello, ZhangSan!*/ 构造函数的首字母应当大写，普通函数首字母应当小写。 可以编写一个函数，在内部封装所有的new操作： 123function createStudent(props)&#123; return new Student(props||&#123;&#125;)&#125; 练习题 请利用构造函数定义Cat，并让所有的Cat对象有一个name属性，并共享一个方法say()，返回字符串'Hello, xxx!'： 12345678910111213141516171819202122function Cat(name) &#123; this.name=name;&#125;Cat.prototype.say=function()&#123; return 'Hello, '+this.name+'!';&#125;// 测试:var kitty = new Cat('Kitty');var doraemon = new Cat('哆啦A梦');if (kitty &amp;&amp; kitty.name === 'Kitty' &amp;&amp; kitty.say &amp;&amp; typeof kitty.say === 'function' &amp;&amp; kitty.say() === 'Hello, Kitty!' &amp;&amp; kitty.say === doraemon.say) &#123; console.log('测试通过!');&#125; else &#123; console.log('测试失败!');&#125;/*运行结果如下：测试通过!*/ 原型继承 JavaScript的原型继承实现方式为： 定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this； 借助中间函数F实现原型链继承，最好通过封装的inherits函数完成； 继续在新的构造函数原型上定义新方法。 现有一构造函数Student： 1234567//Student的构造函数function Student(props)&#123; this.name=props.name||'Unnamed';&#125;Student.prototype.hello=function()&#123; console.log('Hello, '+this.name+'!');&#125; Student的原型链如下： 现在要基于Student扩展出PrimaryStudent。因此先定义新的构造函数PrimaryStudent： 12345//新构造函数function PrimaryStudent(props)&#123; Student.call(this.props); this.grade=props.grade||1;&#125; 利用空函数F来修改原型链，使得PrimaryStudent指向Student.prototype： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Student的构造函数function Student(props)&#123; this.name=props.name||'Unnamed';&#125;Student.prototype.hello=function()&#123; console.log('Hello, '+this.name+'!');&#125;//新构造函数PrimaryStudentfunction PrimaryStudent(props)&#123; Student.call(this,props);//调用Student构造函数，绑定this变量 this.grade=props.grade||1;&#125;//空函数Ffunction F()&#123;&#125;F.prototype=Student.prototype;//将F的原型指向Student.prototypePrimaryStudent.prototype=new F();//将PrimaryStudent的原型指向一个新的F对象PrimaryStudent.prototype.constructor=PrimaryStudent;//将PrimaryStudent原型的构造函数指向PrimaryStudentPrimaryStudent.prototype.getGrade=function()&#123;//在PrimaryStudent原型的构造函数上定义方法 return this.grade;&#125;;var lisi=new PrimaryStudent(&#123;//创建lisi name:'lisi', grade:3&#125;);console.log(lisi.name);console.log(lisi.grade);//验证原型console.log(lisi.__proto__===PrimaryStudent.prototype);console.log(lisi.__proto__.__proto__===Student.prototype);//验证继承关系console.log(lisi instanceof PrimaryStudent);console.log(lisi instanceof Student);/*运行结果如下：lisi3truetruetruetrue*/ 此时的新型原型链如下： 如果把整个继承动作用一个inherits()函数封装起来，还可以隐藏空函数F的定义，inherits()函数可以复用： 123456789101112131415161718192021222324252627282930313233//Student的构造函数function Student(props)&#123; this.name=props.name||'Unnamed';&#125;Student.prototype.hello=function()&#123; console.log('Hello, '+this.name+'!');&#125;//新构造函数PrimaryStudentfunction PrimaryStudent(props)&#123; Student.call(this,props);//调用Student构造函数，绑定this变量 this.grade=props.grade||1;&#125;function inherits(Child,Parent)&#123; var F=function()&#123;&#125;; F.prototype=Parent.prototype; Child.prototype=new F(); Child.prototype.constructor=Child;&#125;inherits(PrimaryStudent,Student);//实现原型继承链PrimaryStudent.prototype.getGrade=function()&#123;//绑定其他方法到PrimaryStudent原型 return this.grade;&#125;;var lisi=new PrimaryStudent(&#123;//创建lisi name:'lisi', grade:3&#125;);console.log(lisi.name);console.log(lisi.grade);/*运行结果如下：lisi3*/ class继承 class定义 ES6中引入了新的关键字class，使类的定义更简单。 用class定义Student类并创建一个对象如下： 12345678910111213class Student&#123; constructor(name)&#123; this.name=name; &#125; hello()&#123; console.log('Hello, '+this.name+'!'); &#125;&#125;var lisi=new Student('Lisi');lisi.hello();/*运行结果如下：Hello, Lisi!*/ 原型继承 可以通过extends实现原型继承： 12345678910111213141516171819202122232425class Student&#123; constructor(name)&#123; this.name=name; &#125; hello()&#123; console.log('Hello, '+this.name+'!'); &#125;&#125;class PrimaryStudent extends Student&#123; constructor(name,grade)&#123; super(name);//用super调用父类的构造方法 this.grade=grade; &#125; myGrade()&#123; console.log('I am at grade '+this.grade); &#125;&#125;var lisi=new PrimaryStudent('Lisi',3);lisi.hello();lisi.myGrade();/*运行结果如下：Hello, Lisi!I am at grade 3*/ 不是所有的浏览器都支持ES6的class，当浏览器不支持时，需要Babel这个工具把class代码转换为传统的prototype代码。 练习题 请利用class重新定义Cat，并让它从已有的Animal继承，然后新增一个方法say()，返回字符串'Hello, xxx!'： 1234567891011121314151617181920212223242526272829303132class Animal &#123; constructor(name) &#123; this.name = name; &#125;&#125;class Cat extends Animal&#123; constructor(name)&#123; super(name); &#125; say()&#123; return 'Hello, '+this.name+'!'; &#125;&#125;// 测试:var kitty = new Cat('Kitty');var doraemon = new Cat('哆啦A梦');if ((new Cat('x') instanceof Animal) &amp;&amp; kitty &amp;&amp; kitty.name === 'Kitty' &amp;&amp; kitty.say &amp;&amp; typeof kitty.say === 'function' &amp;&amp; kitty.say() === 'Hello, Kitty!' &amp;&amp; kitty.say === doraemon.say)&#123; console.log('测试通过!');&#125; else &#123; console.log('测试失败!');&#125;/*运行结果如下：测试通过!*/ 浏览器 目前主流的浏览器分为以下几种： IE6-11：国内用的最多的IE浏览器，从IE10开始支持ES6标准 Chrome：Google出品的基于Webkit内核浏览器，由于Chrome一经安装就时刻保持自升级，因此不用管它的版本，最新版肯定支持ES6 Safari：Apple的Mac系统自带的基于Webkit内核浏览器，从OSX 10.7 Lion自带的6.1版本开始支持ES6 Firefox：Mozilla自研的Gecko内核，也是时刻保持自升级。 移动设备上目前IOS和Android两大阵营分别主要使用Apple的Safari和Google的Chrome，两种都是Webkit核心，最新版本均支持ES6 浏览器对象 JavaScript可以获取浏览器提供的很对对象，并进行操作。 window window对象不但充当全局作用域，而且表示浏览器窗口。 window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指出去菜单栏、工具栏、边框等占位元素后，用于显示页面的净宽高。IE&lt;=8版本的浏览器不支持这一特性： 1234console.log('window inner size: '+window.innerWidth+'x'+window.innerHeight);/*运行结果如下：window inner size: 987x752*/ 与之对应的，还有一个outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。 navigator navigator对象表示浏览器的信息，最常用的属性包括： navigator.appName：浏览器名称 navigator.appVersion：浏览器版本 navigator.language：浏览器设置的语言 navigator.platform：操作系统类型 navigator.userAgent：浏览器设定的user-Agent字符串 12345678910111213141516console.log('appName='+navigator.appName);console.log('appVersion='+navigator.appVersion);console.log('language='+navigator.language);console.log('platform='+navigator.platform);console.log('userAgent='+navigator.userAgrnt);/*运行结果如下：appName=NetscapeUsers/Administrator/Desktop/test.js:1appVersion=5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.26Users/Administrator/Desktop/test.js:2language=zh-CNUsers/Administrator/Desktop/test.js:3platform=Win32Users/Administrator/Desktop/test.js:4userAgent=undefined*/ 注意，由于navigator的信息很容易被用户修改，所以常用JavaScript对不存在属性返回unfinded的特性，计算浏览器的信息是否又被改动： 1var width=window.innerWith||document.body.clientWidth; screen screen对象表示屏幕的信息，常用的属性有： screen.width：屏幕宽度，以像素为单位 screen.height：屏幕高度，以像素为单位 sreen.colorDepth：返回颜色位数，如8、16、24 1234console.log('Screen size='+screen.width+'x'+screen.height);/*运行结果如下：Screen size=1440x900*/ location location对象表示当前页面的URL信息。一个完整的URL可以用location.href获取。要获取URL各部分的值，可以这么写： 123456789101112131415//如URL：http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOPconsole.log(location.protocol);console.log(location.host);console.log(location.post);console.log(location.pathname);console.log(location.search);console.log(location.hash);/*运行结果如下：httpwww.example.com8080/path/index.htmla=1&amp;b=2TOP*/ 要加载一个新页面，可以调用location.assign()方法，要重新加载当前页面，可以调用location.reload()方法： 12345if(confirm('要重新加载当前页'+location.href+'?'))&#123; location.reload();&#125;else&#123; location.assign('/');//设置一个新的URL地址&#125; document document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。 document的title属性是从HTML文档中的&lt;title&gt;...&lt;/title&gt;读取的，但其也可以动态改变： 1document.title='helloJavaScript!';//修改浏览器窗口标题 若要查找DOM树的某个节点，需要从document对象开始查找。最常用的方法是根据ID和Tag Name。 有一HTML数据如下： 12345678&lt;dl id=\"drink-menu\" style=\"border:solid 1px #ccc;padding:6px;\"&gt; &lt;dt&gt;摩卡&lt;/dt&gt; &lt;dd&gt;热摩卡咖啡&lt;/dd&gt; &lt;dt&gt;酸奶&lt;/dt&gt; &lt;dd&gt;北京老酸奶&lt;/dd&gt; &lt;dt&gt;果汁&lt;/dt&gt; &lt;dd&gt;鲜榨苹果汁&lt;/dd&gt;&lt;/dl&gt; 用document对象提供的getElementById()和getElementsByTagName()可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点： 1234567891011var menu=document.getElementById('drink-menu');var drinks=document.getElementsByTagName('dt');var i,s;s='提供的饮料有：';for(i=0;i&lt;drinks.length;i++)&#123; s=s+drinks[i].innerHTNL+',';&#125;console.log(s);/*运行结果如下：提供的饮料有:摩卡,酸奶,果汁,*/ document对象还有一个cookie属性，可以获取当前页面的Cookie： 1console.log(document.cookie); 由于JavaScript能读到页面的Cookie，而用户的登录信息通常也存在Cookie中，且HTML页面中允许引入第三方的JavaScript代码。为了防止第三方的JavaScript直接能获取网站的用户登录信息，服务器在设置Cookie时可以使用httpOnly，以防止被JavaScript读取。IE浏览器从IE6 SP1开始支持。 history history对象保持了浏览器的历史记录，JavaScript可以调用history对象的back()或forward()，相当于用户点击了浏览器的后退或前进按钮。在任何情况都不应该使用history这个对象。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://tangmenjue.top/tags/JavaScript/"}]},{"title":"前端三件套之JavaScript（二）","slug":"前端三件套之JavaScript（二）","date":"2022-10-31T13:26:15.000Z","updated":"2022-11-10T15:49:25.342Z","comments":true,"path":"2022/10/31/前端三件套之JavaScript（二）/","link":"","permalink":"http://tangmenjue.top/2022/10/31/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97%E4%B9%8BJavaScript%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"函数 函数定义和调用 定义函数 在JavaScript中，定义函数的方式如下： 1234567function abs(x)&#123; if(x&gt;=0)&#123; return x; &#125;else&#123; return -x; &#125;&#125; 函数内的语句执行到return语句时，函数便执行完毕了。若没有return语句，函数执行完毕后会返回undefined。 由于函数也是一个对象，因此上述定义的abs()函数实际上是一个函数对象，因此，第二种定义函数的方式如下： 1234567var abs=function(x)&#123; if(x&gt;=0)&#123; return x; &#125;else&#123; return -x; &#125;&#125;; 这两种定义完全等价，注意第二种方式函数体末尾要加上一个分号;，表示赋值语句结束。 调用函数 调用函数时，需要按顺序传入参数： 12abs(18);abs(-231); 由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也不会报错： 12abs(12,'sdada');//返回12abs(-123,'asd','asd',null);//返回123 传入的参数比定义的少也不会报错： 1abs();//abs()收到参数undefined，返回NaN 若要避免收到undefined，可以对参数进行检查： 12345678910function abs(x)&#123; if(typeof x!=='number')&#123; throw 'Not a number'; &#125; if(x&gt;=0)&#123; return x; &#125;else&#123; return -x; &#125;&#125; arguments arguments只在函数内部起作用，并且永远指向当前函数的调用者所传入的所有参数。arguments类似于Array但不是一个Array。 12345678910111213function foo(x)&#123; console.log('x='+x); for(var i=0;i&lt;arguments.length;i++)&#123; console.log('arg'+i+'='+arguments[i]); &#125;&#125;foo(10,20,30);/*运行结果如下：x=10arg0=10arg1=20arg2=30*/ 利用arguments可以获得调用者传入的所有参数，即使函数不定义任何参数值，可还是能拿到参数的值： 123456789101112131415function abs()&#123; if(arguments.length===0)&#123; return 0; &#125; var x=arguments[0]; return x&gt;=0?x:-x;&#125;console.log(abs());console.log(abs(12));console.log(abs(-12));/*运行结果如下：01212*/ arguments常用于判断传入参数的个数： 1234567//foo(a,[,b],c)接收2~3个参数，b是可选参数。若只传入2个参数，b默认为bullfunction foo(a,b,c)&#123; if(arguments.length===2)&#123; c=b; b=null; &#125;&#125; rest参数 ES6标准引入了rest参数以帮助获得除了已定义参数之外的参数。 123456789101112131415function foo(a,b,...rest)&#123; console.log('a='+a); console.log('b='+b); console.log(rest);&#125;foo(1,2,3,4,5);foo(1);/*运行结果如下：a=1b=2(3) [3, 4, 5]a=1b=undefined(0) []*/ rest参数只能写在最后，前面用...标识。若传入的参数少于定义参数，rest参数会接收一个空数组。 由于rest参数是ES6新标准，因此需要测试浏览器是否支持。请用rest参数编写的一个sum()函数，接收任意个参数并返回它们的和。 代码如下： 1234567891011121314151617181920212223242526272829function sum(...rest)&#123; var sum=0; if(rest.length===0)&#123; return 0; &#125; for (var i=0;i&lt;rest.length;i++)&#123; sum=sum+rest[i]; &#125; return sum;&#125;// 测试:var i, args = [];for (i=1; i&lt;=100; i++) &#123; args.push(i);&#125;if (sum() !== 0) &#123; console.log('测试失败: sum() = ' + sum());&#125; else if (sum(1) !== 1) &#123; console.log('测试失败: sum(1) = ' + sum(1));&#125; else if (sum(2, 3) !== 5) &#123; console.log('测试失败: sum(2, 3) = ' + sum(2, 3));&#125; else if (sum.apply(null, args) !== 5050) &#123; console.log('测试失败: sum(1, 2, 3, ..., 100) = ' + sum.apply(null, args));&#125; else &#123; console.log('测试通过!');&#125;/*运行结果如下：测试通过!*/ JavaScript引擎有一个再行末自动添加分号的机制，因此要注意return语句不要轻易换行。若要换行写，可以写成以下形式： 12345function foo()&#123; return&#123; name:'foo' &#125;;&#125; 练习题 定义一个计算圆面积的函数area_of_circle()，它有两个参数： r: 表示圆的半径； pi: 表示π的值，如果不传，则默认3.14 1234567891011121314151617'use strict';function area_of_circle(r, pi) &#123; if (arguments.length===1)&#123; pi=3.14; &#125; return pi*r*r;&#125;// 测试:if (area_of_circle(2) === 12.56 &amp;&amp; area_of_circle(2, 3.1416) === 12.5664) &#123; console.log('测试通过');&#125; else &#123; console.log('测试失败');&#125;/*测试通过*/ 小明是一个JavaScript新手，他写了一个max()函数，返回两个数中较大的那个。但是小明抱怨他的浏览器出问题了，无论传入什么数，max()函数总是返回undefined。请帮他指出问题并修复： 123456789101112'use strict';function max(a, b) &#123; if (a &gt; b) &#123; return a; &#125; else &#123; return b; &#125;&#125;console.log(max(15, 20)); 修复后的代码如下： 12345678910'use strict';function max(a, b) &#123; if (a &gt; b) &#123; return a; &#125; else &#123; return b; &#125;&#125;console.log(max(15, 20)); 变量作用域与解构赋值 若一个变量再函数体内部声明，则该变量的作用域为整个函数体，在函数体外不可引用该变量。 若两个不同的函数各自声明了同一个变量，则该变量只在各自的函数体内其作用。 由于JavaScript的函数可以嵌套，此时内部函数可以访问外部函数定义的变量，而外部函数无法访问内部函数定义的变量。 若内部函数和外部函数的变量名重名时，内部函数的变量将忽略外部函数的变量。 变量提升 JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有声明的变量“提升”到函数顶部。只提升变量的声明，不会提升变量的赋值。 12345678910111213141516function foo()&#123; var x='Hello，'+y; console.log(x); var y='Bob';&#125;foo();//等同于function foo()&#123; var y; var x='Hello，'+y; console.log(x); var y='Bob';&#125;/*运行结果如下：Hello,undefined*/ 因此，为了防止不必要的错误，在函数内部定义变量时，首先声明所有变量。 全局作用域 不在任何函数内的变量便处于全局作用域中。JavaScript默认有一个全局对象window，全局作用域的百年来实际上被绑定到window属性中。 123var a='asd';alert(a);//弹出asd弹窗alert(window.a);//弹出asd弹窗 由于函数定义有两种方式，以变量形式定义的函数var foo=function(){}也是一个全局变量。此时函数的定义也被视为一个全局变量，并绑定到window对象中。alert函数也是window的一个变量。 名字空间 全局变量会绑定到window上，不同的JavaScript文件若使用了相同的全局变量，或定义了相同名字的顶层函数，就会造成命名冲突，且这种错误很难被发现。 减少冲突的方法就是把自己的所有变量和函数全部绑定到一个全局变量中，即把代码全部放入唯一的名字空间中MYAPP： 123456789//唯一的全局变量var MYAPP=&#123;&#125;;//其他变量MYAPP.name='myapp';MYAPP.version=1.0;//其他函数MYAPP.foo=function()&#123; return 'foo';&#125; 局部作用域 由于JavaScript的变量作用域实际上是函数内部，故for循环等语句块是无法定义具有局部作用域的变量的。 123456function foo()&#123; for(var i=0;i&lt;100;i++)&#123; // &#125; i+=100//仍然可以引用变量i&#125; ES6引入了let关键字，用let替代var可以声明一个块级作用域的变量： 1234567function foo()&#123; var sum=0; for(let i=0;i&lt;100;i++)&#123; sum=sum+i; &#125; i+=100//报错ReferenceError: i is not defined&#125; 常量 由于var和let声明的是变量，在ES6后，若要声明一个常量，可以通过关键字const来定义，常量名要全部大写。const于let都具有块级作用域： 123const PI=3.14;PI=3;//报错TypeError: Assignment to constant variable.，某些浏览器不报错，但是无效果console.log(PI); 解构赋值 在ES6中，可以使用解构赋值来直接对多个变量同时赋值： 12345var[x,y,z]=['hello','JavaScript','ES6'];console.log('x='+x+', y='+y+', z= '+z);/*运行结果如下：x=hello, y=JavaScript, z= ES6*/ 对数组元素进行结构赋值时，多个变量要用[]括起来。 若数组本身还有嵌套，也可以通过下面的形式进行解构赋值，嵌套层次和位置要保持一致： 12345let [x,[y,z]]=['hello',['JavaScript','ES6']];console.log('x='+x+', y='+y+', z= '+z);/*运行结果如下：x=hello, y=JavaScript, z= ES6*/ 解构赋值还可以忽略某些元素： 12345let [,,z]=['hello','JavaScript','ES6'];console.log('z='+z);/*运行结果如下：z=ES6*/ 若要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性： 123456789101112var person=&#123; name:'zhangsan', age:13, gender:'male', passport:'G-12345678', school:'No.1 middle school'&#125;;var&#123;name,age,passport&#125;=person;console.log('name='+name+', age='+age+', passport'+passport);/*运行结果如下：name=zhangsan, age=13, passportG-12345678*/ 对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，主要要保证对应的层次一致： 1234567891011121314151617var person=&#123; name:'zhangsan', age:13, gender:'male', passport:'G-12345678', school:'No.1 middle school', address:&#123; city:'Beijing', street:'No.1 Road', zipcode:'100001' &#125;&#125;;var&#123;name,address:&#123;city,zip,zipcode&#125;&#125;=person;//person中没有zip属性，故其值为undefinedconsole.log('name='+name+', city='+city+', zip='+zip+', zipcode='+zipcode);/*运行结果如下：name=zhangsan, city=Beijing, zip=undefined, zipcode=100001*/ 使用解构赋值对对象属性进行赋值时，若对应的属性不存在，变量将被赋值为undefined，若要使用的变量名和属性名不一致，可以用下面的语法获取： 123456789101112var person=&#123; name:'zhangsan', age:13, gender:'male', passport:'G-12345678', school:'No.1 middle school',&#125;;let&#123;name,passport:id&#125;=person;console.log('name='+name+', id='+id);/*运行结果如下：name=zhangsan, id=G-12345678*/ 解构赋值还可以使用默认值，这样避免了不存在的属性返回undefined值： 123456789101112var person=&#123; name:'zhangsan', age:13, gender:'male', passport:'G-12345678', school:'No.1 middle school',&#125;;var&#123;name,single=true&#125;=person;//若person对象没有single属性，则默认返回trueconsole.log('name='+name+', single='+single);/*运行结果如下：name=zhangsan, single=true*/ 若变量已经被声明了，再次赋值时，正确的写法也会报语法错误： 1234var x,y;&#123;x,y&#125;=&#123;name:'zhangsan',x:10,y:200&#125;;//报错SyntaxError: Unexpected token '='// (&#123;x,y&#125;=&#123;name:'zhangsan',x:10,y:200&#125;);//返回x=10, y=200console.log('x='+x+', y='+y); 使用场景 解构赋值在很多时候可以简化代码，如：无需临时变量交换两个变量的值： 12var x=1,y=2;[x,y]=[y,x]; 快速获取当前页面的域名和路径： 1var&#123;hostname:domain,pathname:path&#125;=location; 若一个函数接收一个对象作为参数，那么使用解构直接把对象的属性绑定到变量中，如快速创建一个Date对象： 123function buildDate(&#123;year,month,dat,hour=0,minute=0,second=0&#125;)&#123; return new Date(year+'-'+month+'-'+day+' '+hour+':'+minute+':'+second);&#125; 目前支持解构赋值的浏览器包括Chrome、Firefox、Edge等。 方法 在一个对象中绑定函数，称为这个对象的方法。在javaScript中，对象的定义为 1234567891011var person=&#123; name:'zhangsan', birth:1999, age:function()&#123; var y=new Date().getFullYear(); return y-this.birth; &#125;&#125;;console.log(person.age());/*运行结果如下：23*/ 这里的age()函数便是一个方法，在方法内部，this是一个特殊变量，它始终指向当前对象。若是单独调用函数，在函数内调用this，this指向全局变量。要保证this指向正确，必须用obj.xxx()的形式调用。 在strict模式下，函数的this指向undefined，在非strict模式下，函数的this指向全局对象window。 若要将方法重构，为了避免出错可先用that变量捕获this： 123456789101112131415var person=&#123; name:'zhangsan', birth:1999, age:function()&#123; var that=this; function getAgeFromBirth()&#123; var y=new Date().getFullYear(); return y-that.birth; &#125; return getAgeFromBirth(); &#125;&#125;console.log(person.age());/*运行结果如下：23*/ apply 若要指定函数的this指向哪个对象，可以用函数本身的apply方法。它接收两个参数，第一个参数是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 1234567891011121314151617function getAge()&#123; var y=new Date().getFullYear(); return y-this.birth;&#125;var person=&#123; name:'zhangsan', birth:1999, age:getAge&#125;;console.log(person.age());console.log(getAge());//单独调用getAge，this指向windowconsole.log(getAge.apply(person,[]));//apply将this指向person/*运行结果如下：23NaN23*/ 另一个与apply()类似的方法是call()，两者之间的唯一区别是： apply()把参数打包成Array后再传入 call()把参数按顺序传入 如要调用Math.max(3,5,4): 12345console.log(Math.max.apply(null,[3,5,4]));console.log(Math.max.call(null,3,5,4));/*运行结果如下：55*/ 装饰器 利用apply()可以动态改变函数的行为。即使是JavaScript的内置函数，也可以重新指向新的函数。如要统计代码调用了多少次parseInt()，可以将系统默认的parseInt()替换为新的可以统计多少次调用的parseInt()： 12345678910111213var count=0;var oldParseInt=parseInt;//保存原函数window.parseInt=function()&#123; count+=1; return oldParseInt.apply(null,arguments);//调用原函数&#125;// 测试:parseInt('10');parseInt('20');parseInt('30');console.log('count = ' + count); /*在浏览器中的运行结果如下：count = 3*/ 高阶函数 接收另一个函数作为参数的函数，称为高阶函数。 map/reduce map 若要将函数 \\[ f(x)=x^2 \\] 作用在数组[1,2,3,4,5,6,7,8,9]上，可用map实现： 12345678function pow(x)&#123; return x*x;&#125;var arr=[1,2,3,4,5,6,7,8,9];var results=arr.map(pow);console.log(results);/*运行结果如下：(9) [1, 4, 9, 16, 25, 36, 49, 64, 81]*/ map()传入的参数是函数对象本身。 用map，只需两行代码便可以把Array的所有数组转换为字符串： 1234var arr=[1,2,3,4,5,6,7,8,9];console.log(arr.map(String))/*运行结果如下：(9) ['1', '2', '3', '4', '5', '6', '7', '8', '9']*/ reduce Array的reduce()把函数作用在Array的[x1,x2,x3...]上，reduce()接收两个参数，reduce()把结果继续和序列的下一个元素做累计运算，即[x1,x2,x3].reduce(f)=f(f(x1,x2),x3) 对于一个Array求和，可以用reduce实现： 123456var arr=[1,3,5,7,9];console.log(arr.reduce(function(x,y)&#123; return x+y;&#125;));/*运行结果如下：25*/ 利用reduce()也可以把[1,3,5,7,9]变换成整数13579： 123456var arr=[1,3,5,7,9];console.log(arr.reduce(function(x,y)&#123; return x*10+y;&#125;));/*运行结果如下：13579*/ 练习题 利用reduce()求积： 1234567891011121314function product(arr) &#123; return arr.reduce(function(x,y)&#123; return x*y; &#125;);&#125;// 测试:if (product([1, 2, 3, 4]) === 24 &amp;&amp; product([0, 1, 2]) === 0 &amp;&amp; product([99, 88, 77, 66]) === 44274384) &#123; console.log('测试通过!');&#125;else &#123; console.log('测试失败!');&#125;/*运行结果如下：测试通过!*/ 不要使用JavaScript内置的parseInt()函数，利用map和reduce操作实现一个string2int()函数： 1234567891011121314151617181920212223242526function string2int(s) &#123; var arr=[]; for (var i of s)&#123; arr.push(i); &#125; return arr.map(function(x)&#123; return x*1; &#125;).reduce(function(x,y)&#123; return x*10+y; &#125;);&#125;// 测试:if (string2int('0') === 0 &amp;&amp; string2int('12345') === 12345 &amp;&amp; string2int('12300') === 12300) &#123; if (string2int.toString().indexOf('parseInt') !== -1) &#123; console.log('请勿使用parseInt()!'); &#125; else if (string2int.toString().indexOf('Number') !== -1) &#123; console.log('请勿使用Number()!'); &#125; else &#123; console.log('测试通过!'); &#125;&#125;else &#123; console.log('测试失败!');&#125;/*运行结果如下：测试通过!*/ 请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']。 123456789101112131415function normalize(arr) &#123; return arr.map(function(x)&#123; return x.slice(0,1).toUpperCase()+x.slice(1).toLowerCase(); &#125;)&#125;// 测试:if (normalize(['adam', 'LISA', 'barT']).toString() === ['Adam', 'Lisa', 'Bart'].toString()) &#123; console.log('测试通过!');&#125;else &#123; console.log(normalize(['adam', 'LISA', 'barT'])); console.log('测试失败!');&#125;/*运行结果如下：测试通过!*/ 小明希望利用map()把字符串变成整数，他写的代码很简洁： 1234var arr = ['1', '2', '3'];var r;r = arr.map(parseInt);console.log(r); 结果竟然是1, NaN, NaN，小明百思不得其解，请帮他找到原因并修正代码。 修正代码如下： 12345678var arr = ['1', '2', '3'];var r=[];r = arr.map(function(x)&#123; return parseInt(x);&#125;);console.log(r);/*运行结果如下：(3)[1, 2, 3]*/ filter filter用于过滤Array中的某些元素，返回剩下的元素，filter也只接收一个函数，filter把传入的函数依次作用于每个元素，然后根据返回值True or False来决定保留还是丢弃该元素。 如在一个Array中，删掉偶数，只保留奇数： 1234567var arr=[1,2,4,5,6,9,10,15];var r=arr.filter(function(x)&#123; return x%2!=0;&#125;);console.log(r);/*运行结果如下：(4) [1, 5, 9, 15]*/ 把一个Array中的空字符串删掉： 1234567var arr=['A','','B',null,undefined,'C',' '];var r=arr.filter(function(s)&#123; return s&amp;&amp;s.trim();&#125;);console.log(r);/*运行结果如下：(3) ['A', 'B', 'C']*/ 回调函数 filter()接收的回调函数，可以有多个参数。通常仅使用第一个参数来表示Array的某个元素。回调函数还可以接收另外两个参数来表示元素的位置和数组本身： 1234567891011121314151617var arr=['A','B','C'];var r=arr.filter(function(element,index,self)&#123; console.log(element);//依次打印'A','B','C'] console.log(index);//依次打印0,1,2 console.log(self);//打印变量arr return true;&#125;)/*运行结果如下：A0(3) ['A', 'B', 'C']B1(3) ['A', 'B', 'C']C2(3) ['A', 'B', 'C']*/ 利用filter()可以去除Array的重复元素： 12345678var r;var arr=['apple','strawberry','banana','pear','apple','orange','orange','strawberry'];r=arr.filter(function(element,index,self)&#123; return self.indexOf(element)===index;&#125;);console.log(r.toString());/*运行结果如下：apple,strawberry,banana,pear,orange*/ 由于indexof总是返回元素第一次出现的位置，因此后续的重复元素位置与indexof不相等就被过滤掉了。 练习题 请尝试用filter()筛选出素数： 12345678910111213141516171819202122232425262728293031function get_primes(arr) &#123; return arr.filter(function(x)&#123; if(x===1)&#123; return false; &#125;else if(x===2||x===3||x===5||x===7)&#123; return true; &#125;else if(x%2===0||x%3===0||x%5===0||x%7===0)&#123; return false; &#125;else&#123; return true; &#125; &#125;);&#125;// 测试:var x, r, arr = [];for (x = 1; x &lt; 100; x++) &#123; arr.push(x);&#125;r = get_primes(arr);if (r.toString() === [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97].toString()) &#123; console.log('测试通过!');&#125; else &#123; console.log('测试失败: ' + r.toString());&#125;/*运行结果如下：测试通过!*/ sort JavaScript中的sort()默认把所有元素转换为String再进行排序，用于排序字符串时，根据ASCII码进行排序。因此，直接使用sort()对数字进行排序，得到的结果往往不如人意。 比较两个元素大小时，通常规定，对于x&lt;y，则返回-1；对于x==y，则返回0；对于x&gt;y，则返回1。 若要按数字大小进行排序，可以写成： 1234567891011121314151617181920212223242526272829//从小到大排序var arr=[10,20,1,2];arr.sort(function(x,y)&#123; if(x&lt;y)&#123; return -1; &#125; if(x&gt;y)&#123; return 1; &#125; return 0&#125;);console.log(arr);/*运行结果如下：(4) [1, 2, 10, 20]*///从大到小排序：var arr=[10,20,1,2];arr.sort(function(x,y)&#123; if(x&lt;y)&#123; return 1; &#125; if(x&gt;y)&#123; return -1; &#125; return 0&#125;);console.log(arr);/*运行结果如下：(4) [20, 10, 2, 1]*/ 忽略字母大小写，按照字母序排序： 1234567891011121314var arr=['Google','apple','Microsoft'];console.log(arr.sort(function(s1,s2)&#123; x1=s1.toUpperCase(); x2=s2.toUpperCase(); if(x1&lt;x2)&#123; return -1; &#125; if(x1&gt;x2)&#123; return 1; &#125; return 0;&#125;));/*运行结果如下：(3) ['apple', 'Google', 'Microsoft']*/ sort()方法会直接对Array进行修改，原Array返回的结果是修改后的Array： 123456789var a1=['A','C','B'];var a2=a1.sort();console.log(a1);console.log(a2);console.log(a1===a2);/*运行结果如下：(3) ['A', 'B', 'C'](3) ['A', 'B', 'C']true*/ Array 对于数组，除了map()、reduce()、filter()、sort()这些方法外，Array对象还提供了很多实用的高阶函数。 every every()方法可以判断数组的所有元素是否满足测试条件： 12345678910var arr=['Apple','pear','orange'];console.log(arr.every(function(s)&#123; return s.length&gt;0;&#125;));console.log(arr.every(function(s)&#123; return s.toLowerCase()===s;//判断每个元素是否都是小写&#125;));/*运行结果如下：truefalse*/ find find()方法用于查找符合条件的第一个元素，若找到了，返回这个元素，否则返回undefined: 12345678910var arr=['Apple','pear','orange'];console.log(arr.find(function(s)&#123; return s.toLowerCase()===s;//返回全是小写的第一个元素&#125;));console.log(arr.find(function(s)&#123; return s.toUpperCase()===s;//返回全是小写的第一个元素&#125;));/*运行结果如下：pearundefined*/ findIndex findIndex()和find()类似，也是查找符合条件的第一个元素，不同之处在于findIndex()会返回这个元素的索引，若没有找到，则返回-1： 12345678910var arr=['Apple','pear','orange'];console.log(arr.findIndex(function(s)&#123; return s.toLowerCase()===s;//返回全是小写的第一个元素&#125;));console.log(arr.findIndex(function(s)&#123; return s.toUpperCase()===s;//返回全是小写的第一个元素&#125;));/*运行结果如下：1-1*/ forEach forEach和map()类似，也把每个元素依次作用于传入的函数，但不会返回新的数组，常用于遍历数组。 123456var arr=['Apple','pear','orange'];arr.forEach(console.log);/*运行结果如下：Apple 0 (3) ['Apple', 'pear', 'orange']pear 1 (3) ['Apple', 'pear', 'orange']orange 2 (3) ['Apple', 'pear', 'orange']*/ 闭包 函数作为返回值 123456789101112131415function lazy_sum(arr)&#123; var sum=function()&#123; return arr.reduce(function(x,y)&#123; return x+y; &#125;); &#125; return sum;&#125;var f1=lazy_sum([1,2,3,4,5]);//f=sum()，调用lazy_sum时返回的不是求和结果，而是求和函数var f2=lazy_sum([1,2,3,4,5]);//每次调用都会返回一个新函数console.log(f1());console.log(f1===f2);/*运行结果如下：15false*/ 闭包 当一个函数返回一个新函数后，其内部的局部变量还被新函数引用。返回的函数并没有立刻执行，而是知道调用f()后才执行。 与pyhton中的闭包相同，由于返回的函数非立刻执行，而是等到返回函数调用完成时才执行，因此会发生以下情况： 12345678910111213141516function count()&#123; var arr=[]; for(var i=1;i&lt;=3;i++)&#123; arr.push(function()&#123; return i*i; &#125;); &#125; return arr;&#125;var results=count();var f1=results[0];var f2=results[1];var f3=results[2];console.log(f1(),f2(),f3());/*运行结果如下：16 16 16*/ 因此返回闭包时，返回函数不要引用任何循环遍历或是会发生变化的量。 若一定要引用循环变量，则要再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环遍历如何更改，已绑定到函数参数的值都是不变的： 123456789101112131415161718function count()&#123; var arr=[]; for(var i=1;i&lt;=3;i++)&#123; arr.push((function(n)&#123; return function()&#123; return n*n; &#125; &#125;)(i)); &#125; return arr;&#125;var results=count();var f1=results[0];var f2=results[1];var f3=results[2];console.log(f1(),f2(),f3());/*运行结果如下：1 4 9*/ 这里用到了一个创建匿名函数并立刻执行的语法： 123(function(x)&#123; return x*x;&#125;)(3); 正常创建匿名函数并立刻执行写法如下： 1function(x)&#123;return x*x&#125;(3) 但再JavaScript中这么些会报错，因此需要用括号把函数定义括起来。 JavaScript里没有class机制，只有函数。借助闭包，同样可以封装一个私有变量： 12345678910111213141516171819202122232425function create_counter(initial)&#123; var x=initial||0; return &#123; inc:function()&#123; x+=1; return x; &#125; &#125;&#125;var c1=create_counter();console.log(c1.inc());console.log(c1.inc());console.log(c1.inc());var c2=create_counter(10);console.log(c2.inc());console.log(c2.inc());console.log(c2.inc());/*运行结果如下：123111213*/ 在返回的对象中实现了一个闭包，该闭包携带了局部变量x，且外部的代码无法访问到变量x。 闭包还可以把多参数的函数变成单参数的函数。如计算x^y可以用Math.pow(x,y)函数，可以利用闭包创建新的函数pow2和pow3： 123456789101112function make_pow(n)&#123; return function(x)&#123; return Math.pow(x,n); &#125;&#125;var pow2=make_pow(2);var pow3=make_pow(3);console.log(pow2(5));console.log(pow3(7));/*运行结果如下：25343*/ 箭头函数 ES6标准新增了一种新的函数：箭头函数。它的定义用的就是一个箭头： 12345x=&gt;x*x//等价于funtion(x)&#123; return x*x;&#125; 箭头函数相当于是匿名函数，并且简化了函数定义。箭头函数有两种格式，一种只包含一个表达式： 1x=&gt;x*x 还有一种可以包含多条语句： 1234567x=&gt;&#123; if(x&gt;0)&#123; return x*x; &#125;else&#123; return -x*x; &#125;&#125; 如果参数不是一个，就需要用括号()括起来： 123456789(x,y)=&gt;x*x+y*y//两个参数()=&gt;3.14//无参数(x,y,...rest)=&gt;&#123; var i,sum=x+y; for(i=0;i&lt;rest.lenth;i++)&#123; sum+=rest[i]; &#125; return sum;&#125; 如果要返回一个对象，就要写成这样： 1x=&gt;(&#123;foo:x&#125;) this 箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 箭头函数完全修复了this的指向，this总是指向词法作用域，即外层调用者obj，以前的hack写法var that=this就不再需要了： 1234567891011var obj=&#123; birth:1999, getAge:function()&#123; var b=this.birth; var fn=()=&gt;new Date().getFullYear()-this.birth; return fn() &#125;&#125;;console.log(obj.getAge());/*运行结果如下：23*/ 由于this在箭头函数中已经按照词法作用域绑定了，因此用call()或apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略： 1234567891011var obj=&#123; birth:1999, getAge:function(year)&#123; var b=this.birth; var fn=(y)=&gt;y-this.birth; return fn.call(&#123;birth:2000&#125;,year) &#125;&#125;;console.log(obj.getAge(2015));/*运行结果如下：16*/ 练习题 请使用箭头函数简化排序时传入的函数： 1234567var arr = [10, 20, 1, 2];arr.sort((x, y) =&gt; &#123; return x-y;&#125;);console.log(arr); // [1, 2, 10, 20]/*运行结果如下：(4) [1, 2, 10, 20]*/ generator 生成器generator是ES6标准引入一个数据类型，其概念和语法与python的generator相似。 generator的定义如下： 12345function* foo(x)&#123; yield x+1; yield x+2; return x+3;&#125; generator和函数不同的是，generator由function*定义，除了用return语句，还可以用yield返回多次。 用generator写一个斐波那契数列如下： 1234567891011121314151617181920212223242526272829303132333435363738function* fib(max)&#123; var t,a=0,b=1,n=0; while (n&lt;max)&#123; yield a; [a,b]=[b,a+b]; n++; &#125; return;&#125;var f=fib(5);console.log(f.next());//通过调用generator对象的next()方法来调用生成器console.log(f.next());//value的值就是yield的返回值，done表示这个生成器已经执行结束了console.log(f.next());console.log(f.next());console.log(f.next());console.log(f.next());//若done为true,value就是return的返回值，这个生成器对象已经全部执行完毕//用for...of循环迭代生成器对象for(var x of fib(10))&#123; console.log(x);&#125;/*运行结果如下：&#123;value: 0, done: false&#125;&#123;value: 1, done: false&#125;&#123;value: 1, done: false&#125;&#123;value: 2, done: false&#125;&#123;value: 3, done: false&#125;&#123;value: undefined, done: true&#125;0112358132134*/ 由于generator可以在执行过程中多次返回，因此它看上去像是可以记住执行状态的函数。因此可以利用它来实现保存状态的功能。 练习题 要生成一个自增的ID，可以编写一个next_id()函数： 123456var current_id = 0;function next_id() &#123; current_id ++; return current_id;&#125; 由于函数无法保存状态，故需要一个全局变量current_id来保存数字。 不用闭包，试用generator改写： 12345678910111213141516171819202122232425function* next_id()&#123; var current_id=1,n=0; while(n&lt;100)&#123; yield current_id; current_id++; n++; &#125; return ;&#125;// 测试:var x, pass = true, g = next_id();for (x = 1; x &lt; 100; x ++) &#123; if (g.next().value !== x) &#123; pass = false; console.log('测试失败!'); break; &#125;&#125;if (pass) &#123; console.log('测试通过!');&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://tangmenjue.top/tags/JavaScript/"}]},{"title":"前端三件套之JavaScript（一）","slug":"前端三件套之JavaScript（一）","date":"2022-10-28T09:32:29.000Z","updated":"2022-11-10T15:49:09.517Z","comments":true,"path":"2022/10/28/前端三件套之JavaScript（一）/","link":"","permalink":"http://tangmenjue.top/2022/10/28/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97%E4%B9%8BJavaScript%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"快速入门 JavaScript代码可以直接嵌在网页的任何地方，通常会把JavaScript代码放在HTML的&lt;head&gt;中。由&lt;script&gt;...&lt;/script&gt;包含的代码就是JavaScript代码，它将直接被浏览器执行。 另一种方法就是把JavaScript代码放到一个单独的.js文件中，然后在HTML中通过&lt;script src=\"/js文件地址\"&gt;...&lt;/script&gt;的方式引入这个文件。 **JavaScript中的注释符号是//或/**/，*JavaScript中严格区分大小写。** 若需要调试JavaScript代码，可以打开一个网页，然后按下F12打开开发者工具，点击控制台（Console）在&gt;里可以直接输入JavaScript代码，按回车后执行。按F12可关闭开发者工具。 在控制台中输入console.log(a)可以查看变量a的内容，回车后显示的值就是变量内容。 本文中使用的是把JavaScript代码放到一个单独的.js文件中的方法。因此先建立一个test.html文档，其内容如下： 123456&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"test.js\" charset=\"UTF-8\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;/html&gt; 建好test.html后，在test.html所在文件夹新建一个text.js文件，后续的JavaScript代码都在text.js中编写，控制台的代码在text.js里运行，需要页面显示的代码在test.html里运行。 基本语法 JavaScript的语法与Java类似，每个语句以;结束，语句块用{...}。语句块中具有以4个空格为单位的缩进。 练习题 分别利用行注释和块注释把下面的语句注释掉，使它不再执行： 12//alert('我不想执行');/*alert('我也不想执行');*/ 数据类型 Number JavaScript不区分整数和浮点数，统一用Number表示。 以下是合法的Number类型： 整数：123 浮点数：0.123 科学计数法：1.2345e3（即12345x1000） 复数：-123 无法计算结果时：NaN 无限大：Infinity JavaScript里的十六进制用0x前缀表示。 字符串 字符串是以单引号''或双引号\"\"括起来的任意文本，引号本身不是字符串的一部分。如：‘abc'、“qwe”。 布尔值 布尔值与布尔代数的表示完全一致，一个布尔值只有true、false两种值。 &amp;&amp;是与运算，||是或运算，!是非运算。 比较运算符 JavaScript允许对任意数据类型做比较。 注意相等运算符==，JavaScript有两种比较运算符： ==比较运算符：会自动转换数据类型再比较。 ===比较运算符：不会自动转换数据类型。若数据类型不一致，返回false，若一直，再进行比较。 NaN与所有值都不相等，包括他自己。 唯一能判断NaN为true的方法是通过isNaN()函数。 JavaScript比较浮点数只能计算它们之差的绝对值，看是否小于某个阈值即： 121/3===(1-2/3);//falseMath.abs(1/3-(1-2/3))&lt;0.0000001;//true null和undefined null表示一个空的值，它和0以及空字符''不同。0是一个数值，''表示长度为0的字符串，null表示空。 undefined表示值未定义，undefined仅在判断函数参数是否传递的情况下有用。 数组 数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型，如： 1[1,2,3.14,'Hello',null,true]; 创建数组可以通过Array()函数实现： 1new Array(1,2,3.14,'Hello',null,true); 数组的元素可以通过索引来访问，起始值是0. 对象 JavaScript的对象是一组由键-值组成的无序集合： 12345678var person=&#123; name:'Bob', age:20, tags:['js','web','java'], city:'Beijing', hasCar:true, zipcode:null&#125;; JavaScript对象的键都是字符串类型，值可以是任意数据。每个键又称为对象的属性。 要获取一个对象的属性，可以用对象变量.属性名的方式，如person.name;。 变量 变量在JavaScript中用一个变量名表示，变量名是大小写英文、数字、$和_组成，不能以数字开头。变量名也不能是JavaScript的关键字，如if、while等。变量名也可以用中文。 声明变量用var语句，如： 12var a;var $b=1 =号为赋值号，同一个变量可以反复赋值，可以是不同类型的变量，但只能声明一次： 12var a=123;a='ABC'//a的值由整数变为字符串 要在控制台上显示变量的内容，用console.log(x)语句。使用console.log()代替alert()的好处是避免弹出烦人的对话框。 strict模式 使用var声明的变量不是全局变量，它的范围被限制在该变量被声明的函数体内，同名变量在不同的函数体内互不冲突。 在strict模式下运行的JavaScript代码，强制通过var声明变量，未使用var声明变量就使用的，运行会报错。 启用strict模式的方法是在JavaScript代码的第一行写上： 1'use strict'; 这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将会开启strict模式运行JavaScript。 字符串 转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，\\\\表示\\字符。 ASCII字符可以以\\x##形式的十六进制表示，如\\x41;便等同于A。 还可以用\\u####表示一个Unicode字符，如\\u4e2d\\u6587;便等同于‘中文’。 多行字符串 由于多行字符串用\\n写起来比较麻烦，因此最新的ES6标准新增了一种多行字符串的方法，用反引号`表示，反引号里面的内容每次回车就会自动换行： 123`这是一个多行字符串`; 模板字符串 要把多个字符串连接起来，可以用+号连接： 1234var name=\"张三\";var age=22;var message='你好，'+name+'，你今年'+age+'岁了';alert(message); 当由很多变量需要连接时，用+号比较麻烦，ES6新增了一种模板字符串，表示方法和多行字符串一样，但它会自动替换字符串中的变量： 1234var name=\"张三\";var age=22;var message=`你好，$&#123;name&#125;，你今年$&#123;age&#125;岁了`;alert(message); 操作字符串 字符串是不可变的，若对字符串的某个索引赋值，不会报错，但也没有任何效果。 toUpperCase toUpperCase()把一个字符串全部变为大写： 12var s=\"Hello\";console.log(s.toUpperCase());//返回'HELLO' toLowerCase toLowerCase把一个字符串全部变为小写： 12var s=\"Hello\";console.log(s.toLowerCase());//返回'hello' indexOf indexof()会搜索指定字符串出现的位置： 123var s='hello,world';console.log(s.indexOf('world'));//返回6console.log(s.indexOf('World'));//没有找到指定的子串，返回-1 substring substring()返回指定索引区间的子串： 123var s='hello,world';console.log(s.substring(0,5));//从索引0开始到5结束(不包括5)，返回'hello'console.log(s.substring(6));//从索引6开始到结束，返回'world' 练习题 测试你的浏览器是否支持ES6标准，如果不支持，请把多行字符串用\\n重新表示出来： 1234567console.log(`多行字符串测试`);/*运行结果如下：多行字符串测试*/ 测试你的浏览器是否支持ES6模板字符串，如果不支持，请把模板字符串改为+连接的普通字符串： 12345var name = '小明';var age = 20;console.log(`你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`);/*运行结果如下：你好, 小明, 你今年20岁了!*/ 数组 要取得数组的长度，可直接访问length属性： 12var arr=[1,2,3.14,'Hello',null,true];console.log(arr.length);//长度为6,返回6 注意：直接给Array的length赋一个新值会导致Array大小的变化： 1234567var arr=[1,2,3];console.log(arr.length);//长度为3,返回3arr.length=6;console.log(arr);//arr变为[1,2,3,undefined,undefined,undefined]//返回(6) [1, 2, 3, …]arr.length=2;console.log(arr);//arr变为[1,2]，返回(6) [1, 2, 3, …] Array可以通过索引把对应的元素修改为新的值，通过索引赋值会直接修改Array。若索引超过了范围，同样会引起Array大小的变化： 1234var arr=[1,2,3];arr[5]='x';console.log(arr);//arr变为[1,2,3,undefined,undefined,'x']//返回(6) [1, 2, 3, …, 'x'] indexOf 与String类似，Array也可以通过indexof()来搜索一个指定的元素位置： 123var arr=[10,20,'30','xyz'];console.log(arr.indexOf(10));//元素10的索引为0,返回0console.log(arr.indexOf(30));//元素30没有找到，返回-1 slice slice对应String的substring()，截取Array的部分元素，然后返回一个新的Array： 123var arr=['A','B','C','D','E','F','G'];console.log(arr.slice(0,3));//从索引0开始到3结束(不包括3)，返回(3) ['A', 'B', 'C']console.log(arr.slice(3));//从索引3开始到结束，返回(4) ['D', 'E', 'F', 'G'] 若不给slice()传递任何参数，它会从头到尾截取所有元素。 push和pop push()向Array的末尾添加元素，pop()则把Array的最后一个元素删掉： 123456789var arr=[1,2];arr.push('A','B'); console.log(arr); // 返回(4)[1, 2, 'A', 'B']arr.pop(); console.log(arr); // 返回(3)[1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次console.log(arr); // 返回(0)[]arr.pop(); // 空数组继续pop不会报错，而是返回undefinedconsole.log(arr);// 返回(0)[] unshift和shift 若要往Array的头部添加若干元素，使用unshift()方法，shift()方法则是把Array的第一个元素删掉： 123456789var arr=[1,2];arr.unshift('A','B');console.log(arr);// 返回(4) ['A', 'B', 1, 2]arr.shift();console.log(arr);// 返回(3) ['B', 1, 2]arr.shift();arr.shift();arr.shift();console.log(arr);// 返回(0) []arr.shift();// 空数组继续shift不会报错，而是返回undefinedconsole.log(arr);// 返回(0) [] sort sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用是，按照默认顺序排序： 123var arr=['B','C','A'];arr.sort();console.log(arr);//返回(3) ['A', 'B', 'C'] reverse reverse()可以反转Array内的元素： 123var arr=[1,2,3];arr.reverse();console.log(arr);//返回(3) [3, 2, 1] splice splice方法可以从指定的索引开始删除元素，然后再从该位置添加元素： 1234567var arr=[1,2,3,4,5,6];arr.splice(2,3,'A','B');//从索引2开始删除3个元素，然后再添加2个元素console.log(arr);//返回(5) [1, 2, 'A', 'B', 6]arr.splice(2,2)//从索引2开始删除2个元素，不添加元素console.log(arr);//返回(3) [1, 2, 6]arr.splice(2,0,'A','B');//从索引2开始添加2个元素，不删除元素console.log(arr);//返回(5) [1, 2, 'A', 'B', 6] concat concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array： 1234var arr=['A','B','C'];var added=arr.concat([1,2,3]);console.log(added);//返回(6) ['A', 'B', 'C', 1, 2, 3]console.log(arr);//返回(3) ['A', 'B', 'C'] concat()方法可以接收任意个元素和Array，并自动把Array拆开，然后全部添加到新的Array里： 123var arr=['A','B','C'];console.log(arr.concat(1,2,[3,4]));//返回(7) ['A', 'B', 'C', 1, 2, 3, 4] join join()方法把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： 12var arr=['A','B','C',1,2,3];console.log(arr.join('-'))//返回A-B-C-1-2-3 若Array的元素不是字符串，将自动转换为字符串后再连接。 多维数组 若数组的某个元素又是一个Array，便形成了多维数组。 练习题 如何通过索引取到500这个值： 12345var arr = [[1, 2, 3], [400, 500, 600], '-'];var x = arr[1][1];console.log(x); /*运行结果如下：500*/ 在新生欢迎会上，你已经拿到了新同学的名单，请排序后显示：欢迎XXX，XXX，XXX和XXX同学！： 12345var arr = ['小明', '小红', '大军', '阿黄'];arr.sort();console.log('欢迎'+arr[0]+'，'+arr[1]+'，'+arr[2]+'和'+arr[3]+'同学！');/*运行结果如下：欢迎大军，小明，小红和阿黄同学！*/ 对象 JavaScript的对象是一种由若干键值组成的无序集合数据类型。 JavaScript用一个{...}表示一个对象，键值对以xxx:xxx形式声明，用,隔开： 12345678var xiaoming=&#123; name:'小明', birth:1999, school:'No.1 Middle School', height:1.70, weight:65, score:null&#125;; 可以通过对象.属性来获取小明的属性：xiaoming.name;。若属性名包括特殊字符，就必须使用''括起来： 1234var zhangsan=&#123; name:'张三', 'middel-school':'No.1 Middle School'&#125;; 访问这一特殊属性无法使用.操作符，必须使用['xxx']访问： 123zhangsan['middel-school'];zhangsan['name'];//name也可以用['xxx']访问zhangsan.name; 对象的所有属性都是字符串，但属性值可以是任意数据类型。若访问不存在的属性会返回undefined。 由于JavaScript的对象是动态类型，因此可以自由给对象添加或删除属性： 12345678var xiaoming=&#123; name:'小明'&#125;;console.log(xiaoming.age);//返回undefinedxiaoming.age=18;//console.log(xiaoming.age);//返回18delete xiaoming.age;//删除age属性console.log(xiaoming.age);//返回undefined 用in操作符可以检查对象是否拥有某个属性（包括继承属性）： 12345var xiaoming=&#123; name:'小明'&#125;;console.log('name'in xiaoming);//返回trueconsole.log('age' in xiaoming);//返回false 用hasOwnProperty()方法可以可以检查对象自身是否拥有某个属性： 12345var xiaoming=&#123; name:'小明'&#125;;console.log(xiaoming.hasOwenProperty('name'));//返回trueconsole.log(xiaoming.hasOwenProperty('age'));//返回false 条件判断 JavaScript使用if(){...}else{...}来进行条件判断，如： 123456var age=20;if(age&gt;=18)&#123; alert('adult');&#125;else&#123; alert('teenager');&#125; 多行条件判断 使用多个if...else if...else...组合可以进行更细致的判断： 12345678var age=3;if (age&gt;=18)&#123; alert('adult');&#125;else if(age&gt;=6)&#123; alert('teenager');&#125;else&#123; alert('kid');&#125; JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为true。 练习题 小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数： 低于18.5：过轻 18.5-25：正常 25-28：过重 28-32：肥胖 高于32：严重肥胖 用if...else...判断并显示结果： 12345678910111213141516var height=parseFloat(prompt('请输入身高(m):'));var weight=parseFloat(prompt('请输入体重(kg):'));var bmi=weight/(height*height);if(bmi&lt;18.5)&#123; console.log('过轻');&#125;else if(bmi&gt;=18.5&amp;&amp;bmi&lt;25)&#123; console.log('正常');&#125;else if(bmi&gt;=25&amp;&amp;bmi&lt;28)&#123; console.log('过重');&#125;else if(bmi&gt;=28&amp;&amp;bmi&lt;32)&#123; console.log('肥胖');&#125;else&#123; console.log('严重肥胖');&#125;/*运行结果如下：过重*/ 循环 JavaScript的循环有两种，一种是for循环，另一种是while循环。 for循环 123456var x=0;var i;for(i=1;i&lt;=10000;i++)&#123; x=x+i;&#125;console.log(x);//返回50005000 练习题 利用for循环计算1 * 2 * 3 * ... * 10的结果： 123456789var x=1;var i;for (i=1;i&lt;=10;i++)&#123; x=x*i;&#125;if (x === 3628800) &#123; console.log('1 x 2 x 3 x ... x 10 = ' + x);&#125;else &#123; console.log('计算错误');&#125; for循环的3个条件是可以省略的，for(;;)将无限循环下去，为了避免死循环，此时可以使用break语句退出循环。 for...in for循环的一个变体是for...in循环，它可以把一个对象的所有属性依次循环出来： 12345678910111213var a=&#123; name:'Jack', age:20, city:'Beijing'&#125;for(var key in a)&#123; console.log(key);&#125;/*运行结果如下：nameagecity*/ 可用hasOwnProperty()过滤掉继承属性： 123456789101112131415var a=&#123; name:'Jack', age:20, city:'Beijing'&#125;for(var key in a)&#123; if(a.hasOwnProperty(key))&#123; console.log(key); &#125;&#125;/*运行结果如下：nameagecity*/ for...in循环也可以直接循环出Array的索引： 12345678910111213var a=['A','B','C'];for(var i in a)&#123; console.log(i); console.log(a[i]);&#125;/*运行结果如下：0A1B2C*/ while while循环只有一个判断条件，条件满足就不断循环，条件不满足则退出循环： 12345678910var x=0;var n=99;while(n&gt;0)&#123; x=x+n; n=n-2;&#125;console.log(x);/*运行结果如下：2500*/ do...while do...while与while循环的唯一区别在于，do...while在每次循环完成时判断条件： 12345678var n=0;do&#123; n=n+1;&#125;while(n&lt;100);console.log(n);/*运行结果如下：100*/ 练习题 请利用循环遍历数组中的每个名字，并显示Hello, xxx!。请尝试for循环和while循环，并以正序、倒序两种方式遍历： 123456789101112131415161718192021222324252627var arr = ['Bart', 'Lisa', 'Adam'];//for循环正序for(var i in arr)&#123; console.log('Hello, '+arr[i]+'!');&#125;console.log('for循环正序');//for循环倒序for(var i=arr.length-1;i&gt;=0;i--)&#123; console.log('Hello, '+arr[i]+'!');&#125;console.log('for循环倒序');//while循环正序var t=0;while(t&lt;=arr.length-1)&#123; console.log('Hello, '+arr[t]+'!'); t=t+1;&#125;console.log('while循环正序');//while循环倒序var n=arr.length-1do&#123; console.log('Hello, '+arr[n]+'!'); n=n-1;&#125;while(n&gt;=0);console.log('while循环倒序'); Map和Set JavaScript的默认对象表示方式{}可以视为其他语言中的Map的数据结构。但JavaScript的对象，其键必须是字符串，实际上Number或其他数据类型作为键也是合理的。 为解决这种情况，ES6规范引入了新的数据类型Map。 以下代码可以测试浏览器是否支持ES6规范，若报错则不支持： 123var m = new Map();var s = new Set();console.log('你的浏览器支持Map和Set！'); Map Map是一组键值对的结构，具有极快的查找速度： 1234var m=new Map([['Michael',95],['Bob',75],['Tracy',85]]);console.log(m.get('Michael'));/*运行结果如下：95*/ 初始化Map需要两个二维数组，或者直接初始化一个空Map。Map具有以下方法： 123456var m=new Map();//空Mapm.set('Adam',67);//添加一个新的键值console.log(m.has('Adam'));//是否存在key'Adam'console.log(m.get('Adam'));//获取key'Adam'的值，返回67m.delete('Adam');//删除key'Adam'console.log(m.get('Adam'));//返回undefined 由于一个key只能对应一个value，依次多次对一个key放入value，后面的值会把前面的值顶掉。 Set Set和Map类似，也是一组key的集合，但Set不存储value。Set中没有重复的key。 创建一个Set，需要提供一个Array作为输入，或者直接初始化一个空Set： 12var s=new Set();//空Setvar ss=new Set([1,2,3]);//含1,2,3 Set具有以下方法： 1234567var a=new Set([1,2,3]);a.add(4);//添加元素4到set中console.log(a);//返回Set&#123;4, 1, 2, 3&#125;a.add(4);//重复添加元素console.log(a);//自动过滤重复元素。返回Set&#123;4, 1, 2, 3&#125;a.delete(3);//删除set中的元素3console.log(a);//Set&#123;1, 2, 4&#125; iterable 遍历Array可以采用下标循环，而Set和Map无法使用 下标。为了统一集合类型，ES6引入了iterable类型。Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过for...of循环来遍历，可以通过以下代码测试浏览器是否支持for...of循环： 1234var a = [1, 2, 3];for (var x of a) &#123;&#125;console.log('你的浏览器支持for ... of'); 用for...of循环遍历集合，用法如下： 12345678910111213141516171819202122var a=['A','B','C'];var s=new Set(['A','B','C']);var m=new Map([[1,'x'],[2,'y'],[3,'z']]);for(var x of a)&#123;//遍历数组 console.log(x);&#125;for(var x of s)&#123;//遍历Set console.log(x);&#125;for(var x of m)&#123;//遍历Map console.log(x[0]+'='+x[1]);&#125;/*运行结果如下：ABCABC1=x2=y3=z*/ 当给Array对象添加了额外的属性后，使用for ... in循环会有意想不到的意外效果： 1234567891011var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x in a) &#123; console.log(x); &#125;/*运行结果如下：012name*/ for ... in循环将把name包括在内，但Array的length属性却不包括在内。 for ... of循环则完全修复了这些问题，它只循环集合本身的元素： 12345678910var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x of a) &#123; console.log(x);&#125;/*运行结果如下：ABC*/ 还可以使用ES5.1引入的iterable内置forEach方法，它接收一个函数，每次迭代就自动回调该函数： 12345var a=['A','B','C'];a.forEach(function(element,index,array)&#123; console.log(element+', index='+index);&#125;);//element指向当前元素的值，index指向当前索引，array指向array对象本身 Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身。 Map的回调函数参数依次为value、key和map本身。 由于JavaScript的函数调用不要求参数必须一致，因此可以忽略部分参数，如只需要获得Array的element。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://tangmenjue.top/tags/JavaScript/"}]},{"title":"前端三件套之CSS（二）","slug":"前端三件套之CSS（二）","date":"2022-10-28T03:38:49.000Z","updated":"2022-11-10T15:49:38.528Z","comments":true,"path":"2022/10/28/前端三件套之CSS（二）/","link":"","permalink":"http://tangmenjue.top/2022/10/28/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97%E4%B9%8BCSS%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"CSS表格 表格边框 使用border属性可以指定CSS表格边框： 123table,th,td&#123; border:1px solid black;&#125; 由于表格和th/td元素有独立的边界，故会显示有双边框。 折叠边框 使用border-collapse属性可以设置表格的边框是否被折叠成一个单一的边框或隔开： 123456table&#123; border-collapse:collapse;&#125;table,th,td&#123; border:1px solid black;&#125; 表格宽度和高度 使用width和height属性定义表格的宽度和高度： 123456table&#123; width:100%;&#125;th&#123; height:50px;&#125; 表格文字对齐 表格中的文字对齐可分为水平对齐和垂直对齐。 使用text-align属性设置水平对齐方式，如向左对齐left、向右对齐right或居中对齐center： 123td&#123; text-align:right;&#125; 使用vertical-align属性设置垂直对齐方式，如顶部top、底部bottom或中间center： 123td&#123; vertical-align:bottom;&#125; 表格填充 使用padding属性控制内容与边框之间的距离： 123td&#123; padding:15px;&#125; 表格颜色 使用border属性指定边框的颜色，使用color属性控制文本颜色，使用background-color属性控制背景颜色： 1234567table,td,th&#123; border:1px solid green;/*solid指边框线为实线*/&#125;th&#123; background-color:green; color:white;&#125; 盒子模型 CSS盒子模型本质上是一个盒子，封装周围的HTML元素，包括边距、边框、填充和实际内容。盒模型允许在其他元素和周围元素边框之间的空间放置元素。 标准盒子模型如下图所示： Margin（外边距）：盒子与其他盒子的距离。Margin没有背景颜色，其完全透明 Border（边框）：盒子的厚度和它的颜色或材料。边框颜色会受到盒子的背景颜色影响 Padding（内边距）：盒子里与盒中内容的填充物。会受到框中填充的背景颜色影响 Content（内容）：盒子里装的东西，显示文本和图像 元素的宽度和高度 当指定一个CSS元素的宽度和高度属性时，实质上只是设置内容区域的宽度和高度，除此之外，还需要添加填充、边框和边距： 123456a&#123; width:250px; padding:10px; border:5 px solid gray; margin:10px;&#125; 则该元素的总宽度为250px（宽）+20px（左右填充）+10px（左右边框）+20px（左右边距=300px。 因此，元素的总宽度计算公式为： 元素的总宽度=元素自身宽度+左填充+右填充+左边框+右边框+左边距+右边距 同理可得，元素的总高度计算公式为： 元素的总高度=元素自身高度+顶部填充+底部填充+上边框+下边框+上边距+下边距 网页的宽度一般为1920px，高度不限。有限可视区在：950px~1200px的宽度之间。 边框 边框样式 使用border-style属性可以定义边框的样式。 border-style有以下属性值： none：默认无边框 dotted：定义一个点线框 dashed：定义一个虚线框 solid：定义实线边界 double：定义两个边界。两个边界的宽度和border-width的值相同 groove：定义3D沟槽边距。效果取决于边界的颜色值 ridge：定义3D脊边界。效果取决于边界的颜色值 inset：定义一个3D的嵌入边框。效果取决于边界的颜色值 outset：定义一个3D的突出边框。效果取决于边界的颜色值 边框宽度 使用border-width属性可以为边框指定宽度。可以指定长度值，比如2px或0.1em；或使用3个关键字之一：thin、medium（默认值）和thick。 1234p&#123; border-style:solid; border-width:medium;&#125; 边框颜色 使用border-color属性可以设置边框的颜色，一次最多可以接受4个颜色值，使用border-color必须得先使用border-style来设置边框样式： 1234p&#123; border-style:solid; border-color:red;&#125; 单独设置各边 可以指定不同的侧面不同的边框： 12345678910p&#123; border-top-style:dotted; border-right-style:solid; border-bottom-style:dotted; border-left-style:solid;&#125;/*方法2*/p&#123; border-style:dotted solid;&#125; border-style 属性可以有 1-4 个值： border-style:dotted solid double dashed; 上边框是 dotted 右边框是 solid 底边框是 double 左边框是 dashed border-style:dotted solid double; 上边框是 dotted 左、右边框是 solid 底边框是 double border-style:dotted solid; 上、底边框是 dotted 左、右边框是 solid border-style:dotted; 四面边框是 dotted 透明边框 透明样式的定义如下： 12345678a:link,a:visited&#123; border-style:solid; border-width:5px; border-color:transparent;&#125;a:hover&#123; border-color:gray;&#125; 简写边框属性 可以在border属性中设置以下属性： border-width border-style border-color 1border:5px solid red; CSS伪类 伪类可以用来添加一些选择器的特殊效果。 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。伪类的名称不区分大小写，伪类的语法如下： 123selector:pseudo-class&#123; property:value;&#125; CSS类中也可以使用伪类： 123selector.class:pseudo-class&#123; property:value;&#125; anchor伪类 在支持CSS的浏览器中，链接的不同状态可以以不同的方式显示。 123456789101112a:link&#123; color:blue;&#125;a:visited&#123; color:red;&#125;a:hover&#123; color:#FF00FF;&#125;a:active&#123; color:#0000FF;&#125; 伪类和CSS类 伪类可以与CSS类配合使用： 1234a.red:visited&#123; color:#FF0000;&#125;&lt;a class=\"red\" href=\"1.html\"&gt;CSS style&lt;/a&gt; first-child伪类 可以使用first-child伪类来选择元素的第一个子元素。 注意：在IE8之前是版本必须声明&lt;!DOCTYPE&gt;，first-child才会生效。 如用来匹配第一个&lt;p&gt;元素： 12345678910111213&lt;html&gt;&lt;head&gt;&lt;style&gt;p:first-child&#123; color:blue;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;我是狼&lt;/p&gt; &lt;p&gt;我是小狼&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： 如用来匹配所有&lt;p&gt;元素中的第一个&lt;i&gt;元素： 12345678910111213&lt;html&gt;&lt;head&gt;&lt;style&gt;p&gt;i:first-child&#123; color:blue;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;我是&lt;i&gt;一只&lt;/i&gt;&lt;i&gt;狼&lt;/i&gt;&lt;/p&gt; &lt;p&gt;我是&lt;i&gt;一只&lt;/i&gt;&lt;i&gt;小&lt;/i&gt;狼&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： 如用来匹配所有作为第一个子元素的&lt;p&gt;元素中的所有&lt;i&gt;元素： 12345678910111213&lt;html&gt;&lt;head&gt;&lt;style&gt;p:first-child i&#123; color:blue;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;我是&lt;i&gt;一只&lt;/i&gt;&lt;i&gt;狼&lt;/i&gt;&lt;/p&gt; &lt;p&gt;我是&lt;i&gt;一只&lt;/i&gt;&lt;i&gt;小&lt;/i&gt;狼&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： lang伪类 lang伪类可以为不同的语言定义特殊的规则。 注意：在IE8之前是版本必须声明&lt;!DOCTYPE&gt;才能支持lang伪类。 如lang类为属性值为no的q元素定义引号的类型： 12345678910111213&lt;html&gt;&lt;head&gt;&lt;style&gt;q:lang(no)&#123; quotes:\"~\"\"~\";&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;我是&lt;q lang=\"no\"&gt;一只&lt;/q&gt;狼&lt;/p&gt; &lt;p&gt;我是一只&lt;q lang=\"no\"&gt;小狼&lt;/q&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"http://tangmenjue.top/tags/CSS/"}]},{"title":"前端三件套之CSS（一）","slug":"前端三件套之CSS（一）","date":"2022-10-28T02:15:29.000Z","updated":"2022-11-10T15:49:35.195Z","comments":true,"path":"2022/10/28/前端三件套之CSS（一）/","link":"","permalink":"http://tangmenjue.top/2022/10/28/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97%E4%B9%8BCSS%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"CSS简介 CSS指层叠样式表，样式定义如何显示HTML元素。 样式对网页中元素位置的排版进行像素级精确控制。 样式通常存储在样式表中，外部样式表通常存储在CSS文件中。 多个样式定义可以层叠为一个，即对一个元素多次设置同一个样式，将使用最后一次设置的属性值。 所有样式根据以下规则层叠于一个新的虚拟样式表中，其中数字4拥有最高的优先权。即意味着它将优先于以下的样式声明： 浏览器缺省设置 外部样式表 内部样式表（位于&lt;head&gt;标签内部） 内联样式（在HTML元素内部） CSS语法 CSS规则由两个主要的部分构成：选择器，以及一条或多条声明，语法如下： 123selector&#123; property:value; &#125; 选择器通常是需要改变样式的HTML元素，每条声明由一个属性和一个值组成。每个属性有一个值，属性和值被冒号分开，例如： 123p&#123; color:red;&#125; CSS颜色值的写法 在描述颜色时，除了使用英文单词，还可以使用十六进制颜色值。 123p&#123; color:#FF0000;&#125; 为了节约字节，可以使用CSS的缩写形式： 123p&#123; color:#F00;&#125; 除此之外，还可以通过两种方法使用RGB值，当使用RGB百分比时，即使值为0也要写百分比符号。： 1234567p&#123; color:rgb(255,0,0);&#125;p&#123; color:rgb(100%,0%,0%);&#125; CSS注释 CSS注释以\"/*\"开始，以\"*/\"结束。 Id和Class选择器 id选择器 id选择器可以为标有特定id的HTML元素指定特定的样式。 HTML元素以id属性来设置id选择器，CSS中id选择器以#号来显示： 123#para1&#123; text-align:center;&#125; id属性不要以数字开头，数字开头的id在Mozilla/Firefox浏览器中不起作用。 id属性只能在每个HTML文档中出现一次。 class类选择器 class选择器用于描述一组元素的样式，class选择器有别于id选择器，class可以在多个元素中使用。 class选择器在HTML中以class属性表示，在CSS中类选择器以一个点.号来显示： 1234567.center&#123; text-align:center;&#125;/*也可以指定特定的HTML元素使用class,如指定所有p元素使用class=\"center\"*/p.center&#123; text-align:center;&#125; 类名不要以数字开头，数字开头的id在Mozilla/Firefox浏览器中不起作用。 标签选择器 以HTML标签作为CSS修饰多用的选择器： 123456&lt;style&gt;h3&#123; color:red;&#125;&lt;/style&gt;&lt;h3&gt;hello world!&lt;/h3&gt; 内联选择器 直接在标签内部写CSS代码： 123&lt;h3 style=\"color red;\"&gt; hello world!&lt;/h3&gt; 这四种CSS选择器有修饰上的优先级，即： 内联选择器&gt;id选择器&gt;类选择器&gt;标签选择器。 样式优先级 多重样式优先级顺序 下列是一份优先级逐级减少的选择器列表，其中数字1拥有最高的优先权： 内联样式 id选择器 伪类 属性选择器 类选择器 元素（类型）选择器 通用选择器（*） !important规则例外 当!important规则被应用在一个样式声明中时，无论它处在声明列表中的哪里，该样式声明会覆盖CSS中任何其他的声明。 注意：只在需要覆盖全站或外部CSS的特定页面中使用!important，不要在全站范围的CSS上使用!important，不要在插件中使用!important。 优先级法则 各CSS样式的权值： 内联样式的权值：1000 id选择器（#id）的权值：100 类选择器（.类）的权值：10 元素选择器（元素名）的权值：1 CSS优先级法则： 选择器都有一个权值，权值越大越优先 当权值相等时，后出现的样式表设置要优于先出现的样式表设置 网页编写者设置的CSS样式的优先权高于浏览器所设置的样式 继承的CSS样式不如后来指定的CSS样式 在同一组属性设置中标有“!important”规则的优先级最大 CSS设置背景 CSS背景用于定义HTML元素的背景。 CSS属性定义背景效果： background-color:背景颜色 background-image：背景图像 background-repeat：背景是否重复、如何重复 background-attachment：背景图像是否固定或随着页面的其余部分滚动 background-position：背景图像的起始位置 background-color background-color属性定义了元素的背景颜色。background-color属性不能继承，默认值是透明transparent。 123body&#123; background-color:#FF0000;&#125; background-image background-image属性描述了元素的背景图像。 默认情况下背景图像进行平铺重复显示，以覆盖整个元素实体，默认在页面的水平或垂直方向平铺。 123body&#123; background-image:url('图片名字');&#125; background-repeat background-repeat属性可以取消图像平铺，或指定只在某个方向上平铺： 12345body&#123; background-image:url('图片名字'); background-repeat:no-repeat;/*取消平铺*/ /*background-repeat:repeat-x; 只在水平方向平铺*/&#125; background-position background-position属性可以改变图像在背景中的位置，其属性值可以使用一些关键字top、bottom、left、right和center等，也可以使用如100px或5cm的长度值，还可以只有百分比数值： 12345body&#123; background-image:url('图片名字'); background-image:no-repeat; background-position:right top;&#125; 背景属性简写 以上代码的属性都可以合并在一个属性background中： 123body&#123; background:#FF0000 url('图片名字') no-repeat right top&#125; 使用简写属性时，属性值的顺序为： background-color background-image background-repeat background-attachment background-position Text（文本） 文本颜色 颜色属性可用来设置文字的颜色，如： 123h1&#123; color:#00ff00;&#125; 对于W3C标准的CSS，若定义了颜色属性，还必须定义背景色属性。 文本的对齐方式 文本排列属性是用来设置文本的水平对齐方式，文本可居中或对齐到左或右或两端对齐。 当text-align设置为justify时，每一行被展开为宽度相等，左右外边距对齐： 123456789h1&#123; text-align:center;&#125;p.date&#123; text-align:right;&#125;p.main&#123; text-align:justify;&#125; 若想把一个行内元素的第一行“缩进”，可用左内边距或外边距创造这种效果。 文本修饰 text-decoration属性用来设置或删除文本的装饰，主要用来删除链接的下划线： 123456789101112a&#123; text-decoration:none;&#125;h1&#123; text-decoration:overline;/*横线在文字上方*/&#125;h2&#123; text-decoration:line-through;/*横线贯穿文字*/&#125;h3&#123; text-decoration:underline;/*横线在文字下方*/&#125; 文本转换 text-transform属性是用来指定在一个文本中的大写和小写字母，可用于所有字句变成大写或小写字母，或每个单词的首字母大写： 123456789p.uppercase&#123; text-transform:uppercase;/*文字全大写*/&#125;p.lowercase&#123; text-transform:lowercase;/*文字全小写*/&#125;p.capitalize&#123; text-transform:capitalize;/*文字首字母大写*/&#125; 文本缩进 text-indent属性用来指定文本的第一行缩进： 123p&#123; text-indent:50px;&#125; 文字间隔 word-spacing属性可以改变字或单词之间的标准间隔（不是每个字之间，以回车键为分隔符），其默认值normal与设置值为0是一样的： 123p&#123; word-spacing:30px;&#125; 字体 字体系列有两种类型： 通用字体系列：拥有相似外观的字体系统组合（如\"Serif\"或\"Monospace\"） 特定字体系列：一个特定的字体系列（如“Times”或“Courier”） 除了各种特定的字体系列外，CSS定义了5种通用字体系列： Serif字体 Sans-serif字体 Monospace字体 Cursive字体 Fantasy字体 Generic family 字体系列 说明 Serif Times New Roman Georgia Serif字体中字符在行的末端拥有额外的装饰 Sans-serif Arial Verdana \"Sans\"是指无 - 这些字体在末端没有额外的装饰 Monospace Courier New Lucida Console 所有的等宽字符具有相同的宽度 字体系列 font-family属性设置文本的字体系列。 font-family属性应该设置几个字体名称作为备用，若浏览器不支持第一种字体会尝试下一种字体。若字体系列的名称超过一种，第一个字体必须用引号： 123p&#123; font-family:\"Times New Roman\",Times,serif;&#125; 字体样式 font-style属性主要用于指定斜体文字的字体样式。 该属性有三个值： 正常normal：正常显示文本 斜体italic：以斜体字显示的文字 倾斜的文字oblique：文字向一边倾斜 通常情况下italic与oblique在web浏览器种看上去完全一样。 italic与oblique的区别： italic是一种简单的文字风格，对每个字母的结果有一些小改动，来反映变化的外观 oblique文本是正常竖直文本的一个倾斜版本 123456789p.normal&#123; font-style:normal;&#125;p.italic&#123; font-style:italic;&#125;p.oblique&#123; font-style:oblique;&#125; 字体大小 font-size属性设置文本的大小，若不指定一个字体的大小，则默认大小和普通文本段落一样，是16像素（16px=1em），字体大小的值可以是绝对或相对的大小。 绝对大小： 设置一个指定大小的文本 不允许用户在所有浏览器中改变文本大小 确定了输出的物理尺寸时，绝对大小很有用 相对大小： 相对于周围的元素来设置大小 允许用户在浏览器中改变文字的大小。 用像素设置字体大小 用像素可以在IE9、Firefox、Chrome、Opera和Safa里调整文本大小，不能在IE9以前的版本运行。通过浏览器缩放工具调整文本大小时，整个页面也随之变化。 123p&#123; font-size:40px;&#125; 用em设置字体大小 默认1em=16px，当font-size为30px时，1em=30px。使用em单位可以在所有浏览器中调整文本大小。通过浏览器缩放工具调整文本大小时，会比正常的尺寸更大或更小。 123p&#123; font-size:2.5em;/*40px/16=2.5em*/&#125; 使用百分比和em组合 在所有浏览器的解决方案中，先设置&lt;body&gt;元素的默认大小是百分比，再用em设置其他元素的字体大小。这样可以在所有浏览器中显示相同的文本大小，并允许所有浏览器缩放文本的大小： 123456body&#123; font-size:100%;&#125;p&#123; font-size:2.5em;&#125; 链接样式 链接的样式可以用任何CSS属性，链接a具有四个链接状态： a:link：正常，未访问过的链接 a:visited：用户已访问过的链接 a:hover：当用户鼠标放在链接上时 a:active：链接被点解的哪一刻 当设置为若干链路状态的样式时，要注意： a:hover必须跟在a.link和a.visited后面 a:active必须跟在a:hover后面 背景颜色 背景颜色属性指定链接背景色： 1234a.link&#123; background-color:#FF704D; text-decoration:none;/*删除链接中的下划线*/&#125; 鼠标形状 使用cursor属性可以设置鼠标形状。 常用鼠标形状如下所示： 属性值 描述 default 默认光标，箭头 pointer 超链接的指针，手型 wait 指示程序正在忙 help 指示可用的帮忙 text 指示文本 crosshair 鼠标呈现十字状 1234a:hover&#123; color:green; cursor:crosshair;&#125; 列表样式 CSS列表可以设置不同的列表项标记为有序列表或无序列表，设置列表项标记为图像。 不同的列表项标记 list-style-type属性指定列表项标记的类型： 123456789101112ul.a&#123; list-style-type:circle;/*空心圆标记*/&#125;ul.b&#123; list-style-type:square;/*实心方块标记*/&#125;ol.c&#123; list-style-type:upper-roman;/*大写罗马数字标记*/&#125;ol.d&#123; list-style-type:lower-alpha;/*小写英文字母标记*/&#125; list-style-type属性的常见属性值有： none：不使用项目符号 disc：实心圆 circle：空心圆 square：实心方块 decimal：阿拉伯数字 lower-alpha：小写英文字母 upper-alpha：大写英文字母 lower-roman：小写罗马数字 upper-roman：大写罗马数字 作为列表项标记的图像 使用列表样式list-style-image属性可以指定列表项标记的图像： 123ul&#123; list-style-image:url('图像名称');&#125; 各大主流浏览器对图像标记的显示各有差异，IE和Opera显示标记比Firefox、Chrome和Safari更高一点。 标记出现位置 list-style-position属性可以指定标志出现在列表项内容外（outside）还是内容内部（inside）： 123ul&#123; list-style-position:outside;&#125; 简写属性 与背景属性类似，列表属性也可以在单个属性list-style中指定所有的列表属性： 123ul&#123; list-style:square url(\"图片名称\");&#125; 使用简写属性值的顺序是： list-style-type list-style-position list-style-image 浏览器兼容性解决方案 若想要在所有浏览器放置同样的标志，应解决浏览器的兼容性问题。 1234567891011ul&#123; list-style-type: none;/*设置列表样式类型为无列表项标记*/ padding: 0px;/*设置填充和边距0px，确保能在浏览器之间兼容*/ margin: 0px;&#125;ul li&#123; background-image: url(图像名称);/*设置图像并设置它只显示一次*/ background-repeat: no-repeat; background-position: 0px 5px;/*定位图像位置*/ padding-left: 14px;/*把文本置于列表中*/&#125; 即解决浏览器兼容性问题可以从四个方面着手：浏览器CSS样式初始化、浏览器私有属性、CSS hack语法和自动化插件。 浏览器CSS样式初始化 在所有CSS开始前，先把margin和padding都设为0： 1234*&#123; margin:0; padding:0;&#125; 若不知道浏览器CSS样式要初始化哪些内容，建议直接引用Normalize.css库。 浏览器私有属性 -webkit-、-moz-、-ms-等是经常在CSS属性前加的一些前缀，这些就是浏览器的私有属性。 常用的前缀有： -moz：代表Firefox浏览器私有属性 -ms-：代表IE浏览器私有属性 -webkit：代表Chrome、Safari私有属性 -o：代表opera私有属性 要注意书写顺序，兼容性写法放到前面，标准写法放到最后： 12345-webkit-transform:rotate(-3deg);/*Chrome、Safari*/-moz-transform:rotate(-3deg);/*Firefox*/-ms-transform:rotate(-3deg);/*IE*/-o-transform:rotate(-3deg):/*opera*/transform:rotate(-3deg); CSS hack 除了以上的默认样式覆盖及私有属性添加，有时还需要针对不同浏览器甚至不同版本来编写特定的CSS样式，这一过程称之为CSS hack。在Web页面制作中尽量不要使用CSS Hack来处理兼容问题。 CSS hack的写法可归纳为以下几种：条件hack、属性级hack、选择符级hack。 条件hack 主要针对IE浏览器进行一些特殊的设置： 123&lt;!--[if &lt;keywords&gt;? IE &lt;version&gt;?]&gt; 代码块，可以是html、css、js&lt;![endif]--&gt; if后面跟的条件共包括6种选择方式： 是否：指定是否IE或IE某个版本。关键字：空 大于：选择大于指定版本的IE版本。关键字：gt 大于或等于：选择大于或等于指定版本的IE版本。关键字：gte 小于：选择小于指定版本的IE版本。关键字：lt 小于或等于：选择小于或等于指定版本的IE版本。关键字：lte 非指定版本：选择除指定版本外的所有IE版本。关键字：! 这里的版本是指IE浏览器版本，如6、7、8。注意IE10及以上版本已将条件注释特性移除： 12345678910111213141516&lt;!--[if IE]&gt; &lt;p&gt;在非IE中看不到这条文字&lt;/p&gt;&lt;![endif]--&gt;&lt;!--[if IE]&gt;&lt;style&gt; .test&#123; color:red; &#125;&lt;/style&gt;&lt;![endif]--&gt;&lt;!--[if IE 9]&gt; &lt;script src=\"//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js\"&gt;&lt;/script&gt; &lt;script src=\"//cdn.bootcss.com/respond.js/1.4.2/respond.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 属性hack 在CSS样式属性名前加上一些只有特定浏览器才能识别的hack前缀。 123selector&#123; &lt;hack&gt;?property:value&lt;hack&gt;?;&#125; 属性取值及浏览器支持情况如下： IE6 IE7 IE8 IE9 IE10 现代浏览器 * 支持 支持 + 支持 _ 支持 !important 支持 支持 支持 支持 支持 \\9 支持 支持 支持 支持 支持 \\0 支持 支持 支持 \\9\\0 支持 支持 注意书写顺序，低版本的兼容性写法放到最后： 12345.test&#123; color:#090\\9;/*IE6-IE10*/ *color:#f00;/*IE6-IE7*/ _color:#ff0;/*IE6及更早版本*/&#125; 选择符级hack 针对一些页面表现不一致或需要特殊对待的浏览器，在CSS选择器前加上一些只有某些特定浏览器才能识别的前缀进行hack： 123&lt;hack&gt; selector&#123; sRules&#125; 常见的选择符级hack有： 123456789*html /**前缀只对IE6生效*/*+html /**+前缀只对IE7生效*/@media screen\\9&#123;...&#125;/*只对IE6/7生效*/@media \\0screen\\,screen\\9&#123;body &#123; background: blue; &#125;&#125;/*只对IE6/7/8有效*/@media \\0screen &#123;body &#123; background: red; &#125;&#125;/*只对IE8有效*/@media screen\\0 &#123;body &#123; background: green; &#125;&#125; /*只对IE8/9/10有效*/@media screen and (min-width:0\\0) &#123;body &#123; background: gray; &#125;&#125; /*只对IE9/10有效*/@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) &#123;body &#123; background: orange; &#125;&#125; /*只对IE10有效*/ 例如： 123456*html .test&#123; color:#090;/*IE6及更早版本*/&#125;*+html .test&#123; color:#ff0;/*IE7*/&#125; 自动化插件 Autoprefixer是一款自动管理浏览器前缀的插件，它可以解析CSS文件并添加浏览器前缀到CSS内容里。该插件的安装和使用可在webpack指南中学习。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"http://tangmenjue.top/tags/CSS/"}]},{"title":"前端三件套之HTML（二）","slug":"前端三件套之HTML（二）","date":"2022-10-27T09:07:08.000Z","updated":"2022-11-10T15:49:32.496Z","comments":true,"path":"2022/10/27/前端三件套之HTML（二）/","link":"","permalink":"http://tangmenjue.top/2022/10/27/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97%E4%B9%8BHTML%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"HTML符号 HTML符号实体 若想将数学符号、希腊符号等符号添加到HTML页面，可以使用HTML实体名称。若不存在实体名称，可使用实体编号、十进制或十六进制进行引用。 12345678910&lt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;p&gt;我将显示 &amp;&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;我将显示 &amp;#8364;&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;我将显示 &amp;#x20AC;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&gt; 运行结果如下： 我将显示 &amp; 我将显示 € 我将显示 € HTML 支持的一些数学符号 字符 数字 实体 描述 ∀ &amp;#8704; &amp;forall; FOR ALL ∂ &amp;#8706; &amp;part; PARTIAL DIFFERENTIAL ∃ &amp;#8707; &amp;exist; THERE EXISTS ∅ &amp;#8709; &amp;empty; EMPTY SETS ∇ &amp;#8711; &amp;nabla; NABLA ∈ &amp;#8712; &amp;isin; ELEMENT OF ∉ &amp;#8713; &amp;notin; NOT AN ELEMENT OF ∋ &amp;#8715; &amp;ni; CONTAINS AS MEMBER ∏ &amp;#8719; &amp;prod; N-ARY PRODUCT ∑ &amp;#8721; &amp;sum; N-ARY SUMMATION HTML 支持的一些希腊字母 字符 数字 实体 描述 Α &amp;#913; &amp;Alpha; GREEK CAPITAL LETTER ALPHA Β &amp;#914; &amp;Beta; GREEK CAPITAL LETTER BETA Γ &amp;#915; &amp;Gamma; GREEK CAPITAL LETTER GAMMA Δ &amp;#916; &amp;Delta; GREEK CAPITAL LETTER DELTA Ε &amp;#917; &amp;Epsilon; GREEK CAPITAL LETTER EPSILON Ζ &amp;#918; &amp;Zeta; GREEK CAPITAL LETTER ZETA HTML 支持的一些其他实体。 字符 数字 实体 描述 © &amp;#169; &amp;copy; COPYRIGHT SIGN ® &amp;#174; &amp;reg; REGISTERED SIGN € &amp;#8364; &amp;euro; EURO SIGN ™ &amp;#8482; &amp;trade; TRADEMARK ← &amp;#8592; &amp;larr; LEFTWARDS ARROW ↑ &amp;#8593; &amp;uarr; UPWARDS ARROW → &amp;#8594; &amp;rarr; RIGHTWARDS ARROW ↓ &amp;#8595; &amp;darr; DOWNWARDS ARROW ♠ &amp;#9824; &amp;spades; BLACK SPADE SUIT ♣ &amp;#9827; &amp;clubs; BLACK CLUB SUIT ♥ &amp;#9829; &amp;hearts; BLACK HEART SUIT ♦ &amp;#9830; &amp;diams; BLACK DIAMOND SUIT HTML表格 表格由&lt;table&gt;标签来定义。每个表格均有由&lt;tr&gt;标签定义的若干行，每行被分隔为由&lt;td&gt;标签定义的若干单元格。字母td指表格数据，即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等。 HTML表格的基本结构 &lt;table&gt;..&lt;/table&gt;：定义表格 &lt;th&gt;..&lt;/th&gt;：定义表格的标题栏（文字加粗） &lt;tr&gt;..&lt;/tr&gt;：定义表格的行 &lt;td&gt;..&lt;/td&gt;：定义表格的列 边框属性： 若不定义边框属性，表格将不显示边框。若要显示边框，可使用border来显示。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;row1,cell1&lt;/td&gt; &lt;td&gt;row1,cell2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,cell1&lt;/td&gt; &lt;td&gt;row2,cell2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： row1,cell1 row1,cell2 row2,cell1 row2,cell2 表头单元格 表格的表头单元格使用&lt;th&gt;标签定义。 表格的表头单元格属性有：align、dir、width、height。 大多数浏览器会把表头显示为粗体居中的文本： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt; &lt;th&gt;Header 2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row1,cell1&lt;/td&gt; &lt;td&gt;row1,cell2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,cell1&lt;/td&gt; &lt;td&gt;row2,cell2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： Header 1 Header 2 row1,cell1 row1,cell2 row2,cell1 row2,cell2 表格标题 在&lt;table&gt;标签中可以使用&lt;caption&gt;...&lt;/caption&gt;标签作为标题，并在表的顶部显示出来。但此标签在较新版本的HTML/XHTML中已经弃用。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;table border=\"1\"&gt; &lt;caption&gt;这是标题&lt;/caption&gt; &lt;tr&gt; &lt;td&gt;row1,cell1&lt;/td&gt; &lt;td&gt;row1,cell2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,cell1&lt;/td&gt; &lt;td&gt;row2,cell2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： 这是标题 row1,cell1 row1,cell2 row2,cell1 row2,cell2 表格高度和宽度 在&lt;table&gt;标签中可以使用width（宽）和height（高）属性类设置表格宽度和高度，可以按像素或可用屏幕区域的百分比来指定表格宽度或高度： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;table border=\"1\" width=\"400\" height=\"150\"&gt; &lt;tr&gt; &lt;td&gt;row1,cell1&lt;/td&gt; &lt;td&gt;row1,cell2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,cell1&lt;/td&gt; &lt;td&gt;row2,cell2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： row1,cell1 row1,cell2 row2,cell1 row2,cell2 表格背景 设置HTML表格的背景有以下几种方法： bgcolor属性：为整个表格或仅为一个单元格设置背景颜色 background属性：为整个表设置背景图像或仅为一个单元设置背景图像，需要提供图像的URL地址。 bordercolor属性：设置边框颜色 但在HTML5中不推荐使用bgcolor、background和bordercolor，部分属性不会生效。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;table border=\"1\" bordercolor=\"green\" bgcolor=\"yellow\"&gt; &lt;!--&lt;table border=\"1\" bordercolor=\"green\" background=\"图像地址\"&gt;--&gt; &lt;tr&gt; &lt;td&gt;row1,cell1&lt;/td&gt; &lt;td&gt;row1,cell2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,cell1&lt;/td&gt; &lt;td&gt;row2,cell2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： row1,cell1 row1,cell2 row2,cell1 row2,cell2 表格空间 以下两个属性可用于调整HTML表格中单元格的空间： cellspacing属性：定义表格单元格之间的空间 cellpadding属性：表示单元格边框与单元格内容之间的距离 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;table border=\"1\" cellpadding=\"50\" cellspacing=\"5\"&gt; &lt;tr&gt; &lt;td&gt;row1,cell1&lt;/td&gt; &lt;td&gt;row1,cell2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,cell1&lt;/td&gt; &lt;td&gt;row2,cell2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 合并单元格 若要合并两列或更多列，可使用colspan属性。 若要合并两行或更多行，可使用rowspan属性。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;coulumn 1&lt;/th&gt; &lt;th&gt;coulumn 2&lt;/th&gt; &lt;th&gt;coulumn 3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=\"2\"&gt;row1,cell1&lt;/td&gt; &lt;td&gt;row1,cell2&lt;/td&gt; &lt;td&gt;row1,cell3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,cell2&lt;/td&gt; &lt;td&gt;row2,cell3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"3\"&gt;row3 cell1&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： coulumn 1 coulumn 2 coulumn 3 row1,cell1 row1,cell2 row1,cell3 row2,cell2 row2,cell3 row3 cell1 表格头部、主体、页脚 表格可氛围三个部分：头部、主体和页脚。其对应的标签是： &lt;thead&gt;：创建单独的表头 &lt;tbody&gt;：表示表格的主体 &lt;tfoot&gt;：创建一个单独的表页脚 表可以包含多个&lt;tbody&gt;元素以指示不同的页面，&lt;thread&gt;和&lt;tfoot&gt;标签应出现在&lt;tbody&gt;之前。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;table border=\"1\" width=\"100%\"&gt; &lt;thread&gt; &lt;tr&gt; &lt;td colspan=\"4\"&gt;This is the head of the table&lt;/td&gt; &lt;/tr&gt; &lt;/thread&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td colspan=\"4\"&gt;This is the foot of the table&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;cell1&lt;/td&gt; &lt;td&gt;cell2&lt;/td&gt; &lt;td&gt;cell3&lt;/td&gt; &lt;td&gt;cell4&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： This is the head of the table This is the foot of the table cell1 cell2 cell3 cell4 表格的嵌套 在一个表中是使用另一个表： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;table border=\"1\" width=\"100%\"&gt; &lt;tr&gt; &lt;td&gt; &lt;table border=\"1\" width=\"100%\"&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Salary&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;5000&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;7000&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： Name Salary 张三 5000 李四 7000 HTML表格标签总览 标签 描述 &lt;table&gt; 定义表格 &lt;th&gt; 定义表格的表头 &lt;tr&gt; 定义表格的行 &lt;td&gt; 定义表格单元 &lt;caption&gt; 定义表格标题 &lt;colgroup&gt; 定义表格列的组 &lt;col&gt; 定义用于表格列的属性 &lt;thead&gt; 定义表格的页眉 &lt;tbody&gt; 定义表格的主体 &lt;tfoot&gt; 定义表格的页脚 HTML列表 HTML支持有序列表、无序列表和自定义列表。 无序列表 无序列表是一个项目的列表，此列项目使用粗体原点进行标记。无序列表适合成员之间无级别顺序关系的情况，无序列表始于&lt;ul&gt;标签，每个列表项始于&lt;li&gt;标签： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Mikk&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： Coffee Mikk 有序列表 有序列表也是一列项目，列表项目使用数字进行标记。有序列表适合各项目之间存在顺序关系的情况，有序列表始于&lt;ol&gt;标签，每个列表项始于&lt;li&gt;标签： 123456789&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;ol&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ol&gt;&lt;/body&gt; &lt;/html&gt; 运行结果如下： Coffee Milk 自定义列表 自定义列表不仅仅是一列项目，而是项目及其注释的组合。&lt;dt&gt;与&lt;dd&gt;在自定义列表中的数量不限、对应关系不限。自定义列表始于&lt;dl&gt;标签，每个列表项始于&lt;dt&gt;标签，每个自定义列表项的定义始于&lt;dd&gt;： 1234567891011&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;dl&gt; &lt;dt&gt;Coffee&lt;/dt&gt; &lt;dd&gt;-black hot drink&lt;/dd&gt; &lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;-white cold drink&lt;/dd&gt; &lt;/dl&gt;&lt;/body&gt; &lt;/html&gt; 运行结果如下： HTML区块 &lt;div&gt;和&lt;span&gt;： HTML可以通过&lt;div&gt;和&lt;span&gt;将元素组合起来 区块元素 大多数HTML元素被定义为块级元素或内联元素。块级元素在浏览器显示时，通常会以新行来开始（和结束），如：&lt;h1&gt;、&lt;p&gt;、&lt;ul&gt;、&lt;table&gt; 内联元素 内联元素在显示时通常不以新行开始，如：&lt;b&gt;、&lt;td&gt;、&lt;a&gt;、&lt;img&gt; &lt;div&gt;元素 &lt;div&gt;标签可以把文档分割为独立的、不同的部分，它是块级元素，可用于组合其他HTML元素的容器，常用于文档布局。&lt;div&gt;元素没有特定的含义，与CSS一同使用时，&lt;div&gt;元素可用于对大的内容块设置样式属性。 1234567891011&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;这是一些文本。&lt;/p&gt; &lt;div style=\"color:#00ffff\"&gt; &lt;h3&gt;这是一个在div元素中的标题&lt;/h3&gt; &lt;p&gt;这是一个在div元素中的文本&lt;/p&gt; &lt;/div&gt; &lt;p&gt;这是一些文本。&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; 运行结果如下： &lt;span&gt;元素 &lt;span&gt;元素是内联元素，可用作文本的容器，&lt;span&gt;元素也没有特定的含义，与CSS一同使用时，&lt;span&gt;元素可用于为部分文本设置样式属性。 12345678910&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;我有一双 &lt;span style=\"color:gold\"&gt;金色&lt;/span&gt;的 &lt;span style=\"font-size:50px\"&gt;大眼睛&lt;/span&gt;和一头 &lt;span style=\"color:blue\"&gt;蓝色的头发&lt;/span&gt; &lt;/p&gt;&lt;/body&gt; &lt;/html&gt; 运行结果如下： 我有一双 金色的 大眼睛和一头 蓝色的头发 HTML布局 大多数网站可以使用&lt;div&gt;或&lt;table&gt;元素来创建多列。CSS用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观。 使用&lt;div&gt;元素 可以使用&lt;div&gt;元素来改变页面的布局，如使用5个div元素来创建多列布局： 12345678910111213141516171819202122&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;div id=\"container\" style=\"width:500px\"&gt; &lt;div id=\"header\" style=\"background-color:#FFA500;\"&gt; &lt;h1 style=\"margin-bottom:0;\"&gt;网页的标题&lt;/h1&gt; &lt;/div&gt; &lt;div id=\"menu\" style=\"background-color:#FFD700;height:200px;width:100px;float:left;\"&gt; &lt;b&gt;菜单&lt;/b&gt;&lt;br /&gt; HTML&lt;br /&gt; CSS&lt;br /&gt; JavaScript &lt;/div&gt; &lt;div id=\"content\" style=\"background-color:#EEEEEE;height:200px;width:400px;float:left;\"&gt; 内容在这里 &lt;/div&gt; &lt;div id=\"footer\" style=\"background-color:#FFA500;clear:both;text-align:center;\"&gt; Copyright &lt;/div&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 运行结果如下： 使用表格 123456789101112131415161718192021222324&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;table width=\"500\" border=\"0\"&gt; &lt;tr&gt; &lt;td colspan=\"2\" style=\"background-color:#FFA500;\"&gt; &lt;h1&gt;网页的主标题&lt;/h1&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=\"background-color:#FFD700;width:100px;\"&gt; &lt;b&gt;菜单&lt;/b&gt;&lt;br /&gt; HTML&lt;br /&gt; CSS&lt;br /&gt; JavaScript &lt;/td&gt; &lt;td style=\"background-color:#EEEEEE;height:200px;width:400px;\"&gt;内容就在这里&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\" style=\"background-color:#FFA500;text-align:center;\"&gt;Copyright&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt; &lt;/html&gt; 运行结果如下： 网页的主标题 菜单 HTML CSS JavaScript 内容就在这里 Copyright HTML表单 HTML表单用于收集不同类型的用户输入。 表单 表单是一个包含表单元素的区域，使用变大标签&lt;form&gt;来设置。表单元素允许用户在表单中输入内容，如文本域、下拉列表、单选框、复选框等。其形式如下： 12345&lt;form&gt; ... input elements ...&lt;/form&gt; 输入元素 多数情况下被用到的表单标签是输入标签&lt;input&gt;。&lt;input&gt;元素是最重要的表单元素，输入类型是由类型属性定义的。经常被用到的输入类型如下： 文本域 文本域通过&lt;input type=\"text\"&gt;标签来设定，当用户要在表单中键入字母、数字等内容时就会用到文本域： 123456789&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;form&gt; 姓名：&lt;input type=\"text\" name=\"firstname\"&gt;&lt;br /&gt; 电话号码：&lt;input type=\"text\" name=\"lastname\"&gt; &lt;/form&gt;&lt;/body&gt; &lt;/html&gt; 运行结果如下： 密码字段 密码字段通过标签&lt;input type=\"password\"&gt;来定义，密码字段字符不会明文显示，而是以星号或圆点替代： 12345678&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;form&gt; 密码：&lt;input type=\"password\" name=\"pwd\"&gt;&lt;br /&gt; &lt;/form&gt;&lt;/body&gt; &lt;/html&gt; 运行结果如下： 密码： 单选按钮 表单单选框选项通过&lt;input type=\"radio\"&gt;来定义： 123456789&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;form&gt; &lt;input type=\"radio\" name=\"sex\" value=\"male\"&gt;男&lt;br /&gt; &lt;input type=\"radio\" name=\"sex\" value=\"female\"&gt;女 &lt;/form&gt;&lt;/body&gt; &lt;/html&gt; 运行结果如下： 男 女 复选框 复选框通过&lt;input type=\"checkbox\"&gt;来定义，用户需要从若干给定的选择中选取一个或若干个选项： 123456789&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;form&gt; &lt;input type=\"checkbox\" name=\"vehicle\" value=\"Bike\"&gt;我有自行车&lt;br /&gt; &lt;input type=\"checkbox\" name=\"vehicle\" value=\"Car\"&gt;我有小车 &lt;/form&gt;&lt;/body&gt; &lt;/html&gt; 运行结果如下： 我有自行车 我有小车 提交按钮 提交按钮通过&lt;input type=\"submit\"来定义，当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名，由目的文件通常会对接收到的输入数据进行相关的处理： 123456789&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;form name=\"input\" action=\"目标文件名\" method=\"get\"&gt; Username:&lt;input type=\"text\" name=\"User\"&gt; &lt;input type=\"submit\" value=\"按钮名称\"&gt; &lt;/form&gt;&lt;/body&gt; &lt;/html&gt; 运行结果如下： Username: HTML框架 &lt;iframe&gt;标签规定一个内联框架。一个内联框架被用来在当前HTML文档中嵌入另一个文档。通过使用框架可以在浏览器窗口中显示不止一个页面。语法如下： 12&lt;iframe src=\"URL\"&gt;&lt;/iframe&gt;&lt;!--该URL指向不同的网页，将窗口内容显示为URL地址指向页面--&gt; 设置高度与宽度 height和width属性用来定义iframe标签的高度与宽度。属性默认以像素为单位，但也可以指定其按比例显示，如“80%”： 123456&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;iframe src=\"tangmenjue.top.html\" width=\"80%\" height=\"80%\"&gt;&lt;/iframe&gt;&lt;/body&gt; &lt;/html&gt; 运行结果如下： 移除边框 frameborder属性用于定义iframe表示是否显示边框。设置属性值为0时，移除iframe边框： 123456&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;iframe src=\"tangmenjue.top.html\" frameborder=\"0\"&gt;&lt;/iframe&gt;&lt;/body&gt; &lt;/html&gt; 使用iframe来显示目录链接页面 iframe可以显示是一个目标链接的页面。目标链接的属性必须使用iframe属性： 123456789&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;iframe src=\"tangmenjue.top.html\" name=\"iframe_a\"&gt;&lt;/iframe&gt; &lt;p&gt; &lt;a href=\"http://tangmenjue.top/2020/01/09/hello-world/\" target=\"iframe_a\"&gt;tangmenjue.top&lt;/a&gt; &lt;/p&gt;&lt;/body&gt; &lt;/html&gt; iframe标准属性 属性 说明 class 规定元素的类名（classname） id 规定元素的唯一 id style 规定元素的行内样式（inline style） title 规定元素的额外信息（可在工具提示中显示） HTML颜色 HTML颜色采用的是RGB颜色，是通过对红绿蓝三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色。 Color Values HTML颜色由一个十六进制符号来定义，这个符号由红绿蓝的值组成。每种颜色的最小值是0（十六进制：#00），最大值是255（十六进制：#FF）。在项目过程中若要查询颜色码时，可以使用RGB颜色值与十六进制颜色码转换工具来查询。 颜色名 目前所有浏览器都支持以下颜色名： 141个颜色名称是在HTML和CSS颜色规范定义的（17标准颜色+其余的124种），其中17标准颜色为：黑色，蓝色，水，紫红色，灰色，绿色，石灰，栗色，海军，橄榄，橙，紫，红，白，银，蓝绿色，黄色。 141个颜色的颜色名及其对应的16进制值可使用RGB颜色对照表来查询。 HTML脚本 JavaScript是可插入HTML页面的编程代码，其使HTML页面具有更强的动态和交互性。 &lt;script&gt;标签 &lt;script&gt;标签用于定义客户端脚本，&lt;script&gt;元素既可包含脚本语句，也可通过src属性指向外部脚本文件，若使用src属性，则&lt;script&gt;元素必须是空的。JavaScript常用于图片操作、表单验证以及内容动态更新： 12345678&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;script&gt;document.write(\"Hello world!\") &lt;/script&gt;&lt;/html&gt;&lt;!--运行结果如下--&gt;Hello world! &lt;noscript&gt;标签 当浏览器禁用脚本或浏览器不支持客户端脚本时，&lt;noscript&gt;标签提供无法使用脚本时的替代内容。&lt;noscript&gt;元素支持全局属性，可包含普通HTML页面的body元素中能找到的所有元素。只有在浏览器禁用脚本或不支持客户端脚本时，才会显示&lt;noscript&gt;元素中的内容： 1234567&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;script&gt;document.write(\"Hello world!\") &lt;/script&gt;&lt;noscript&gt;Sorry,your browser does not support JavaScript!&lt;/noscript&gt;&lt;/html&gt; JavaScript示例代码 JavaScript直接在HTML输出： 12345678&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;script&gt;document.write(\"Hello world!\")document.write(\"&lt;h1&gt;这是一个标题&lt;/h1&gt;\");document.write(\"&lt;p&gt;这是一个段落。&lt;/p&gt;\"); &lt;/script&gt;&lt;/html&gt; JavaScript事件响应： 123456789101112&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;p id=\"demo\"&gt;JavaScript can react to events.Like the click of a button.&lt;/p&gt;&lt;script&gt; function myFunction() &#123; document.getElementById(\"demo\").innerHTML=\"Hello JavaScript!\"; &#125;&lt;/script&gt;&lt;button type=\"button\" onclick=\"myFunction()\"&gt;Click Me!&lt;/button&gt;&lt;/html&gt; JavaScript处理HTML样式： 12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;p id=\"demo\"&gt;JavaScript can change the css.Like the click of a button.&lt;/p&gt;&lt;script&gt; function myFunction() &#123; x=document.getElementById(\"demo\") x.style.color=\"#FF0000\" &#125;&lt;/script&gt;&lt;button type=\"button\" onclick=\"myFunction()\"&gt;Click Me!&lt;/button&gt;&lt;/html&gt; 对于老式浏览器 若浏览器没法识别&lt;script&gt;标签，那么&lt;script&gt;标签所包含的内容将以文本方式显示在页面上。为了避免这种情况发送，应将脚本隐藏在注释标签中。老式浏览器将忽略这些注释，便不会将标签的内容显示到页面上，而新版本的浏览器将会读懂这些脚本而执行它们，即使代码嵌套在注释标签内： 123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt; &lt;p id=\"demo\"&gt;JavaScript can change the css.Like the click of a button.&lt;/p&gt;&lt;script type=\"text/javascript\"&gt; //&lt;!-- function myFunction() &#123; x=document.getElementById(\"demo\") x.style.color=\"#FF0000\" &#125; //--&gt;&lt;/script&gt;&lt;button type=\"button\" onclick=\"myFunction()\"&gt;Click Me!&lt;/button&gt;&lt;/html&gt; HTML字符实体 HTML中的预留字符必须被替换为字符实体，一些在键盘上找不到的字符也可以用字符实体来替换，实体名称对大小写敏感。 HTML实体 在HTML中，某些字符是保留的，不能使用包含这些字符的文本。 在HTML中不能使用小于号和大于号，浏览器会误以为它们是标签。若希望正确地显示预留字符，则必须在HTML源代码中使用字符实体，字符实体类似于：&amp;entiy_name或&amp;#entity_number;。若要显示小于号，必须写成：&amp;lt;或&amp;#60;或&amp;#060;。 一些字符实体如下： 显示结果 描述 实体名称 实体编号 空格 &amp;nbsp; &amp;#160; &lt; 小于号 &amp;lt; &amp;#60; &gt; 大于号 &amp;gt; &amp;#62; &amp; 和号 &amp;amp; &amp;#38; \" 引号 &amp;quot; &amp;#34; ' 撇号 &amp;apos; (IE不支持) &amp;#39; ￠ 分 &amp;cent; &amp;#162; £ 镑 &amp;pound; &amp;#163; ¥ 人民币/日元 &amp;yen; &amp;#165; € 欧元 &amp;euro; &amp;#8364; § 小节 &amp;sect; &amp;#167; © 版权 &amp;copy; &amp;#169; ® 注册商标 &amp;reg; &amp;#174; ™ 商标 &amp;trade; &amp;#8482; × 乘号 &amp;times; &amp;#215; ÷ 除号 &amp;divide; &amp;#247; 不间断空格 HTML中常用字符实体是不间断空格。 浏览器会截断HTML页面中的空格。若要在页面增加空格的数量，可以使用字符实体&amp;nbsp; 结合音标符 发音符号是加到字母上的一个字形。 一些变音符号，如尖音符 ( ̀) 和 抑音符 ( ́) 。 变音符号可以出现在字母的上面和下面、字母里面或两个字母间。 变音符号可以与字母、数字字符的组合来使用。 一些音标符如下： 音标符 字符 Construct 输出结果 ̀ a à à ́ a á á ̂ a a&amp;#770; â ̃ a a&amp;#771; ã ̀ O O&amp;#768; Ò ́ O O&amp;#769; Ó ̂ O O&amp;#770; Ô ̃ O O&amp;#771; Õ HTML URL URL是一个网页网站，可以由字母组成，也可以由ip地址组成。大多数人进入网站使用网站域名来访问。 URL（统一资源定位器） Web浏览器通过URL从Web服务器请求页面。当您点击HTMl页面中的某个链接时，对应的&lt;a&gt;标签指向万维网上的一个地址。URL用于定位万维网上的文档。 URL的语法规则： 1scheme://host.domain:port/path/filename 其中： scheme:定义因特网服务的类型，最常见的类型是http host：定义域主机（http的默认主机是www） domain：定义因特网域名，比如tangmenjue.top :port：定义主机上的端口号（http默认端口号是80） path：定义服务器上的路径（如果省略，则文档必须位于网站的根目录中） filename：定义文档/资源的名称 常见的scheme类型如下： Scheme 访问 用于 http 超文本传输协议 以 http:// 开头的普通网页。不加密。 https 安全超文本传输协议 安全网页，加密所有信息交换。 ftp 文件传输协议 用于将文件下载或上传至网站。 file 您计算机上的文件。 URL字符编码 URL只用使用ASCII字符集。 URL编码会将字符转换为可通过因特网传输的格式来通过因特网进行发送。由于URL常包含ASCII集合以外的字符，URL必须转换为有效的ASCII格式。 URL编码使用\"%\"号及其后跟随两位的十六进制数来替换非ASCII字符，URL不能包含空格，常用“+”号来替换空格。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"HTML","permalink":"http://tangmenjue.top/tags/HTML/"}]},{"title":"前端三件套之HTML（一）","slug":"前端三件套之HTML（一）","date":"2022-10-26T09:07:08.000Z","updated":"2022-11-10T15:49:29.048Z","comments":true,"path":"2022/10/26/前端三件套之HTML（一）/","link":"","permalink":"http://tangmenjue.top/2022/10/26/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97%E4%B9%8BHTML%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"HTML简介 HTML是指超文本标记语言，是用来描述网页的一种语言。可以使用HTML来建立Web站点，HTML运行在浏览器上，有浏览器来解析。 HTML不是一种编程语言，而是一种标记语言，它有一套标记标签。 HTML使用标记标签来描述网页。 HTML文档包含了HTML标签及文本内容，HTML文档也叫做web页面。 HTML文档的后缀名包含.html（常用）、.htm。 HTML网页结构 一个可视化HTML页面结构实例如下： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;这是页面标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;p&gt;这是一个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 上述语句的含义如下： &lt;!DOCTYPE html&gt;声明为HTML5文档，doctype声明是不区分大小写的。 &lt;html&gt;与&lt;/html&gt;之间的文本用来描述网页。 &lt;head&gt;与&lt;/head&gt;之间的文本用来描述文档的元数据(meta)。可以包含脚本、样式、meta信息以及其他更多的信息。 &lt;meta&gt;标签提供了HTML文档的元数据。元数据会被浏览器解析，但不会显示在客户端。对于中文网页需要使用&lt;meta charset=\"utf-8\"&gt;定义网页编码格式为utf-8，否则会出现乱码。 &lt;title&gt;与&lt;/title&gt;之间的 文本描述文档的标题。(&lt;head&gt;中必须包含&lt;title&gt;) &lt;body&gt;与&lt;/body&gt;之间的文本是可见的页面内容。 &lt;h1&gt;与&lt;/h1&gt;之间的文本被显示为一个大标题。 &lt;p&gt;与&lt;/p&gt;之间的文本被显示为一个段落。 代码运行结果如下： HTML标签 HTML标记标签通常被称为HTML标签。 HTML标签是由尖括号包围的关键词，如&lt;html&gt;。 HTML标签通常是成对出现的，如&lt;b&gt;和&lt;/b&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签，开始和结束标签也被称为开放标签和闭合标签。 标签的具体格式为：&lt;标签&gt;内容&lt;/标签&gt;。 web浏览器 web浏览器用于读取HTML文件，并将其作为网页显示。 web不会直接显示HTML标签，而是通过使用标签来决定如何向用户展现HTML页面的内容。 &lt;!DOCTYPE&gt;声明 &lt;!DOCTYPE&gt;是标准通用标记语言的文档类型声明，有助于在浏览器中正确地显示网页。由于网络上文件的类型不一，因此需要正确的声明HTML版本，以便浏览器能够正确识别并显示网页内容。doctype声明不区分大小写。在html页面的头部声明字符为UTF-8可以解决浏览器中出现中文乱码的现象。 HTML基础 HTML标题 HTML标题是通过&lt;h1&gt;-&lt;h6&gt;标签来定义的。 h是英文header标题的缩写，有六个标题元素标签：&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;、&lt;h6&gt;。每个元素代表文档中不同级别的内容：如&lt;h1&gt;代表主标题，&lt;h2&gt;代表二级子标题，&lt;h3&gt;代表三级子标题、&lt;h4&gt;、&lt;h5&gt;、&lt;h6&gt;的字体大小依次递减。 注意： 应该只对每个页面使用一次&lt;h1&gt;主标题。所有其他标题位于层次结构中的下方。 确保在层次结构中以正确的顺序使用标题。如不要使用&lt;h3&gt;来表示副标题后，使用&lt;h2&gt;来表示副副标题。 在可用的六个标题级别中，保证每个页面中标题级别的使用不超过三个。具有许多标题类别的文档会变得难以操作并难以导航，在这种情况下，若可能的话把内容分散在多个页面上。 浏览器会自动地在标题的前后添加空行。默认情况下，HTML会自动在块级元素前后添加一个额外的空行，如段落、标题元素前后。 不要为了生成粗体或大号的文本而使用标题。 HTML中的空格 无论在HTML中使用多少空格（包括空格字符、换行等），当渲染代码时，HTML解释器会将连续出现的空格字符减少为一个单独的空格符。 在HTML中，每个嵌套的元素是以两个空格缩进的。 HTML图像 HTML图像是通过标签&lt;img&gt;来定义的。&lt;img&gt;标签有两个必需的属性：src和alt。。img元素是自关闭元素，不需要结束标记。 图像标签（&lt;img&gt;）和源属性（src） &lt;img&gt;是空标签，它只包含属性，没有闭合标签。 使用img元素来在网站中添加图片，使用src属性来指向一个图片的具体地址，图像的名称和尺寸以属性的形式提供。定义图像的语法是 1&lt;img src=\"存储图片的位置\" alt=\"some_text\"&gt; 浏览器将图像显示在文档中图像标签出现的地方。如果将图像标签置于两个段落之间，浏览器会首先显示第一个段落，然后显示图片，最后显示第二段。 alt属性 alt属性用来为图像定义一串预备的可替换的文本。替换文本属性的值是用户定义的。在浏览器无法载入图像时，替换文本属性告诉读者所失去的信息。此时浏览器将显示替代性的文本而不是图像。 设置图像的高度与宽度 height（高度）与width（宽度）属性用于设置图像的高度与宽度。属性值默认单位为像素： 1&lt;img src=\"pulpit.jpg\" alt=\"Pulpit rock\" width=\"304\" height=\"228\"&gt; 设置图像边框 在&lt;img&gt;标签中使用border属性以像素为单位指定边框粗细。厚度为0时表示图片周围没有边框： 1&lt;img src=\"pulpit.jpg\" alt=\"Pulpit rock\" border=\"3\"&gt; 设置图像对齐 默认情况下，图像在页面中将显示为左侧对齐，在&lt;img&gt;标签中可以使用align属性设置图像的对齐方式：center（居中）或right（右侧）。 1&lt;img src=\"pulpit.jpg\" alt=\"Pulpit rock\" align=\"right\"&gt; HTML强调 HTML中强调一句话的某些词可以使用em元素来标记，浏览器默认风格为斜体： 123456&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;我&lt;em&gt;很高兴&lt;/em&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 除此之外，开可以使用&lt;strong&gt;元素来标记，浏览器默认风格为粗体： 123456&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;我&lt;strong&gt;很高兴&lt;/strong&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML注释 将注释插入HTML代码中，可以提高代码可读性。浏览器会忽略注释，也不会显示它们。其格式为： 1&lt;!--注释内容--&gt; 条件注释 条件注释定义是由Internet Explorer浏览器执行的HTML标签。 123&lt;!--[if IE 8]&gt; ....some HTML here....&lt;![endif]--&gt; HTML段落 HTML段落是通过标签&lt;p&gt;来定义的，经常被用来创建一个段落。 HTML换行 若希望在不产生新起点的情况下进行换行（新行），可以使用&lt;br /&gt;标签。 在HTML中，&lt;br /&gt;标签定义为一个换行符。可以简单的输入一个空行，而不是用来对内容进行拆分： 123456&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;这个&lt;br&gt;段落&lt;br /&gt;演示了换行的效果&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 在HTML中，由于屏幕的大小、对窗口的调整都可能导致不同的结果，因此无法确定HTML被显示的效果。当显示页面时，浏览器会移动源代码中多余的空间和空行。所有连续的空间或空行都会被算作一个空格。 HTML水平线 &lt;hr&gt;标签在HTML页面中创建水平线。 hr元素用于分隔内容，使用该元素产生的水平线可以在视觉上将文档分隔成各个部分。 12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;hr标签定义水平线：&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;这是段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 如何查看源代码 在浏览器中可以通过单击右键，然后选择\"查看源文件\"或\"查看页面源代码\"来打开一个包含页面HTML代码的窗口来查看源代码。 HTML元素 HTML标签和HTML元素通常都是描述相同的意思。但严格来讲，一个HTML元素包含了开始标签和结束标签。 HTML元素语法 HTMl元素以开始标签起始，以结束标签终止。 元素的内容是开始标签与结束标签之间的内容。 某些HTML元素具有空内容。 空元素在开始标签中进行关闭，以开始标签的结束而结束。 大多数HTML元素可拥有属性。 嵌套的HTML元素 HTML文档由嵌套的HTML元素构成，即一个HTML元素里可以包含其他HTML元素。例如下面的代码中包含了三个HTML元素： 123456&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;这是第一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; HTML空元素 HTML空元素即为没有内容的HTML元素。 HTML空元素应该在开始标签中关闭。 HTML的一个空元素为&lt;br&gt;（用于定义换行），&lt;br&gt;元素是没有关闭标签的空元素。 HTML空元素的关闭方法是在剋是标签中添加斜杠，例如&lt;br/&gt;，HTML、XHTML和XML都接受这种方式。 在XHTML和XML以及未来版本的HTML中，所有元素都必须被关闭，即使是空元素。 使用小写标签 HTML标签对英文字母的大小写不敏感：&lt;P&gt;等同于&lt;p&gt;。 随着HTML4甚至是HTML5的普及，后续的网站都遵循HTML4的语法--使用小写。 HTML头部 HTML头部元素包含关于文档的概要信息，也被称为元信息。 &lt;head&gt;标签与&lt;header&gt;标签的不同 head标签用于定义文档头部，是所有头部元素的容器。&lt;head&gt;描述了文档的各种属性和信息 header标签定义文档的页眉（介绍信息）。 &lt;head&gt;元素 &lt;head&gt;元素包含了所有的头部标签元素。在&lt;head&gt;元素中可以插入脚本（scripts）、样式文件（CSS）以及各种meta信息。其描述了文档的各种属性和信息，其中包括文档的标题、在Web中的位置以及和其他文档的关系等。 可以添加在头部区域的元素标签为：&lt;title&gt;、&lt;style&gt;、&lt;meta&gt;、&lt;link&gt;、&lt;script&gt;、&lt;noscript&gt;和&lt;base&gt;。 &lt;title&gt;元素 &lt;title&gt;标签定义了不同文档的标题，其在HTML/XHTML中是必须的。 &lt;title&gt;元素 定义了浏览器工具栏的标题 当网页添加到收藏夹时，显示在收藏夹中的标题 显示在搜索引擎结果页面的标题 &lt;title&gt;元素还可以在左侧显示logo等图片，显示时要将&lt;link&gt;标签放入&lt;head&gt;里： 1234567&lt;!doctype HTML&gt;&lt;html&gt;&lt;head&gt;&lt;link rel=\"shortcut icon\" href=\"图片url\"&gt; &lt;title&gt;这是一个带图片的标签&lt;/title&gt; &lt;/head&gt; &lt;/html&gt; &lt;base&gt;元素 &lt;base&gt;标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接规定默认地址或默认目标(target)： 123456&lt;!doctype HTML&gt;&lt;html&gt;&lt;head&gt; &lt;base href=\"链接地址\" target=\"_blank\"&gt; &lt;/head&gt; &lt;/html&gt; 在HTML中，&lt;base&gt;标签没有结束标签，但在XHTML中，&lt;base&gt;标签必须被正确地关闭。 &lt;link&gt;元素 &lt;link&gt;标签定义了文档与外部资源之间的关系，通常用于链接到样式表： 123456&lt;!doctype HTML&gt;&lt;html&gt;&lt;head&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"tips.css\"&gt; &lt;/head&gt; &lt;/html&gt; &lt;style&gt;元素 &lt;style&gt;标签定义了HTML文档的样式文件引用地址。在&lt;style&gt;元素中需要指定特定样式文件来渲染HTML文档： 12345678910&lt;head&gt;&lt;style type=\"text/css\"&gt;body&#123; background-color:yellow; &#125;p&#123; color:blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;meta&gt;元素 &lt;meta&gt;元素又称为元数据，其是关于数据的信息。&lt;meta&gt;标签始终位于head元素中。 &lt;meta&gt;标签提供关于HTML文档的元数据。元数据不会显示在页面上，但对于机器是可读的。meta元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词）或其他Web服务。 针对搜索引擎的关键词 一些搜索引擎会用meta元素中用来描述页面内容的name和content属性来索引页面： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;!--meta元素定义页面的描述--&gt;&lt;meta name=\"description\" content=\"Free web tutorials on HTML,CSS,XML\" /&gt;&lt;!--meta元素定义页面的关键词--&gt;&lt;meta name=\"keywords\" content=\"HTML,CSS,XML\" /&gt; &lt;/head&gt; &lt;/html&gt; &lt;script&gt;元素 &lt;script&gt;标签用于加载脚本文件 HTML属性 属性是为HTML元素提供的附加信息。 HTML元素可以设置属性 属性可以在元素中添加信息 属性一般描述于开始标签 属性总是以名称/值对的形式出现，如name=\"value\"。 属性实例 HTML链接由&lt;a&gt;标签定义。链接的地址在href属性中指定： 123456&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"链接的地址\"&gt;这是一个链接使用了href属性&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; HTML属性常用引用属性值 属性值应该始终被包含在引号内，最常用的是双引号。在某些个别情况下，比方说属性值本身就含有双引号时，必须使用单引号。例如：name='John\"ShotGun\"Nelson'。 使用小写属性 属性和属性值对大小写不敏感。 但万维网联盟在其HTML4中推荐标准小写的属性/属性值。新版本的(X)HTML也要求使用小写属性。 HTML属性参考手册 下面列出了适用于大多数 HTML 元素的属性： 属性 描述 class 为html元素定义一个或多个类名（classname）(类名从样式文件引入) id 定义元素的唯一id style 规定元素的行内样式（inline style） title 描述了元素的额外信息 (作为工具条使用) id属性 id属性可用于为HTML元素指定唯一的id，一个HTML文档中不能存在多个有相同id的元素。 使用id属性 id属性的值在HTML文档中必须是唯一的。其用于指向样式表中的特定样式声明，JavaS也可使用它来访问和操作拥有特定ID的元素。 id的语法是一个井号后面跟一个id名称，然后在花括号{}中定义CSS属性。如： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;#tips&#123; background-color:lightblue; color:black; padding: 40px; text-align: center;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--在HTML文档中插入ID--&gt; &lt;a id=\"tips\"&gt;Useful Tips Section&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 注意： id名称对大小写敏感 id必须包含至少一个字符，且不能包含空白字符（空格、制表符等） Class与ID的差异 同一个类名可以由多个HTML元素使用，而一个id名称只能由页面中的一个HTML元素使用。 通过ID和链接实现HTML书签 HTML书签用于让读者跳转到网页的特定部分： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;!--创建一个来链接跳转到(id=\"tips\")的部分--&gt; &lt;a href=\"#tips\"&gt;Visit the Useful Tips Section&lt;/a&gt; &lt;br /&gt; &lt;!--从另一个页面创建一个链接到(id=\"tips\")的部分--&gt; &lt;a href=\"链接地址#tips\"&gt;Visit the Useful Tips Section&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 在JavaScript中使用id属性 JavaScript也可以使用id属性为特定元素执行某些任务，可以使用getElementById()方法访问拥有特定id的元素： 12345&lt;script&gt;function displayResult()&#123; document.getElementById(\"tips\").innerHTML=\"Have a nice day!\";&#125; &lt;/script&gt; HTML链接 HTML链接是通过标签&lt;a&gt;来定义的。其具体格式如下： 123456&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"链接的地址\"&gt;这是一个链接&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，可以点击这些内容来跳转到新的文档或当前文档中的某个部分。 默认情况下，链接在浏览器中表现为以下形式： 一个未访问过的链接显示为蓝色字体并带有下划线 访问过的链接显示为紫色并带上下划线 点击链接时，链接显示为红色并带上下划线 若为这些超链接设置了CSS样式，展示样式会根据CSS的设定来显示。 HTML空链接 空链接即指当鼠标指向链接后，会变成手性，但单机后仍停留在当前页面。 123456&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"#\"&gt;这是一个空链接&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; target属性 使用Target属性，可以定义被链接的文档在何处显示（在新窗口打开，还是在原有的窗口中打开）。 1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"链接地址\" target=\"\"&gt;这是一个链接&lt;/a&gt; &lt;!--默认在原窗口打开，若将target属性设置为\"_blank\"，链接将在新窗口打开--&gt;&lt;/body&gt;&lt;/html&gt; 注意：始终将正斜杠添加到子文件夹，如href=\"//www.baidu.com/html/\"。若写成href=\"//www.baidu.com/html\"，就会向服务器产生两次HTTP请求。 HTML文本格式化 HTML格式化标签 HTML使用标签&lt;b&gt;与&lt;i&gt;对输出的文本进行粗体或斜体的格式化，这些标签被称为格式化标签。 通常&lt;strong&gt;替换加粗标签&lt;b&gt;来使用，&lt;em&gt;替换&lt;i&gt;标签使用。 HTML 文本格式化标签 标签 描述 &lt;b&gt; 定义粗体文本 &lt;em&gt; 定义着重文字 &lt;i&gt; 定义斜体字 &lt;small&gt; 定义小号字 &lt;strong&gt; 定义加重语气 &lt;sub&gt; 定义下标字 &lt;sup&gt; 定义上标字 &lt;ins&gt; 定义插入字 &lt;del&gt; 定义删除字 HTML \"计算机输出\" 标签 标签 描述 &lt;code&gt; 定义计算机代码 &lt;kbd&gt; 定义键盘码 &lt;samp&gt; 定义计算机代码样本 &lt;var&gt; 定义变量 &lt;pre&gt; 定义预格式文本 HTML 引文, 引用, 及标签定义 标签 描述 &lt;abbr&gt; 定义缩写 &lt;address&gt; 定义地址 &lt;bdo&gt; 定义文字方向 &lt;blockquote&gt; 定义长的引用 &lt;q&gt; 定义短的引用语 &lt;cite&gt; 定义引用、引证 &lt;dfn&gt; 定义一个定义项目。 HTML CSS CSS定义如何显示HTML元素，用于渲染HTML元素标签的样式，用于控制Web页面的外观。样式存储在样式表中，通常放在&lt;head&gt;部分或存储在外部CSS文件中。目前的网页大都由前端三件套HTML+CSS+Javascript组成。其中，HTML是网页的结构，CSS是网页的样式，Javascript控制网页的行为。 CSS添加到HTML的方式 内联样式：在HTML元素中使用“style”属性 内部样式表：在HTML文档头部&lt;head&gt;区域使用&lt;style&gt;元素来包含CSS 外部引用：使用外部CSS文件 内联样式 当特殊的样式需要应用到个别元素时，可以使用内联样式。使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何CSS属性： 123456&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p style=\"color:blue;margin-left:20px;\"&gt;Tips&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; CSS样式标签 标签 描述 background 定义元素的背景颜色 font-family 定义字体的样式 color 定义元素的颜色 font-size 定义字体的大小 text-align 指定文本的水平与垂直对齐方式 内部样式表 当单个文件需要特别样式时，可以使用内部样式表。在HTML文档头部&lt;head&gt;区域使用&lt;style&gt;元素来定义内部样式表 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;body&#123; background-color: yellow;&#125;p&#123; color: blue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Tips&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 外部样式表 当样式需要被应用到很多页面时，可以使用外部样式表。通过只更改一个文件来改变整个站点的外观： 12345678910&lt;!doctype HTML&gt;&lt;html&gt;&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"tip.css\"&gt;&lt;!--导入外部样式表的另一种方式--&gt; &lt;style&gt; @import url(\"样式表路径\")&lt;/style&gt; &lt;/head&gt; &lt;/html&gt; link和@import之间的区别 link属于XHTML标签，而@import是CSS提供的一种方式 当一个页面被加载时，link引用的CSS会同时被加载。而@import引用的CSS会等到页面全部下载完才被加载 @import是CSS2.1提出的，与老版本的浏览器不兼容，只能在IE5以上的浏览器被识别，link在任何地方都兼容 当使用Javascript控制dom去改变样式时，只能使用link标签 已弃用的标签和属性 在HTML4中，原来支持定义HTML元素样式的标签和属性已被弃用。 不建议使用的标签有：&lt;font&gt;、&lt;center&gt;、&lt;strike&gt;。 不建议使用的属性有：color和bgcolor。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"HTML","permalink":"http://tangmenjue.top/tags/HTML/"}]},{"title":"python学习笔记(十三)","slug":"python学习笔记（十三）","date":"2022-10-24T09:44:36.000Z","updated":"2022-12-06T12:39:54.244Z","comments":true,"path":"2022/10/24/python学习笔记（十三）/","link":"","permalink":"http://tangmenjue.top/2022/10/24/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/","excerpt":"","text":"常用内建模块 datetime datetime是python处理时间和日期的标准库。 获取当前日期和时间 12345from datetime import datetimenow=datetime.now()print(now)#运行结果如下：2022-10-13 16:01:58.422125 获取指定日期和时间 12345from datetime import datetimedt=datetime(2022,4,19,12,22)print(dt)#运行结果如下：2022-04-19 12:22:00 datetime转换为timestamp 在计算机中时间是用数字表示的，1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为0，当前时间就是相对于epoch time的秒数称为timestamp。 12345from datetime import datetimedt=datetime(2022,4,19,12,22)print(dt.timestamp())#运行结果如下：1650342120.0 timestamp转换为datetime 12345from datetime import datetimedt=1650342120.0print(datetime.fromtimestamp(dt))#运行结果如下：2022-04-19 12:22:00 str转换为datetime 12345from datetime import datetimedt=datetime.strptime('2022-04-19 12:22:00','%Y-%m-%d %H:%M:%S')print(dt)#运行结果如下：2022-04-19 12:22:00 datetime转换为str 12345from datetime import datetimenow=datetime.now()print(now.strftime('%a, %b %d %H:%M'))#运行结果如下：Thu, Oct 13 16:13 datetime加减 1234567891011from datetime import datetime,timedeltanow=datetime.now()print(now)print(now+timedelta(hours=10))print(now+timedelta(days=1))print(now+timedelta(days=2,hours=12))#运行结果如下：2022-10-13 16:17:44.3445502022-10-14 02:17:44.3445502022-10-14 16:17:44.3445502022-10-16 04:17:44.344550 本地时间转换为UTC时间 本地时间是指系统设定时区的时间，如北京时间是UTC+8:00，UTC时间是指UTC+0:00时区的时间。 123456789from datetime import datetime,timedelta,timezonetz_utc_8=timezone(timedelta(hours=8))now=datetime.now()print(now)dt=now.replace(tzinfo=tz_utc_8)print(dt)#运行结果如下：2022-10-13 16:25:07.6884762022-10-13 16:25:07.688476+08:00 时区转换 12345678from datetime import datetime,timedelta,timezoneutc_dt=datetime.utcnow().replace(tzinfo=timezone.utc)#拿到utc时间并设置时区为UTC+0:00print(utc_dt)bj_dt=utc_dt.astimezone(timezone(timedelta(hours=8)))#将转换时区为北京时间print(bj_dt)#运行结果如下：2022-10-13 08:28:08.363061+00:002022-10-13 16:28:08.363061+08:00 collections collections是Python内建的一个集合模块，提供了许多有用的集合类。 namedtuple namedtuple是一个函数，用来创建一个自定义的tuple对象，并规定了tuple元素的个数，可以用属性而不是索引来引用tuple的某个元素： 1234567891011121314from collections import namedtuplePoint=namedtuple('Point',['x','y'])Circle=namedtuple('Circle',['x','y','r'])p=Point(1,2)c=Circle(1,2,3)print(isinstance(p,Point))print(isinstance(p,tuple))print(p.x,p.y)print(c.x,c.y,c.r)#运行结果如下：TrueTrue1 21 2 3 deque deque可以高效实现插入和删除操作的双向列表，适合用于队列和栈： 1234567from collections import deque q=deque(['a','b','c'])q.append('x')q.appendleft('y')print(q)#运行结果如下：deque(['y', 'a', 'b', 'c', 'x']) 除此之外，还支持pop()、popleft()等方法，可以非常高效地往头部添加或删除元素。 defaultdict 使用dict时，若引用的Key不存在，就会抛出KeyError，若希望Key不存在时返回一个默认值，可以用defaultdict： 12345678from collections import defaultdictd=defaultdict(lambda:'N/A')d['key1']='abc'print(d['key1'])print(d['key2'])#运行结果如下：abcN/A 默认值是调用函数返回的，而函数在创建defaultdict对象时传入。 OrderedDict 使用dict时，Key是无序的。若要保持Key的顺序，可以用OrderedDict： 123456789101112131415from collections import OrderedDictd=dict([('c',1),('a',2),('b',3)])print(d)od=OrderedDict([('b',1),('a',2),('c',3)])print(od)odd=OrderedDict()odd['x']=1odd['z']=2odd['y']=3print(list(odd.keys()))#OrderedDict的Key按照插入的顺序排序，并非是Key自身的顺序，即odd是按插入值的前后排序，而不是根据'x'、'y'、'z'的顺序排#运行结果如下：&#123;'c': 1, 'a': 2, 'b': 3&#125;OrderedDict([('b', 1), ('a', 2), ('c', 3)])['x', 'z', 'y'] OrderedDict可以实现一个先进先出的dict，当容量超出限制时，先删除最早添加的Key。 ChainMap ChainMap可以把一组dict串起来组成一个大的dict。但在查找数据时会按照顺序在内部的dict依次查找。 例如，使用ChainMap来实现参数的优先级查找，其顺序为：命令行参数&gt;环境变量&gt;默认参数： 12345678910111213141516171819from collections import ChainMapfrom email.policy import defaultimport os,argparse# 构造默认参数:defaults=&#123; 'color':'red', 'user':'guest'&#125;#构造命令行参数:parser=argparse.ArgumentParser()parser.add_argument('-u','--user')parser.add_argument('-c','--color')namespace=parser.parse_args()command_line_args=&#123;k :v for k,v in vars(namespace).items() if v&#125;#组合成ChainMap:combined=ChainMap(command_line_args,os.environ,defaults)print('color=%s' % combined['color'])print('user=%s' % combined['user']) 打开cmd，将路径切换到当前.py文件所在的目录，运行代码： 在没有任何参数传入时，打印出默认参数： 12345C:\\Users\\Administrator\\Desktop&gt;python learn.py#运行结果如下：color=reduser=guest 当传入命令行参数时，优先使用命令行参数： 1234C:\\Users\\Administrator\\Desktop&gt;python learn.py -u bob#运行结果如下：color=reduser=bob 当同时传入命令行参数和环境变量时，也是优先使用命令行参数。 Counter Counter是一个简单的计数器，也是dict的一个子类，可以统计字符出现的个数： 12345678910from collections import Counterc=Counter()for ch in 'programming': c[ch]=c[ch]+1print(c) c.update('hello')#更新数据print(c)#运行结果如下：Counter(&#123;'r': 2, 'g': 2, 'm': 2, 'p': 1, 'o': 1, 'a': 1, 'i': 1, 'n': 1&#125;)Counter(&#123;'r': 2, 'o': 2, 'g': 2, 'm': 2, 'l': 2, 'p': 1, 'a': 1, 'i': 1, 'n': 1, 'h': 1, 'e': 1&#125;) base64 Base64是一种用64个字符来表示任意二进制数据的方法。 struct struct可以解决bytes和其他二进制数据类型的转换。 hashlib Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。 摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。 hmac Python自带的hmac模块实现了标准的Hmac算法，通过一个标准算法，在计算哈希的过程中，把key混入计算过程中。 itertools Python的内建模块itertools提供了非常有用的用于操作迭代对象的函数。 contextlib 在Python中，读写文件这样的资源要特别注意，必须在使用完毕后正确关闭它们。Python的标准库contextlib提供了更简单的写法，以实现上下文管理。 urllib urllib提供了一系列用于操作URL的功能。 Get urllib的request模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应。例如，对百度网址进行抓取，并返回响应：： 12345678910111213141516from urllib import requestwith request.urlopen('https://baidu.com/') as f: data = f.read() print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', data.decode('utf-8'))#运行结果如下：Status: 200 OKBdpagetype: 1Bdqid: 0x8dfa7ad90002130fContent-Type: text/html; charset=utf-8Date: Mon, 24 Oct 2022 09:01:21 GMT...Data: &lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt;&lt;meta content=\"always\" name=\"referrer\"&gt;&lt;meta name=\"theme-color\" content=\"#ffffff\"&gt;&lt;meta name=\"description\" content=\"全球领先的中文... 若要模拟浏览器发送GET请求，需要使用Request对象，通过往Request对象添加HTTP头，可以把请求伪装成浏览器。例如，模拟iPhone 6去请求豆瓣首页： 12345678910111213141516from urllib import requestreq = request.Request('http://www.douban.com/')req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')with request.urlopen(req) as f: print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', f.read().decode('utf-8'))#运行结果如下：&lt;!DOCTYPE html&gt;&lt;html itemscope itemtype=\"http://schema.org/WebPage\" class=\"ua-safari ua-mobile \"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;豆瓣(手机版)&lt;/title&gt; &lt;meta name=\"google-site-verification\" content=\"ok0wCgT20tBBgo9_zat2iAcimtN4Ftf5ccsh092Xeyw\" /&gt;... Post 若要以POST发送一个请求，只需要把参数data以bytes形式传入。 例如模拟一个微博登录，先读取登录的邮箱和口令，然后按照weibo.cn的登录页的格式以username=xxx&amp;password=xxx的编码传入： 12345678910111213141516171819202122232425from urllib import request, parseprint('Login to weibo.cn...')email = input('Email: ')passwd = input('Password: ')login_data = parse.urlencode([ ('username', email), ('password', passwd), ('entry', 'mweibo'), ('client_id', ''), ('savestate', '1'), ('ec', ''), ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F')])req = request.Request('https://passport.weibo.cn/sso/login')req.add_header('Origin', 'https://passport.weibo.cn')req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')req.add_header('Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F')with request.urlopen(req, data=login_data.encode('utf-8')) as f: print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', f.read().decode('utf-8')) 若登录成功，获得的响应如下： 123456Status: 200 OKServer: nginx/1.2.0...Set-Cookie: SSOLoginState=1432620126; path=/; domain=weibo.cn...Data: &#123;\"retcode\":20000000,\"msg\":\"\",\"data\":&#123;...,\"uid\":\"1658384301\"&#125;&#125; 若登录失败，获得的响应如下： 12...Data: &#123;\"retcode\":50011002,\"msg\":\"\\u7528\\u6237\\u540d\\u6216\\u5bc6\\u7801\\u9519\\u8bef\",\"data\":&#123;\"username\":\"123456@qq.com\",\"errline\":15&#125;&#125; Handler 若需要更复杂的控制，比如通过一个Proxy去访问网站，需要利用ProxyHandler来处理，例如： 123456proxy_handler = urllib.request.ProxyHandler(&#123;'http': 'http://www.example.com:3128/'&#125;)proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()proxy_auth_handler.add_password('realm', 'host', 'username', 'password')opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)with opener.open('http://www.example.com/login.html') as f: pass XML 操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。 正常情况下，优先考虑SAX，因为DOM实在太占内存。 在Python中使用SAX解析XML非常简洁，通常我们关心的事件是start_element，end_element和char_data，准备好这3个函数，然后就可以解析xml了。 HTMLParser Python提供了HTMLParser来非常方便地解析HTML。 常用第三方模块 Pillow PIL：Python Imaging Library，已经是Python平台事实上的图像处理标准库了。PIL功能非常强大，但API却非常简单易用。 由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫Pillow，支持最新Python 3.x，又加入了许多新特性，因此，我们可以直接安装使用Pillow。 requests Python内置的urllib模块，用于访问网络资源。但是，它用起来比较麻烦，而且，缺少很多实用的高级功能。 更好的方案是使用requests。它是一个Python第三方库，处理URL资源特别方便。 安装request：pip install requests requests的使用 通过GET访问一个页面： 12345678import requests r=requests.get('https://www.baidu.com/')print(r.status_code)#访问状态码print(r.text)#网页详情#运行结果如下：200'''&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css ...''' 对于带参数的URL，传入一个dict作为params参数： 123456789import requests r=requests.get('https://www.baidu.com/',params=&#123;'q':'python','cat':'1001'&#125;)print(r.url)#实际请求的URLprint(r.encoding)#自动检测编码print(r.content)#获得bytes对象#运行结果如下：https://www.baidu.com/?q=python&amp;cat=1001ISO-8859-1'''b'&lt;!DOCTYPE html&gt;\\r\\n&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css ...''' 对于特定类型的响应，例如JSON，可以直接获取： 123456789101112131415161718import requests #获取JSONr1=requests.get('https://p.3.cn/prices/mgets?skuIds=J_10026711061553')#需要传入HTTP Header时，传入一个dictr2=requests.get('https://douban.com/',headers=&#123;'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit'&#125;)print(r1.json())#必须为JSON类型的网址print(r2.text)#运行结果如下：[&#123;'exception': '该接口即将下线，请联系(erp)wangjianyu1，liuhuimin9，liteng36;p.3.cn,null'&#125;]'''&lt;!DOCTYPE html&gt;&lt;html itemscope itemtype=\"http://schema.org/WebPage\" class=\"ua-mobile \"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;豆瓣(手机版)&lt;/title&gt; &lt;meta name=\"google-site-verification\" content=\"ok0wCgT20tBBgo9_zat2iAcimtN4Ftf5ccsh092Xeyw\" /&gt; ...''' 需要发送POST请求，只需要把get()方法变成post()，然后传入data参数作为POST请求的数据： 1r=requests.post('https://accounts.douban.com/login', data=&#123;'form_email': 'abc@example.com', 'form_password': '123456'&#125;) requests默认使用application/x-www-form-urlencoded对POST数据编码。如果要传递JSON数据，可以直接传入json参数： 12params=&#123;'key': 'value'&#125;r=requests.post(url,json=params) # 内部自动序列化为JSON 类似的，上传文件需要更复杂的编码格式，但是requests把它简化成files参数： 12upload_files=&#123;'file':open('report.xls','rb')&#125;r=requests.post(url,files=upload_files) 在读取文件时，注意务必使用'rb'即二进制模式读取，这样获取的bytes长度才是文件的长度。 requests对获取HTTP响应的其他信息也非常简单。例如，获取响应头： 12345print(r.headers)print(r.headers['Content-Type'])#运行结果如下：&#123;Content-Type': 'text/html; charset=utf-8', 'Transfer-Encoding': 'chunked', 'Content-Encoding': 'gzip', ...&#125;'text/html; charset=utf-8' requests对Cookie做了特殊处理，使得我们不必解析Cookie就可以轻松获取指定的Cookie： 123print(r.cookies['ts'])#运行结果如下：'example_cookie_12345' 要在请求中传入Cookie，只需准备一个dict传入cookies参数： 12cs=&#123;'token':'12345','status':'working'&#125;r=requests.get(url,cookies=cs) 最后，要指定超时，传入以秒为单位的timeout参数： 1r=requests.get(url,timeout=2.5) # 2.5秒后超时 练习题 参考《OA统一待办接口协议》，使用requests访问统一待办接口，给自己生成一个待办，确认生成后，调用删除接口删除待办。 代码如下： 123456789101112131415161718192021222324252627import requests import json#基础数据headers=&#123;'Content-Type':'application/json'&#125;url='GetToken的URL地址'#URL地址以http://开头，后接ip形式的urlurl_create='CreateTask的URL地址'url_del='DeleteTask的URL地址'data=&#123;\"app_id\":\"app_id的数值\",\"app_secret\":\"app_secret的数值\"&#125;#获取调用凭证access_tokenr=requests.post(url,json=data)token=json.loads(r.text)['access_token']#生成待办事项data_create=&#123;\"access_token\":token,\"title\":\"20221025测试\",\"task_segment\":\"报名\",\\ \"task_url\":\"http://tangmenjue.top/\",\"staff_id\":\"staff_id的数值\"&#125;r_create=requests.post(url_create,json=data_create)print(r_create.text)r_del=requests.post(url,json=data)task_id=json.loads(r_create.text)['task_id']# task_id='17837ed5-48e4-4120-964a-477d258aaeb3'#确认待办事项已生成后，调用删除接口删除待办。data_del=&#123;\"access_token\":token,'task_id':task_id&#125;r_del=requests.post(url_del,json=data_del)print(r_del.text) chardet 字符串编码一直是令人非常头疼的问题，尤其是我们在处理一些不规范的第三方网页的时候。虽然Python提供了Unicode表示的str和bytes两种数据类型，并且可以通过encode()和decode()方法转换，但是，在不知道编码的情况下，对bytes做decode()不好做。 对于未知编码的bytes，要把它转换成str，需要先“猜测”编码。猜测的方式是先收集各种编码的特征字符，根据特征字符判断，就能有很大概率“猜对”。 当然，我们肯定不能从头自己写这个检测编码的功能，这样做费时费力。chardet这个第三方库正好就派上了用场。用它来检测编码，简单易用。 psutil 在Python中获取系统信息的另一个好办法是使用psutil这个第三方模块。顾名思义，psutil = process and system utilities，它不仅可以通过一两行代码实现系统监控，还可以跨平台使用，支持Linux／UNIX／OSX／Windows等，是系统管理员和运维小伙伴不可或缺的必备模块。 venv 在开发Python应用程序的时候，系统安装的Python3只有一个版本：3.10。所有第三方的包都会被pip安装到Python3的site-packages目录下。 如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python 3。如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？ 这种情况下，每个应用可能需要各自拥有一套“独立”的Python运行环境。venv就是用来为一个应用创建一套“隔离”的Python运行环境。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://tangmenjue.top/tags/python/"}]},{"title":"Flask实战之搭建博客后端","slug":"Flask实战之搭建博客后端","date":"2022-10-24T06:36:53.000Z","updated":"2022-12-07T02:27:02.017Z","comments":true,"path":"2022/10/24/Flask实战之搭建博客后端/","link":"","permalink":"http://tangmenjue.top/2022/10/24/Flask%E5%AE%9E%E6%88%98%E4%B9%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%AB%AF/","excerpt":"","text":"创建一个Flask RESTful API 本节的目的为搭建Flask应用，并提供一个测试API，客户端访问/ping后会返回pong!响应。 配置Flask 确保python3已安装后，在合适的位置新建tutorproject项目目录，在tutorproject里新建back-end目录，作为后端API应用所在的位置。在C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end的目录下右键，选择在终端打开后，按照以下步骤搭建Flask所需的环境。 12345678#创建虚拟环境venvPS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;python -m venv venv#激活环境venvPS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;venv\\Scripts\\activate#虚拟环境中导入flask模块(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;pip install flask#把系统环境信息写到txt中(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;pip freeze &gt;requirements.txt 应用工厂 创建tutorweb目录，并在tutorweb目录下新建__init__.py文件，在__init__.py中，使用应用工厂函数来创建Flask应用： 123456789101112from flask import Flaskfrom config import Configdef create_app(config_class=Config): app=Flask(__name__) app.config.from_object(config_class) #注册blueprint from tutorweb.api import bp as api_bp app.register_blueprint(api_bp,url_prefix='/api') return app 创建tutorweb/api目录，并在api目录下新建__init__.py文件，定义蓝图： 1234from flask import Blueprintbp=Blueprint('api',__name__)#防止循环导入ping.py文件from tutorweb.api import ping 在api目录下新建ping.py文件，定义路由函数，当客户端访问/ping时返回包含JSON的数据： 1234567from flask import jsonifyfrom tutorweb.api import bp@bp.route('/ping',methods=['GET'])def ping(): #vue.js用来测试与后端Flask API的连通性 return jsonify('Pong!') 应用启动文件 在back-end目录下新建madblog.py文件： 123from tutorweb import create_appapp=create_app() 配置文件 在back-end目录下新建config.py文件： 12345678import os from dotenv import load_dotenvbasedir=os.path.abspath(os.path.dirname(__file__))load_dotenv(os.path.join(basedir,'.env'),encoding='utf-8')class Config(object): pass 读取环境变量信息 将Flask应用所需的系统环境变量写到back-end/.env中，可先使用python-dotenv这个包来读取环境变量信息，再把系统环境写到txt中： 12(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;pip install python-dotenv(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;pip freeze &gt;requirements.txt 在back-end目录下新建.env文件，用记事本打开后写入以下信息保存： 12FLASK_APP=madblog.pyFLASK_DEBUG=1 启动应用 输入flask run即可启动应用： 12345678910(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;flask run * Serving Flask app 'madblog.py' * Debug mode: onWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Running on http://127.0.0.1:5000Press CTRL+C to quit * Restarting with stat * Debugger is active! * Debugger PIN: 354-979-609 启动应用后，打开浏览器，访问http://127.0.0.1:5000/api/ping，若出现Pong!则说明所定义的Ping-Pong测试路由正常。 在cmd页面按下ctrl+c即可停止应用运行。 此时的目录结构如下： Flask设计User用户相关API 本节的内容为：Flask后端针对“用户资源”提供部分RESTful API，基于token认证，支持添加用户、查看单个或多个用户、修改用户，使用HTTPie或Postman测试API通过。 数据库 ORM：SQLAlchemy 安装Flask-SQLAlchemy插件和数据表结构有变化后进行迁移的Flask-Migrate插件： 12(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;pip install flask-sqlalchemy flask-migrate(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;pip freeze &gt; requirements.txt 修改配置文件back-end/config.py，默认使用SQLite数据库： 12345678910import os from dotenv import load_dotenvbasedir=os.path.abspath(os.path.dirname(__file__))load_dotenv(os.path.join(basedir,'.env'),encoding='utf-8')class Config(object): SQLALCHEMY_DATABASE_URI=os.environ.get('DATABASE_URL') or \\ 'sqlite:///'+os.path.join(basedir,'tutorweb.db') SQLALCHEMY_TRACK_MODIFICATIONS=False 修改tutorweb/__init__.py，引入并初始化插件： 12345678910111213141516171819202122232425262728from flask import Flaskfrom flask_cors import CORSfrom flask_sqlalchemy import SQLAlchemyfrom flask_migrate import Migratefrom config import Config#定义Flack_SQLAlchemydb=SQLAlchemy()#定义Flack_Migrate migrate=Migrate()def create_app(config_class=Config): app=Flask(__name__) app.config.from_object(config_class) #启用CORS CORS(app) #初始化Flack_SQLAlchemy db.init_app(app) #初始化Flack_Migrate migrate.init_app(app,db) #注册blueprint from tutorweb.api import bp as api_bp app.register_blueprint(api_bp,url_prefix='/api') return app 在back-end目录下新建tutorweb.db文件作为数据库文件，修改back-end目录下的madblog.py文件如下： 123from tutorweb import create_app,dbapp=create_app() 定义User用户数据模型 创建tutorweb/models.py: 12345678910from tutorweb import dbclass User(db.Model): id=db.Column(db.Integer,primary_key=True) username=db.Column(db.String(64),index=True,unique=True) email=db.Column(db.String(120),index=True,unique=True) password_hash=db.Column(db.String(128))#不保留原始密码 def __repr__(self): return '&lt;User &#123;&#125;&gt;'.format(self.username) 修改tutorweb/__init__.py，在文件末尾添加： 1from tutorweb import models 第一次数据库迁移 创建迁移数据库： 1(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;flask db init 生成迁移脚本： 1(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;flask db migrate -m \"add users table\" 将迁移脚本应用到数据库中： 1(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;flask db upgrade 若要回滚上次的迁移，可用flask db downgrade命令回滚。 存储用户密码的hash值： 使用werkzeug.security库的generate_password_hash和check_password_hash来创建哈希密码和验证密码的hash是否一致： 1234567891011(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; pythonPython 3.10.5 (tags/v3.10.5:f377153, Jun 6 2022, 16:14:13) [MSC v.1929 64 bit (AMD64)] on win32Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; from werkzeug.security import generate_password_hash, check_password_hash&gt;&gt;&gt; hash = generate_password_hash('123')&gt;&gt;&gt; hash'pbkdf2:sha256:260000$RBvmqvkVP61YXGy0$52d3ea1ae76f51d284ba66d2665c8bcfdd069b47cdff7e3211e46d5d98a9d01a'&gt;&gt;&gt; check_password_hash(hash, 'foobar')False&gt;&gt;&gt; check_password_hash(hash, '123')True 注意：使用generate_password_hash生成不同的3个'123'哈希值，并复制其值保存下来备用，以作为后面用户密码使用。 修改tutorweb/models.py，增加创建密码和验证密码两个方法： 1234567891011121314151617from werkzeug.security import generate_password_hash,check_password_hashfrom tutorweb import dbclass User(db.Model): id=db.Column(db.Integer,primary_key=True) username=db.Column(db.String(64),index=True,unique=True) email=db.Column(db.String(120),index=True,unique=True) password_hash=db.Column(db.String(128))#不保留原始密码 def __repr__(self): return '&lt;User &#123;&#125;&gt;'.format(self.username) def set_password(self,password): self.password_hash=generate_password_hash(password) def check_password(self,password): return check_password_hash(self.password_hash,password) 配置Flask Shell上下文环境： flask shell命令是继flask run后被实现的第二个“核心”命令，其目的是启动一个python解释器包含应用的上下文： 123456789101112(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; flask shellPython 3.10.5 (tags/v3.10.5:f377153, Jun 6 2022, 16:14:13) [MSC v.1929 64 bit (AMD64)] on win32App: tutorwebInstance: C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end\\instance&gt;&gt;&gt; tutorwebTraceback (most recent call last): File \"&lt;console&gt;\", line 1, in &lt;module&gt;NameError: name 'tutorweb' is not defined&gt;&gt;&gt; app&lt;Flask 'tutorweb'&gt;&gt;&gt;&gt; db&lt;SQLAlchemy sqlite:///C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end\\tutorweb.db&gt; 修改back-end/madblog.py，添加一个方法： 12345678from tutorweb import create_app,dbfrom tutorweb.models import Userapp=create_app()@app.shell_context_processordef make_shell_context(): return &#123;'db':db,'User':User&#125; 再次运行flask shell命令： 12345678910111213141516(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; flask shellPython 3.10.5 (tags/v3.10.5:f377153, Jun 6 2022, 16:14:13) [MSC v.1929 64 bit (AMD64)] on win32App: tutorwebInstance: C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end\\instance&gt;&gt;&gt; app&lt;Flask 'tutorweb'&gt;&gt;&gt;&gt; db&lt;SQLAlchemy sqlite:///C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end\\tutorweb.db&gt;&gt;&gt;&gt; User&lt;class 'tutorweb.models.User'&gt;&gt;&gt;&gt; u=User(username='tom',email='tom@163.com')&gt;&gt;&gt; u.set_password('123456')&gt;&gt;&gt; u.check_password('123456')True&gt;&gt;&gt; u.check_password('654321')False RESTful API设计 用户资源暂时提供以下几个API： HTTP方法 资源URL 说明 GET /api/users 返回所有用户的集合 POST /api/users 注册一个新用户 GET /api/users/&lt;id&gt; 返回一个用户 PUT /api/users/&lt;id&gt; 修改一个用户 DELETE /api/users/&lt;id&gt; 删除一个用户 创建tutorweb/api/users.py： 1234567891011121314151617181920212223242526from tutorweb.api import bp@bp.route('/users', methods=['POST'])def create_user(): '''注册一个新用户''' pass@bp.route('/users', methods=['GET'])def get_users(): '''返回所有用户的集合''' pass@bp.route('/users/&lt;int:id&gt;', methods=['GET'])def get_user(id): '''返回一个用户''' pass@bp.route('/users/&lt;int:id&gt;', methods=['PUT'])def update_user(id): '''修改一个用户''' pass@bp.route('/users/&lt;int:id&gt;', methods=['DELETE'])def delete_user(id): '''删除一个用户''' pass 修改 tutorweb/api/__init__.py，在末尾添加： 1from tutorweb.api import ping,users 用户对象转换成JSON Flask使用的都是User实例对象，返回响应给前端时，需要传递JSON对象。 修改 tutorweb/models.py，给 User 数据模型添加 to_dict 方法： 12345678910111213141516from flask import url_for...class User(db.Model): ... def to_dict(self, include_email=False): data = &#123; 'id': self.id, 'username': self.username, '_links': &#123; 'self': url_for('api.get_user', id=self.id) &#125; &#125; if include_email: data['email'] = self.email return data 只有当用户请求自己的数据时才包含 email，使用 include_email 标志来确定该字段是否包含在字典中。调用该方法返回字典，再用 flask.jsonify 将字典转换成 JSON 响应 用户集合转换成JSON API 中有 POST /users 需要返回用户集合，所以还需要添加 to_collection_dict 方法。考虑到后续会创建 Post 等数据模型。 在 tutorweb/models.py 中设计一个通用类 PaginatedAPIMixin，放到User类前： 12345678910111213141516171819202122class PaginatedAPIMixin(object): @staticmethod def to_collection_dict(query, page, per_page, endpoint, **kwargs): resources = query.paginate(page=page,per_page=per_page,error_out=False) data = &#123; 'items': [item.to_dict() for item in resources.items], '_meta': &#123; 'page': page, 'per_page': per_page, 'total_pages': resources.pages, 'total_items': resources.total &#125;, '_links': &#123; 'self': url_for(endpoint, page=page, per_page=per_page, **kwargs), 'next': url_for(endpoint, page=page + 1, per_page=per_page, **kwargs) if resources.has_next else None, 'prev': url_for(endpoint, page=page - 1, per_page=per_page, **kwargs) if resources.has_prev else None &#125; &#125; return data 然后，由User类继承这个类： 12class User(PaginatedAPIMixin, db.Model): ... JSON转换成用户对象 前端发送过来 JSON 对象，需要转换成 User 对象： 123456def from_dict(self, data, new_user=False): for field in ['username', 'email']: if field in data: setattr(self, field, data[field]) if new_user and 'password' in data: self.set_password(data['password']) 错误处理 创建 tutorweb/api/errors.py： 1234567891011121314from flask import jsonifyfrom werkzeug.http import HTTP_STATUS_CODESdef error_response(status_code, message=None): payload = &#123;'error': HTTP_STATUS_CODES.get(status_code, 'Unknown error')&#125; if message: payload['message'] = message response = jsonify(payload) response.status_code = status_code return responsedef bad_request(message): #最常用的错误：400：错误的请求 return error_response(400, message) 注册新用户 修改tutorweb/api/users.py： 123456789101112131415161718192021222324252627282930313233343536373839import re from flask import request,jsonify,url_forfrom tutorweb import dbfrom tutorweb.api import bpfrom tutorweb.api.errors import bad_requestfrom tutorweb.models import User@bp.route('/users',methods=['POST'])def create_user(): #注册一个新用户 data=request.get_json() if not data: return bad_request('You must post JSON data.') message=&#123;&#125; if 'username' not in data or not data.get('username', None): message['username'] = 'Please provide a valid username.' pattern = '^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]&#123;2,&#125;))$' if 'email' not in data or not re.match(pattern, data.get('email', None)): message['email'] = 'Please provide a valid email address.' if 'password' not in data or not data.get('password', None): message['password'] = 'Please provide a valid password.' if User.query.filter_by(username=data.get('username', None)).first(): message['username'] = 'Please use a different username.' if User.query.filter_by(email=data.get('email', None)).first(): message['email'] = 'Please use a different email address.' if message: return bad_request(message) user=User() user.from_dict(data,new_user=True) db.session.add(user) db.session.commit() response=jsonify(user.to_dict()) response.status_code=201 #HTTP协议要求201响应包含一个值为新资源URL的Location头部 response.headers['Location']=url_for('api.get_user',id=user.id) return response 在C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end的目录下右键，选择在终端打开后，运行应用： 1234567891011PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; venv\\Scripts\\activate(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; pip install --upgrade httpie(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; flask run * Serving Flask app 'madblog.py'WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Running on http://127.0.0.1:5000Press CTRL+C to quit * Restarting with stat * Debugger is active! * Debugger PIN: 354-979-609 保持应用处于运行的状态后，打开另一个终端并激活环境。使用HTTPie或Postman测试API接口： 123456789101112131415161718(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; http POST http://localhost:5000/api/users username=lisi password=123 email=lisi@163.comHTTP/1.1 201 CREATEDAccess-Control-Allow-Origin: *Connection: closeContent-Length: 82Content-Type: application/jsonDate: Mon, 24 Oct 2022 03:12:01 GMTLocation: /api/users/5Server: Werkzeug/2.2.2 Python/3.10.5&#123; \"_links\": &#123; \"self\": \"/api/users/5\" &#125;, \"id\": 5, \"username\": \"lisi\"&#125; 若应用没有运行，会报错： 123(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; http POST http://localhost:5000/api/users username=lisi password=123 email=lisi@163.comhttp: error: ConnectionError: HTTPConnectionPool(host='localhost', port=5000): Max retries exceeded with url: /api/users (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000022A6C404550&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')) while doing a POST request to URL: http://localhost:5000/api/users 检索单个用户 修改tutorweb/api/users.py： 1234@bp.route('/users/&lt;int:id&gt;', methods=['GET'])def get_user(id): #返回一个用户 return jsonify(User.query.get_or_404(id).to_dict()) 保持应用处于运行的状态后，在另一个终端检索用户： 12345678910111213141516(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; http GET http://localhost:5000/api/users/4 HTTP/1.1 200 OKAccess-Control-Allow-Origin: *Connection: closeContent-Type: application/jsonDate: Mon, 24 Oct 2022 03:16:47 GMTServer: Werkzeug/2.2.2 Python/3.10.5&#123; \"_links\": &#123; \"self\": \"/api/users/4\" &#125;, \"id\": 4, \"username\": \"zhangsan\"&#125; 若查询的用户id不存在，返回404错误 123456789101112131415(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; http GET http://localhost:5000/api/users/7 HTTP/1.1 404 NOT FOUNDAccess-Control-Allow-Origin: *Connection: closeContent-Length: 207Content-Type: text/html; charset=utf-8Date: Mon, 24 Oct 2022 03:19:48 GMTServer: Werkzeug/2.2.2 Python/3.10.5&lt;!doctype html&gt;&lt;html lang=en&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;h1&gt;Not Found&lt;/h1&gt;&lt;p&gt;The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.&lt;/p&gt; 修改tutorweb/api/errors.py，设置返回JSON错误信息 123456789101112from tutorweb import dbfrom tutorweb.api import bp...@bp.app_errorhandler(404)def not_found_error(error): return error_response(404)@bp.app_errorhandler(500) def internal_error(error): db.session.rollback() return error_response(500) 若查询的用户id不存在，此时返回404错误信息为： 123456789101112(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; http GET http://localhost:5000/api/users/7HTTP/1.1 404 NOT FOUNDAccess-Control-Allow-Origin: *Connection: closeContent-Length: 27Content-Type: application/jsonDate: Mon, 24 Oct 2022 03:17:01 GMTServer: Werkzeug/2.2.2 Python/3.10.5&#123; \"error\": \"Not Found\"&#125; 检索用户集合 修改tutorweb/api/users.py： 1234567@bp.route('/users',methods=['GET'])def get_users(): #返回所有用户的集合 page=request.args.get('page',1,type=int) per_page=min(request.args.get('per_page',10,type=int),100) data=User.to_collection_dict(User.query,page,per_page,'api.get_users') return jsonify(data) 终端测试如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; http GET http://localhost:5000/api/users HTTP/1.1 200 OKAccess-Control-Allow-Origin: *Connection: closeContent-Length: 889Content-Type: application/jsonDate: Mon, 24 Oct 2022 06:24:27 GMTServer: Werkzeug/2.2.2 Python/3.10.5&#123; \"_links\": &#123; \"next\": null, \"prev\": null, \"self\": \"/api/users?page=1&amp;per_page=10\" &#125;, \"_meta\": &#123; \"page\": 1, \"per_page\": 10, \"total_items\": 6, \"total_pages\": 1 &#125;, \"items\": [ &#123; \"_links\": &#123; \"self\": \"/api/users/1\" &#125;, \"id\": 1, \"username\": \"alice\" &#125;, &#123; \"_links\": &#123; \"self\": \"/api/users/2\" &#125;, \"id\": 2, \"username\": \"bob\" &#125;, &#123; \"_links\": &#123; \"self\": \"/api/users/3\" &#125;, \"id\": 3, \"username\": \"madman\" &#125;, &#123; \"_links\": &#123; \"self\": \"/api/users/4\" &#125;, \"id\": 4, \"username\": \"zhangsan\" &#125;, &#123; \"_links\": &#123; \"self\": \"/api/users/5\" &#125;, \"id\": 5, \"username\": \"lisi\" &#125;, &#123; \"_links\": &#123; \"self\": \"/api/users/6\" &#125;, \"id\": 6, \"username\": \"wangwu\" &#125; ]&#125; 修改用户 修改tutorweb/api/users.py： 123456789101112131415161718192021222324252627@bp.route('/users/&lt;int:id&gt;',methods=['PUT'])def update_user(id): #修改一个用户 user=User.query.get_or_404(id) data=request.get_json() if not data: return bad_request('You must post JSON data.') message=&#123;&#125; if 'username' in data and not data.get('username', None): message['username']='Please provide a valid username.' pattern='^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]&#123;2,&#125;))$' if 'email' in data and not re.match(pattern, data.get('email', None)): message['email']='Please provide a valid email address.' if 'username' in data and data['username'] != user.username and \\ User.query.filter_by(username=data['username']).first(): message['username']='Please use a different username.' if 'email' in data and data['email'] != user.email and \\ User.query.filter_by(email=data['email']).first(): message['email']='Please use a different email address.' if message: return bad_request(message) user.from_dict(data,new_user=False) db.session.commit() return jsonify(user.to_dict()) 终端测试如下： 1234567891011121314151617(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; http PUT http://localhost:5000/api/users/5 email=madman@gmail.com HTTP/1.1 200 OKAccess-Control-Allow-Origin: *Connection: closeContent-Length: 82Content-Type: application/jsonDate: Mon, 24 Oct 2022 05:16:38 GMTServer: Werkzeug/2.2.2 Python/3.10.5&#123; \"_links\": &#123; \"self\": \"/api/users/5\" &#125;, \"id\": 5, \"username\": \"lisi\"&#125; API认证 为了简化使用 token 认证时客户端和服务器之间的交互，可以使用 Flask-HTTPAuth 插件 12(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;pip install flask-httpauth(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;pip freeze &gt; requirements.txt 当客户端想要开始与 API 交互时，它需要使用用户名和密码进行 Basic Auth 验证，然后获得一个临时 token。只要 token 有效，客户端就可以发送附带 token 的 API 请求以通过认证。一旦 token 到期，需要申请新的 token。 User 数据模型添加 token 修改 tutorweb/models.py： 1234567891011121314151617181920212223242526272829import base64from datetime import datetime, timedeltaimport os...class User(PaginatedAPIMixin, db.Model): ... token = db.Column(db.String(32), index=True, unique=True) token_expiration = db.Column(db.DateTime) ... def get_token(self, expires_in=3600): now = datetime.utcnow() if self.token and self.token_expiration &gt; now + timedelta(seconds=60): return self.token self.token = base64.b64encode(os.urandom(24)).decode('utf-8') self.token_expiration = now + timedelta(seconds=expires_in) db.session.add(self) return self.token def revoke_token(self): self.token_expiration = datetime.utcnow() - timedelta(seconds=1) @staticmethod def check_token(token): user = User.query.filter_by(token=token).first() if user is None or user.token_expiration &lt; datetime.utcnow(): return None return user 创建数据库迁移脚本并应用： 12(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;flask db migrate -m &quot;user add tokens&quot;(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt;flask db upgrade HTTP Basic Authentication 创建 tutorweb/api/auth.py： 1234567891011121314151617181920from flask import gfrom flask_httpauth import HTTPBasicAuth,HTTPTokenAuthfrom tutorweb.models import Userfrom tutorweb.api.errors import error_responsebasic_auth=HTTPBasicAuth()@basic_auth.verify_passworddef verify_password(username,password): #用于检查用户提供的用户名和密码 user=User.query.filter_by(username=username).first() if user is None: return False g.current_user=user return user.check_password(password)@basic_auth.error_handlerdef basic_auth_error(): #用于在认证失败情况下返回错误响应 return error_response(401) 客户端申请 Token 目前已经实现了 Basic Auth 验证的支持，因此可以添加一条 token 检索路由，以便客户端在需要 token 时调用。 创建 tutorweb/api/tokens.py： 12345678910111213141516171819from flask import jsonify,gfrom tutorweb import dbfrom tutorweb.api import bpfrom tutorweb.api.auth import basic_auth,token_auth@bp.route('/tokens',methods=['POST'])@basic_auth.login_requireddef get_token(): token=g.current_user.get_token() db.session.commit() return jsonify(&#123;'token':token&#125;)@bp.route('/tokens',methods=['DELETE']) @token_auth.login_requireddef revoke_token(): g.current_user.revoke_token() db.session.commit() return '',204 装饰器 @basic_auth.login_required 将指示 Flask-HTTPAuth 验证身份，当通过 Basic Auth 验证后，才使用用户模型的 get_token() 方法来生成 token，数据库提交在生成 token 后发出，以确保 token 及其到期时间被写回到数据库。 修改 tutorweb/api/__init__.py，在末尾添加： 1from tutorweb.api import ping, users, tokens 如果尝试直接向 token API 路由发送 POST 请求，则会发生以下情况： 1234567891011121314(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; http POST http://localhost:5000/api/tokensHTTP/1.1 401 UNAUTHORIZEDAccess-Control-Allow-Origin: *Connection: closeContent-Length: 30Content-Type: application/jsonDate: Mon, 24 Oct 2022 04:51:39 GMTServer: Werkzeug/2.2.2 Python/3.10.5WWW-Authenticate: Basic realm=\"Authentication Required\"&#123; \"error\": \"Unauthorized\"&#125; 如果在 POST 请求附带上了 Basic Auth 需要的凭证： 12345678910111213(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; http --auth madman:123 POST http://localhost:5000/api/tokens HTTP/1.1 200 OKAccess-Control-Allow-Origin: *Connection: closeContent-Length: 50Content-Type: application/jsonDate: Mon, 24 Oct 2022 04:52:22 GMTServer: Werkzeug/2.2.2 Python/3.10.5&#123; \"token\": \"q2L2Umakr5/iSrf1L4mglZmYoBD/K9Je\"&#125; HTTP Token Authentication 用户通过 Basic Auth 拿到 token 后，之后的请求只要附带这个 token 就能够访问其它 API，修改 tutorweb/api/auth.py： 12345678910111213141516from flask_httpauth import HTTPBasicAuth,HTTPTokenAuth...token_auth=HTTPTokenAuth()...@token_auth.verify_tokendef verify_token(token): #用于检查用户请求是否有token,且token真实存在，还在有效期内 g.current_user=User.check_token(token) if token else None return g.current_user is not None@token_auth.error_handlerdef token_auth_error(): #用于在Token Auth认证失败的情况下返回错误响应 return error_response(401) 修改tutorweb/api/users.py，在文件开头导入模块： 1from tutorweb.api.auth import token_auth 使用 Token 机制保护 API 路由 除 create_user() 之外的所有 API 视图函数需要添加 @token_auth.login_required 装饰器， create_user()函数不能使用 token 认证，因为用户不存在时不会有 token 。 1234567891011@bp.route('/users', methods=['GET'])@token_auth.login_requireddef get_users(): ...@bp.route('/users/&lt;int:id&gt;', methods=['GET'])@token_auth.login_requireddef get_user(id): ...... 若直接对上面列出的受 token 保护的 endpoint 发起请求，则会得到一个 401 错误： 1234567891011121314(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; http GET http://localhost:5000/api/users/5HTTP/1.1 401 UNAUTHORIZEDAccess-Control-Allow-Origin: *Connection: closeContent-Length: 30Content-Type: application/jsonDate: Mon, 24 Oct 2022 04:56:51 GMTServer: Werkzeug/2.2.2 Python/3.10.5WWW-Authenticate: Bearer realm=\"Authentication Required\"&#123; \"error\": \"Unauthorized\"&#125; 为了成功访问，需要添加 Authorization 头部，其值是请求 /api/tokens 获得的 token 的值： 1234567891011121314151617(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; http GET http://localhost:5000/api/users/5 \"Authorization:Bearer q2L2Umakr5/iSrf1L4mglZmYoBD/K9Je\"HTTP/1.1 200 OKAccess-Control-Allow-Origin: *Connection: closeContent-Length: 82Content-Type: application/jsonDate: Mon, 24 Oct 2022 04:58:20 GMTServer: Werkzeug/2.2.2 Python/3.10.5&#123; \"_links\": &#123; \"self\": \"/api/users/5\" &#125;, \"id\": 5, \"username\": \"lisi\"&#125; 撤销 Token 修改 tutorweb/api/tokens.py： 123456789from tutorweb.api.auth import basic_auth,token_auth...@bp.route('/tokens',methods=['DELETE']) @token_auth.login_requireddef revoke_token(): g.current_user.revoke_token() db.session.commit() return '',204 客户端可以向 /api/tokens URL发送 DELETE 请求，以使 token 失效 12345678910111213141516171819202122(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; http DELETE http://localhost:5000/api/tokens \"Authorization:Bearer QYnLb1pN/l4I4j2KwZWzr7+imtyekI66\"HTTP/1.1 204 NO CONTENTAccess-Control-Allow-Origin: *Connection: closeContent-Type: text/html; charset=utf-8Date: Mon, 24 Oct 2022 03:31:11 GMTServer: Werkzeug/2.2.2 Python/3.10.5(venv) PS C:\\Users\\Administrator\\Desktop\\code_learn\\flask_exercise\\tutorproject\\back-end&gt; http DELETE http://localhost:5000/api/tokens \"Authorization:Bearer QYnLb1pN/l4I4j2KwZWzr7+imtyekI66\"HTTP/1.1 401 UNAUTHORIZEDAccess-Control-Allow-Origin: *Connection: closeContent-Type: application/jsonDate: Mon, 24 Oct 2022 03:32:00 GMTServer: Werkzeug/2.2.2 Python/3.10.5WWW-Authenticate: Bearer realm=\"Authentication Required\"&#123; \"error\": \"Unauthorized\"&#125; 至此，Flask后端已成功配置。最终的代码目录如下：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Web框架","slug":"Web框架","permalink":"http://tangmenjue.top/categories/Web%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Flask Web","slug":"Flask-Web","permalink":"http://tangmenjue.top/tags/Flask-Web/"},{"name":"后端","slug":"后端","permalink":"http://tangmenjue.top/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Web框架","slug":"Web框架","permalink":"http://tangmenjue.top/tags/Web%E6%A1%86%E6%9E%B6/"}]},{"title":"Flask Web开发学习笔记（三）","slug":"Flask Web开发学习笔记（三）","date":"2022-10-21T03:36:28.000Z","updated":"2022-11-10T15:48:53.464Z","comments":true,"path":"2022/10/21/Flask Web开发学习笔记（三）/","link":"","permalink":"http://tangmenjue.top/2022/10/21/Flask%20Web%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"模板 Jinja配置 Jinja2默认配置为： 所有扩展名为.html、.htm、.xml以及.xhtml的模板会开启自动转义 模板可以利用 1&#123;% autoescape %&#125; 标签选择自动转义的开关 Flask在Jinja2上下文中插入了几个全局函数和助手，另外还有一些目前默认的值。 标准上下文 默认在Jinja2模板中可用的全局变量有： config： 当前的配置对象(flask.config)。 request： 当前的请求对象(flask.request) 。当模板不是在活动的请求上下文中渲染时，这个变量不可用。 session： 当前的会话对象(flask.session)。当模板不是在活动的请求上下文中渲染时，这个变量不可用。 g： 请求相关的全局变量(flask.g)。当模板不是在活动的请求上下文中渲染时，这个变量不可用。 url_for()： flask.url_for()函数。 get_flashed_messages()： flask.get_flashed_messages()函数。 Jinja上下文行为 这些变量被添加到了请求的上下文中，而非全局变量。其区别在于，默认不会在导入模板的上下文中出现。这样一方面是考虑到性能，另一方面是为了让事情显式透明。 若想要导入一个需要访问请求对象的宏，有两种方法： 显式地传入请求或请求对象的属性作为宏的参数 与上下文一起导入宏，其方式如下： 1&#123;% from '_helpers.html' import my_macro with contexr %&#125; 标准过滤器 tojson()函数把给定的对象转换为JSON表示。例如动态生成JavaScript： 123&lt;script type=text/javascript&gt; doSomethingWith( &#123; &#123;user.username|tojson|safe &#125; &#125; );&lt;!--|safe禁用转义--&gt;&lt;/script&gt; 控制自动转义 自动转义的概念是自动转义特殊字符。HTML（或XML）意义下的特殊字符是&amp;、&gt;、&lt;、\"、'。 控制自动转义可以有三种方法： 在传递到模板之前，用Markup对象封装HTML字符串。一般推荐这个方法。 在模板中，使用|safe过滤器显式地标记一个字符串为安全的HTML(myvariable|safe)。 临时地完全禁用自动转移系统，其方式如下： 1234&#123;% autoescape false %&#125; &lt;p&gt;autoescaping is disabled here &lt;p&gt;&#123; &#123; wii_not_be_escaped &#125; &#125;&#123;% endautoescape %&#125; 注册过滤器 若要在Jinja2中注册过滤器，可以把它们手动添加到应用的jinja_env或使用template_filter()装饰器： 123456789#使用template_filter()装饰器@app.template_filter('reverse')def reverse_filter(s): return s[::-1]#手动添加到应用的jinja_envdef reverse_filter(s): return s[::-1]app.jinja_env.filters['reverse']=reverse_filter 在使用装饰器的情况下，若想以函数名作为过滤器名，参数是可选的。注册之后，可以在模板中使用过。例如在上下文中有一个名为mylist的Python列表： 12&#123;% for x in mylist | reverse %&#125;&#123;% endfor %&#125; 上下文处理器 Flask上下文处理器自动向模板的上下文中插入新变量。上下文处理器在模板渲染之前运行，并且可以在模板上下文中插入新值。上下文处理器是一个返回字典的函数，这个字典的键值最终将传入应用中所有模板的上下文。： 123456789101112#上下文处理器@app.context_processordef inject_user(): return dict(user=g.user)#模板可以使用一个名为user，值为g.user的变量@app.context_processordef utility_processor(): def format_price(amount,currency=u'$'): return u'&#123;0:.2f&#125; &#123;1&#125;.format(amount,currency) return dict(format_price=format_price)#format_price函数在所有模板中可用#调用format_price函数&#123; &#123;format_price(0.33)&#125; &#125; 由于Python允许传递函数，其变量不仅仅限于值，上下文处理器也可以使某个函数在模板中可用。 即插视图 即插视图主要目的是可以替换已实现的部分，并且这个方式可以定制即插视图。 基本原则 若有一个从数据库载入一个对象列表并渲染到视图的函数： 1234@app.route('/users/')def show_users(page): users=User.query.all() return render_template('user.html',users=users) 这是简单而灵活的实现，但若想要用一种通用的，同样可以适应其他模型和模板的方式来提供这个视图，会需要更大的灵活性，而这就是基于类的即插视图所做的。 第一步，把它转换为基于类的视图： 123456from flask.views import Viewclass ShowUsers(View):#创建flask.views.View的子类 def dispatch_request(self): users=User.query.all() return render_template('users.html',objects=users)app.add_url_rule('/users/',ShowUsers.as_view('show_users'))#as_view把类转换到实际的视图 上面实现的方法还不够有效，因此需要重构一下代码： 1234567891011121314151617from flask.views import Viewclass ListView(View): def get_template_name(self):#self无论何时请求被调度都会创建这个类的新实例 raise NotImplementedError() def render_template(self,context): return render_template(self.get_template_name(),**context) def dispatch_request(self):#以URL规则为参数调用 context=&#123; 'objects':self.get_objects() &#125; return self.render_template(context)class UserView(ListView): def get_template_name(self): return 'user.html' def get_objects(self): return User.query.all()#将类实例化并进行注册app.add_url_rule('/about',view_func=RenderTemplateView.as_view( 'about_page',template_name='about.html')) 方法提示 即插视图可以像常规函数一样用route()或更好的add_url_rule()附加到应用中。而当进行附加时，必须提供HTTP方法的名称。为了将这个信息加入到类中，可以提供methods属性类承载它： 123456class MyView(View): methods=['GET','POST'] def dispatch_request(self): if request_method=='POST': passapp.add_url_rule('/myview',view_func=MyView.as_view('myview')) 基于调度的方法 对于每个HTTP方法执行不同的函数，对RESTfulAPI非常有用。可以通过flask.views.MethodView实现。每个HTTP方法映射到同名函数中（只有名称为小写的）： 123456789from flask.views import MethodViewclass UserAPI(MethodView): def get(self): users=User.query.all() pass def post(self): user=User.from_form_data(request.form) passapp.add_url_rule('/users/',view_func=UserAPI.as_view('users')) 如此便可以不提供method属性，其会自动按照类中定义的方法来设置。 装饰视图 视图类自己不是加入到路由系统的视图函数，那么就没有必要去装饰视图类，但可以手动装饰as_view()的返回值： 123456789def user_required(f): #检查用户是否登录，若没登录返回401错误 def decorator(*args,**kwargs): if not g.user: abort(401) return f(*args,**kwargs) return decoratorview=user_required(UserAPI.as_view('users'))app.add_url_rule('/users/',view_func=view) 从Flask0.8开始，增加了另一种在类声明中设定一个装饰器列表的方法： 12class UserAPI(MethodView): decorators=[user_required] 由于从调用者的视角来看self是不明确的，因此不能在单独的视图方法上使用常规的视图装饰器。 用于API的方法视图 WebAPI的工作通常与HTTP动词紧密相关，因此API需要不同的URL规则来访问相同的方法视图。 若要在web上暴露一个用户对象： URL HTTP 方法 描述 /users/ GET 获得全部用户的列表 /users/ POST 创建一个新用户 /users/&lt;id&gt; GET 显示某个用户 /users/&lt;id&gt; PUT 更新某个用户 /users/&lt;id&gt; DELETE 删除某个用户 可以利用MethodView对相同的视图提供多个规则，此时的视图为： 1234567891011121314151617class UserAPI(MethodView): def get(self,user_id): if user_id is None: #返回全部用户列表 pass else: #显示一个用户 pass def post(self): #创建一个新用户 pass def delete(self,user_id): #删除一个用户 pass def put(self,user_id): #更新一个用户 pass 添加两条规则，并为每条规则显式地指出HTTP方法，将它挂载到路由系统中： 123456user_view=UserAPI.as_view('user_api')app.add_url_rule('/users/',default=&#123;'user_id':None&#125;, view_func=user_view,methods=['GET',])app.add_url_rule('/users/',view_func=user_view,methods=['POST',])app.add_url_rule('/users/&lt;int:user_id&gt;',view_func=user_view, methods=['GET','PUT','DELETE']) 若有很多类似的API，可以重构上述的注册代码： 1234567def register_api(view,endpoint,url,pk='id',pk_type='int'): view_func=view.as_view(endpoint) app.add_url_rule(url,defaults=&#123;pk:None&#125;, view_func=view_funv,methods=['GET',]) app.add_url_rule(url,view_func=view_func,methods=['POST',]) app.add_url_rule('%s &lt; %s : %s &gt; ' % (url,pk_type,pk),view_func=view_func,methods=['GET','PUT','DELETE'])register_api(UserAPI,'user_api','/users/',pk='user_id') 用蓝图实现模块化的应用 一个应用中或跨应用制作应用组件和支持通用的模式称为蓝图。蓝图简化了大型应用的工作方式，并提供给Flask扩展在应用上注册操作的核心方法。一个Blueprint对象与Flask应用对象的工作方式很像，但它确实不是一个应用，而是描述如何构建或扩展应用的蓝图。 为什么使用蓝图 Flask中的蓝图为这些情况设计： 把一个应用分解为一个蓝图的集合。一个项目可以实例化一个应用对象，初始化几个扩展，并注册一集合的蓝图。 以URL前缀和/或子域名，在应用上注册一个蓝图。默认情况下，URL前缀/子域名中的参数即为这个蓝图下的所有视图函数的共同的视图参数。 在一个应用中用不同的URL规则多次注册一个蓝图。 通过蓝图提供模板过滤器、静态文件、模板和其他功能。一个蓝图不一定要实现应用或者视图函数。 初始化一个Flask扩展时，在这些情况中注册一个蓝图。 Flask中的蓝图不是即插应用，因为它虽然可以注册，甚至可以多次注册到应用上的操作集合中，但其实际上不是一个应用。可以使用多个应用对象，但应用的配置的分开的，并在WSGI层管理。 蓝图作为Flask层提供分隔的替代，共享应用配置，并且在必要情况下可以更新所注册的应用对象。其缺点是不能在应用创建后撤销注册一个蓝图而不销毁整个应用对象。 蓝图的设想 蓝图的基本设想是当它们注册到应用上时，它们记录将会被执行的操作。当分派请求和生成从一个端点到另一个URL时，Flask会关联蓝图中的视图函数。 蓝图的实现 实现一个简单渲染静态模板的蓝图如下： 1234567891011from flask import Blueprint,render_template,abortfrom jinja2 import TemplateNotFoundsimple_page=Blueprint('simple_page',__name__,template_folder='templates')@simple_page.route('/',defaults=&#123;'page':'index'&#125;)#绑定函数@simple_page.route('/&lt;page&gt;')def show(page): try: return render_template('pages/ %s.html' %page) except TemplateNotFound: abort(404) 当使用@simple_page.route装饰器绑定函数时，在蓝图之后被注册时它会记录把show函数注册到应用上的意图。除此之外还会给函数的端点加上有Blueprint的构造函数中给出的蓝图的名称作为前缀（如上述代码中是simple_page） 注册蓝图 注册蓝图： 1234from flask import Flaskfrom yourapplicarion.simple_page import simple_pageapp=Flask(__name__)app.register_blueprint(simple_page) 若检查已经注册到应用的规则，会发现这些生成出的规则： 123[ &lt;Rule '/static/&lt;filename&gt;' (HEAD, OPTIONS, GET) -&gt; static&gt;,#来自应用本身，用于静态文件 &lt;Rule '/&lt;page&gt;' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;,#用于simple_page蓝图中的show函数 &lt;Rule '/' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt; ]#用于simple_page蓝图中的show函数 蓝图在不同位置挂载时生成的规则也不同，如： 123456app.register_blueprint(simple_page,url_prefix='/pages')#生成的规则如下：[ &lt;Rule '/static/&lt;filename&gt;' (HEAD, OPTIONS, GET) -&gt; static&gt;,#来自应用本身，用于静态文件 &lt;Rule '/pages/&lt;page&gt;' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;,#挂载到pages页下，用于simple_page蓝图中的show函数 &lt;Rule '/pages/' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt; ] 除此之外还可以多次注册蓝图，但不是每个蓝图都会正确地响应。实际上蓝图能否被多次挂载，取决于蓝图是怎样实现的。 蓝图资源 蓝图也可以提供资源。有时候会只为它提供的资源而引入一个蓝图。 蓝图资源文件夹 蓝图被设想为包含在一个文件夹中。也有多个蓝图源于同一个文件夹的情况，但不推荐这种做法。 这个文件夹会从Blueprint的第二个参数中推断出来，通常是__name__。这个参数决定对应蓝图的是哪个逻辑的Python模块或包。若它指向一个存在的Python包，这个包就是资源文件夹。若是一个模块，模块所在的包就是资源文件夹。可以访问Blueprint.root_path属性来查看资源文件夹是什么，其语句为：simple_page.root_path。 可以使用open_resource()函数来快速从这个文件夹打开源文件： 12with simple_page.open_resource('static/style.css') as f: code=f.read() 静态文件 一个蓝图可以通过static_folder关键字参数提供一个指向文件系统上文件夹的路径，并以此来暴露一个带有静态文件的文件夹。这可以是一个绝对路径，也可以是相对于蓝图资源文件夹的路径： 1admin=Blueprint('admin',__name__,static_folfer='static') 默认情况下，路径最右边的部分就是它在web所暴露的地址。这个static的文件夹会在蓝图+/static的位置上可用，即蓝图为/admin把静态文件夹注册到/admin/static。 最后是用于命名的blueprint_name.static，也可以生成它的URL： 1url_for('admin.static',filename='style.css') 模板 若想要蓝图暴露模板，可以通过Blueprint构造函数中的template_folder参数来实现： 1admin=Blueprint('admin',__name__,template_folder='templates') 路径可以是绝对的或是相对蓝图资源文件夹的。模板文件夹会被加到模板的搜索路径中，但比实际的应用模板文件夹优先级低，因此可以在实际的应用中覆盖蓝图提供的资源。 因此当有一个yourapplication/admin文件夹中的蓝图并且想要渲染admin/index.html模板时，提供templates作为template_folder，则创建文件的路径为： yourapplication/admin/templates/admin/index.html。 构造URL 当想要用蓝图从一个页面链接到另一个页面时，可以使用url_for()函数，但要在UTL的末端加上蓝图的名称和一个点（.）来作为前缀。若在一个蓝图的视图函数或是模板中想要从链接到同一蓝图下另一个端点时，可以通过对端点只加上一个点作为前缀来使用相对的重定向： 12url_for('admin.index')#链接到admin蓝图的index页面url_for('.index')#链接到同一蓝图下的index页面","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Web框架","slug":"Web框架","permalink":"http://tangmenjue.top/categories/Web%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Flask Web","slug":"Flask-Web","permalink":"http://tangmenjue.top/tags/Flask-Web/"},{"name":"后端","slug":"后端","permalink":"http://tangmenjue.top/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Web框架","slug":"Web框架","permalink":"http://tangmenjue.top/tags/Web%E6%A1%86%E6%9E%B6/"}]},{"title":"Flask Web开发学习笔记（二）","slug":"Flask Web开发学习笔记（二）","date":"2022-10-20T08:36:28.000Z","updated":"2022-11-10T15:48:36.892Z","comments":true,"path":"2022/10/20/Flask Web开发学习笔记（二）/","link":"","permalink":"http://tangmenjue.top/2022/10/20/Flask%20Web%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"创建应用教程 创建文件夹 先创建应用所需的文件夹，接下来会直接把数据库模式和主模块放在这个目录中。用户可以通过HTTP访问static文件夹中的文件，即存放css和javascript文件的地方： 123/tutorweb /static /templates 创建数据库模式 创建schema.sql文件，文件里编写以下内容，放到tutorweb文件中： 123456drop table if exists entries;create table entries( id integer primary key autoincrement, title string not null, text string not null); 该模式包含一个名为entries的表，该表中的每行都包含一个id、一个title和一个text。id是一个自增的整数，也是主键，其余的两个是字符串且不允许为空。 应用设置代码 创建应用模块 创建应用的模块tutorweb.py并放置在tutorweb目录下。从添加所需的导入语句和添加配置部分开始。对于小型应用，可以直接把配置放在主模块里，但更简洁的方案是创建独立的.ini或.py文件，并载入里面的值。 首先在tutorweb.py里导入内容： 12345678910111213141516#导入所有模块import osimport sqlite3from flask import Flask,request,session,g,redirect,url_for,abort,\\ render_template,flash#配置文件DATABASE='./sqlite_db'USERNAME='admin'PASSWORD='default'DEBUG=True#创建应用app=Flask(__name__)app.config.from_object(__name__)app.secret_key='develop key' 数据库路径 操作系统有进程当前工作目录的概念，但由于在Web应用中相同的进程运用多个应用，因此不能依赖此概念。Flask提供了app.root_path属性以获取应用的路径，配合os.path模块的使用，可以轻松到达任意文件。在本例中，数据库放在根目录下。 通常只能加载一个单独的、环境特定的配置文件。Flask中使用from_envvar()方法可以实现允许导入多份配置文件，并使用最后的导入的设置。 1app.config.from_envvar('FLASKR_SETTINGS',slient=True) 只需要设置一个名为FLASKR_SETTINGS的环境变量指向要加载的配置文件，启动静默模式告诉Flask在没有设置该环境变量的情况下噤声。 此外还可以使用配置对象上的from_object()方法，并传递一个模块的导入名作为参数。Flask会从这个模块初始化变量，注意只有名称全为大写字母的变量才会被采用。 secret_key是保证客户端会话安全的重要所在。尽量选择一个尽可能难猜测、尽可能复杂的密钥。 调试标志关系交互式调试器的开启。永远不要在生产系统中激活调试模式，因为它将允许用户在服务器上执行代码。 添加一个连接到指定数据的方法是，用于请求时开启一个数据库连接，并在交互式Python shell和脚本中也能使用。在tutorweb.py文件中创建一个简单的SQLite数据库的连接，并让它用sqlite3.Row表示数据库中的行，使得可以通过字典而不是元组的形式访问行： 12345def connect_db(): #连接特定的数据库 rv=sqlite3.connect(app.config['DATABASE']) rv.row_factory=sqlite3.Row return rv 最后，若想要把这个文件当作独立应用来运行，只需在可启动服务器文件tutorweb.py的末尾加上这行代码即可运行这个应用： 12if __name__=='__main__': app.run() 此时在浏览器中访问服务器会遇到404 page not found错误，这是因为还没有创建任何视图的缘故。在创建视图之前，应该先让数据库工作起来。 数据库连接 Flask提供了两种环境：应用环境和请求环境。不同环境有不同的特殊变量。例如request变量与当前请求的请求对象有关，而g是当前应用环境有关的通用变量。 在tutorweb.py文件中可以写一个辅助函数把数据库连接存放在g对象上。这个函数首次调用时会为当前的函数创建一个数据库连接，调用成功后返回已经建立好的连接： 12345def get_db(): #打开一个新数据库连接 if not hasattr(g,'sqlite_db'): g.sqlite_db=connect_db() return g.sqlite_db Flask提供了teardown_appcontext()装饰器来断开数据库连接，它将在每次应用环境销毁时执行： 12345@app.teardown_appcontextdef close_db(error): #断开数据库连接 if hasattr(g,'sqlite_db'): g.sqlite_db.close() 本质上，应用环境在请求传入前创建，每当请求结束时销毁。销毁有两种原因：一切正常（错误参数是None）或发送异常，后者错误会被传递给销毁函数。 创建数据库 Flask是一个由关系数据库驱动的应用。关系数据库系统需要一个模式来决定存储信息的方式。 创建模式 可以通过管道把schema.sql作为sqlite3命令的输入来创建这个模式： 1sqlite3 /tmp/flaskr.db &lt; schema.sql 这种方法的缺点是需要安装sqlite3命令，且必须提供数据库的路径，否则会报错。因此比较推荐使用函数来初始化数据库。 创建一个名为init_db的函数来初始化数据库，只需要把这个函数放在tutorweb.py里的connect_db函数后面并调用init_db()函数来创建数据库： 123456789def init_db():#建立应用环境，在with内部，g对象与app关联，在语句结束出会释放这个关联并执行所有销毁函数，即数据库连接会在提交后断开 with app.app_context(): db=get_db() #open_resource可以打开应用提供的资源，在tutorweb文件夹打开文件并允许读取它，用它来在数据库连接上执行脚本 with app.open_resource('schema.sql',mode='r') as f: db.cursor().executescript(f.read()) db.commit() init_db() 应用环境在每次请求传入时创建，这里并没有请求，故需要手动创建一个应用环境。g在应用环境外无法获知它属于哪个应用，因为可能会有多个应用同时存在。 SQLite的数据库连接对象提供了一个游标对象，游标上有一个方法可以执行完整的脚本。最后只需提交变更，SQLite3和其他支持事务的数据库只会在显示提交的时候提交。 视图函数 数据库连接正常工作后，共需要写四个视图函数。 显示条目 这个视图显示数据库中存储的所有条目，它绑定在应用的根地址，并从数据库查询出文章的标题和正文。id值最大的条目（最新的条目）会显示在最上方。从指针返回的行是按select语句中声明的列组织元组。 视图函数会将条目作为字典传递给show_entries.html模板，并返回渲染结果： 1234567@app.route('/') def show_entries(): #显示条目 g.db=get_db() cur=g.db.execute('select title, text from entries order by id desc') entries=[dict(title=row[0],text=row[1]) for row in cur.fetchall()] return render_template('show_entries.html',entries=entries) 添加条目 这个视图允许已登入的用户添加新条目，并只响应POST请求，实际的表单显示在show_entries页。若一切工作正常，用flash()向下一次请求发送提示消息，并重定向回show_entries页： 1234567891011@app.route('/add',methods=['POST'])def add_entry(): #添加条目 g.db=get_db() if not session.get('logged_in'): abort(401) g.db.execute('insert into entries (title,text) values (?,?)', [request.form['title'],request.form['text']]) g.db.commit() flash('New entry was successfully posted') return redirect(url_for('show_entries')) 注意这里的用户登入检查（logged_in键在会话中存在且为True） 安全提示： 确保像上面代码一样使用问号标记来构建SQL语句。否则当使用格式化字符串构建SQL语句时，所建立的应用容易遭受SQL注入。 登入和登出 这个函数用来让用户登入。登入通过与配置文件中的数据比较检查用户名和密码，并设定会话中的logged_in键值。若用户成功登入，这个键值会被设为True，并跳转回show_entries页。此外还会有信息闪现来提示用户登入成功。如果发生一个错误，模板会通知并提示重新登录。 1234567891011121314@app.route('/login',methods=['GET','POST']) def login(): #登入和登出 error=None if request.method=='POST': if request.form['username']!=app.config['USERNAME']: error='Invalid username' elif request.form['password']!=app.config['PASSWORD']: error='Invalid password' else: session['logged_in']=True flash('You were logged in') return redirect(url_for('show_entries')) return render_template('login.html',error=error) 这个函数用来让用户登出。从会话中删除logged_in键。使用字典的pop()方法并传入第二个参数（默认），以从字典删除这个键，若这个键不存在则什么都不做。 123456@app.route('/logout')def logout(): #登出 session.pop('logged_in',None) flash('You were logged out') return redirect(url_for('show_entries')) 模板 若现在请求URL，只会得到Flask无法找到模板的异常。模板使用Jinja2语法并默认开启自动转义。这意味着除非使用Markup标记或在模板中使用|safe过滤器，否则Jinja2会确保特殊字符，比如&lt;或&gt;被转义为等价的XML实体。 layout.html 将下面的模板放进templates文件夹里。这个模板包含HTML主体结构、标题和一个登入链接（用户已登入则提供登出）。若有，它会显示闪现消息。 1&#123;% block body %&#125; 模块可以被子模版中相同名字的块（body）替换。 session字典在模板中也是可用的，可以用它来检查用户是否已登入。在Jinja中你可以访问不存在的对象、字典属性或成员。 1234567891011121314151617&lt;!doctype html&gt;&lt;title&gt;tutorweb&lt;/title&gt;&lt;link rel=stylesheet type=text/css href=\"&#123;&#123;url_for('static',filename='style.css')&#125;&#125;\"&gt;&lt;div class=page&gt; &lt;h1&gt;tutorweb&lt;/h1&gt; &lt;div class=metanav&gt; &#123;% if not session.logged_in %&#125; &lt;a href=\"&#123;&#123;url_for('login')&#125;&#125;\"&gt;log in&lt;/a&gt; &#123;% else %&#125; &lt;a href=\"&#123;&#123;url_for('logout')&#125;&#125;\"&gt;log out&lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% for message in get_flashed_messages() %&#125; &lt;div class=flash&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; &#123;% endfor %&#125; &#123;% block body %&#125;&#123;% endblock %&#125;&lt;/div&gt; show_entries.html 这个模板继承了上面的layout.html模板来显示消息。注意for循环会遍历并输出所有render_template()函数传入的消息。还告诉表单使用HTTP的POST方法提交信息到add_entry函数： 123456789101112131415161718192021&#123;% extends \"layout.html\" %&#125;&lt;!--模板继承，继承layout.html的内容--&gt;&#123;% block body %&#125; &#123;% if session.logged_in %&#125;&lt;!--初次登录，session.logged_in为假，下面的内容不显示--&gt; &lt;form action=\"&#123;&#123;url_for('add_entry')&#125;&#125;\" method=post class=add-entry&gt; &lt;dl&gt; &lt;dt&gt;Title: &lt;dd&gt;&lt;input type=text size=30 name=title&gt; &lt;dt&gt;Text &lt;dd&gt;&lt;textarea name=text rows=5 cols=40&gt;&lt;/textarea&gt; &lt;dd&gt;&lt;input type=submit value=Share&gt; &lt;/dl&gt; &lt;/form&gt; &#123;% endif %&#125; &lt;ul class=entries&gt; &#123;% for entry in entries %&#125; &lt;li&gt;&lt;h2&gt;&#123;&#123;entry.title&#125;&#125;&lt;/h2&gt;&#123;&#123;entry.text|safe&#125;&#125; &#123;% else %&#125;&lt;!--此次登录默认显示以下内容--&gt; &lt;li&gt;&lt;em&gt;Unbelievable. No entries here so far&lt;/em&gt; &#123;% endfor %&#125; &lt;/ul&gt; &#123;% endblock %&#125; login.html 最后是登入模板，简单地显示一个允许用户登入的表单： 123456789101112131415&#123;% extends \"layout.html\" %&#125;&lt;!--模板继承layout.html的内容--&gt;&#123;% block body %&#125;&lt;!--重载--&gt; &lt;h2&gt;Login&lt;/h2&gt; &lt;!--error不为None时显示出错误原因--&gt; &#123;% if error %&#125;&lt;p class=error&gt;&lt;strong&gt;Error:&lt;/strong&gt;&#123;&#123;error&#125;&#125;&#123;% endif %&#125; &lt;form action=\"&#123;&#123;url_for('login')&#125;&#125;\" method=post&gt;&lt;!--action后是form表单提交的地址--&gt; &lt;dl&gt; &lt;dt&gt;Username: &lt;dd&gt;&lt;input type=text name=username&gt; &lt;dt&gt;Password &lt;dd&gt;&lt;input type=password name=password&gt; &lt;dd&gt;&lt;input type=submit value=Login&gt; &lt;/dl&gt; &lt;/form&gt; &#123;% endblock %&#125; 添加样式 现在其他的一切都可以正常工作，是时候给应用添加样式了。只需在static文件夹中创建一个名为style.css的样式表即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859body&#123; font-family:sans-serif; background:#eee;&#125;a,h1,h2&#123; color:#377BAB;&#125;h1,h2&#123; font-family:'Georgia',serif; margin:0;&#125;h1&#123; border-bottom:2px solid #eee;&#125;h2&#123; font-size:1.2em;&#125;.page&#123; margin:2em auto; width:35em; border:5px solid #ccc; padding:0.8em; background:white;&#125;.entries&#123; list-style:none; margin:0; padding:0;&#125;.entries li&#123; margin:0.8em 1.2em;&#125;.entries li h2&#123; margin-left:-1em;&#125;.add-entry&#123; font-size:0.9em; border-bottom:1px solid #ccc;&#125;.add-entry dl&#123; font-weight:bold;&#125;.metanav&#123; text-align:right; font-size:0.8em; padding:0.3em; margin-bottom:1em; background:#fafafa;&#125;.toturweb&#123; background:#CEE5F5; padding:0.5em;; border:1px solid #AACBE2;&#125;.error&#123; background:#F0D6D6; padding:0.5em;&#125; 最后运行tutorweb.py程序即可在127.0.0.0:5000上看到创建的应用。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Web框架","slug":"Web框架","permalink":"http://tangmenjue.top/categories/Web%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Flask Web","slug":"Flask-Web","permalink":"http://tangmenjue.top/tags/Flask-Web/"},{"name":"后端","slug":"后端","permalink":"http://tangmenjue.top/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Web框架","slug":"Web框架","permalink":"http://tangmenjue.top/tags/Web%E6%A1%86%E6%9E%B6/"}]},{"title":"python学习笔记（十二）","slug":"python学习笔记（十二）","date":"2022-10-19T09:05:39.000Z","updated":"2022-12-06T12:39:28.669Z","comments":true,"path":"2022/10/19/python学习笔记（十二）/","link":"","permalink":"http://tangmenjue.top/2022/10/19/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/","excerpt":"","text":"python语言特点 python语言特点： 开源 免费 跨平台 解析执行 复制=、copy()和deepcopy() 用=复制元素，原object改变，现object也随之改变 用copy()复制object，原object改变，现object不变，若object中包含了list，改变原object的list元素，现object的list元素也随之改变。 用deepcopy()复制object，原object改变，现object的任何元素都不会变。 12345678910111213141516import copya = [1, 2, 3, 4, ['a', 'b']]b = a#a变b也变,c = copy.copy(a)#a变c不变,a里的list['a', 'b']变，c也会变d = copy.deepcopy(a)#a变d不变，a里的list['a', 'b']变，d也不会变a.append(5)a[4].append('c')print(a)print(b)print(c)print(d)#运行结果如下[1, 2, 3, 4, ['a', 'b', 'c'], 5][1, 2, 3, 4, ['a', 'b', 'c'], 5][1, 2, 3, 4, ['a', 'b', 'c']][1, 2, 3, 4, ['a', 'b']] Python自带的模块 Python有着形形色色爬虫相关的库,以下哪个库Python自带不需要额外下载。A A.urlib python内置，用于爬虫 B.urlib3 第三方库 C.Requests python内置，用于http D.lxml 第三方库 extend方法 extend() 函数用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表），添加数据时要用[]把数据括起来。 在Python3中，程序运行结果为： lists = [1, 1, 2, 3, 4, 5, 6] lists.remove(1) lists.extend([7,8,9]) print(lists)。C A.[2,3,4,5,6] B.[1,2,3,4,5,6,[7,8,9]] C.[1,2,3,4,5,6,7,8,9] D.[2,3,4,5,6,7,8,9] del方法 将列表内的所有元素均删除，且列表存在，使用del方法 字符串变换 字符串是不可变类型，无法直接修改字符串的某一位字符。replace()函数用于替换字符串，其用法为字符串序列.replace(旧子串, 新子串, 替换次数)。 若a = 'abcd'，若想将a变为'ebcd'，则下列语句正确的是。 D A.a[0] = 'e' B.a.replace('a\", \"e') C.a[1] = 'e' D.a = 'e' + \"bcd\" divmod()函数 divmod(a,b)函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a//b,a%b) 下面代码的输出结果是 x=10 y=3 print(divmod(x,y))。D A.(1, 3) B.3,1 C.1,3 D.(3, 1) python2与python3除法的区别 在python2中，由于“地板除”的 缘故，每次除完后只剩整数。在python3中的除法是精确计算。 在Python3中，下列程序循环的次数为： n = 1000 while n &gt; 1: print(n) n = n / 2。B A.9 B.10 C.11 D.无限循环 python2里只有9次，因为500、250、125、62、31、15、7、3、1 。python3里有10次，因为500、250、125、62.5、31.25、15.625、7.8125、3.90625、1.953125、0.9765625。 函数返回值 以下程序的输出结果是 def hub(ss, x = 2.0,y = 4.0): ss += x * y ss = 10 print(ss, hub(ss, 3))。B A.22.0 None B.10 None 函数hub设置没有返回值，ss默认为10，hub默认返回done C.22 None D.10.0 22.0 python查找顺序 当使用import导入模块时，按python查找模块的不同顺序可划分为以下几种： ①环境变量中的PYTHONPATH ②内建模块 ③python安装路径 ④当前路径，即执行python脚本文件所在的路径 其中查找顺序正确的一组是。C A.①④②③ B.②①④③ C.②④①③ D.①②③④ range范围 range(n)实际上是取值0~n-1。 sum([i*i for i in range(3)])的计算结果是。B A.3 B.5 C.2 D.14 readlines函数 read(size)方法，每次最多读取size个字节的内容。不需要通过close函数关闭文件。 关于以下代码的描述，错误的选项是()with open( ' abtxt ' , ' r+' ) as f:lines = f.readlines() for item in lines:print(item)。A A.执行代码后，abc.txt文件未关闭，必须通过close()函数关闭 B.打印输出abc.txt文件内容 C.item是字符串类型 D.lines是列表类型 lambda表达式 lambda只是一个表达式不是代码块，而def是一个语句。 在内部只能包含一行代码，自动返回最后一个表达式的值，没有return，参数列表不需要用括号。 if、for或print语句不能用于lambda中，不能共享给其他程序调用。 关于匿名函数叙述正确的是（）。ABC A.lambda只是一个表达式，函数体比def简单很多 B.lambda的主体不是一个代码块 C.lambda函数只能写一行 D.可以访问全局变量和函数体以外的变量 运算符优先级 括号：() 幂运算：** 按位取反：~ 正号、负号：+、- 乘除、取模、取整除：*、/、%、// 加、减：+、- 左移、右移：&lt;&lt;、&gt;&gt; 按位“与”：&amp; 按位“异或”、按位“或”：^、| 比较运算符：&lt;=、&lt;、&gt;、&gt;= 等于、不等于：==、!= 赋值运算符：=、%=、/=、//、//=、-=、+=、*=、**= 身份运算符：is、is not 成员运算符：in、not in 逻辑运算符：and、or、not Python中，运算符由高到低为。C A.逻辑运算符&gt;比较运算符&gt;赋值运算符&gt;位运算符 B.位运算符&gt;赋值运算符&gt;比较运算符&gt;逻辑运算符 C.位运算符&gt;比较运算符&gt;赋值运算符&gt;逻辑运算符 D.逻辑运算符&gt;赋值运算符&gt;比较运算符&gt;位运算符 下列哪些语句在Python中是合法的。ACD A.x = y = z=1 B.x =(y = z+ 1) C.x,y = y,x D.x+= y for i,x in enumerate() 函数 enumerate是枚举的意思，把元素一个个列举出来，它返回的是元素以及对应的索引。例如： 123456789&gt;&gt;&gt; line = [1,2,3,4,5]&gt;&gt;&gt; for i,j in enumerate(line):... print(i,j)...0 11 22 33 44 5 在Python3中，下列程序运行结果为： lists = [1, 2, 3, 4] tmp = 0 for i,j in enumerate(lists): tmp += i * j print(tmp) 。A A.20 tmp=0+1*2+2*3+3*4=2+6+12=20 B.30 C.100 D.None replace函数 replace函数不会改变原string的内容。 执行以下程序，输入”93python22”，输出结果是 w = input(\"请输入数字和字母构成的字符串：\") for x in w: if '0'&lt;= x &lt;= '9': continue else: w.replace(x,'') print(w)。C A.python9322 B.python C.93python22 D.9322 floor函数 math.floor(x)函数用于将x向下取整，它接收数字/数字表达式并返回不大于数字的最大整数值。math.ceil(x)函数用于x向上取整，它接收数字/数字表达式并返回最接近的数字最小整数值。 以下代码运行结果是什么?0import math print math.floor(5.5)。A A.5 B.5.0 C.5.5 D.6 按位与&amp;计算 python 中 &amp; (按位与) 和 | (按位或) 是把 2个数据转为二进制然后在做相应的计算。如 12345678910111213141516171819202122232425262728293031323334353637383940414243a = 10 # 10的二进制为1010b = 18 # 18的二进制为10010\"\"\"按位与运算符:&amp; : 如果两个相应位都为1,则该位的结果为1,否则为00101010010计算的结果为:00010把二进制00010转10进制结果为2,所以下面的打印结果应该为2\"\"\"print(a &amp; b) # 打印结果为2\"\"\"按位或运算符:| : 只要对应的二个二进位有一个为1时，结果位就为10101010010计算的结果为:11010把二进制11010转10进制结果为26,所以下面的打印结果应该为26\"\"\"print(a | b) # 打印结果为26\"\"\"按位异或运算符:^ : 当两对应的二进位相异时，结果为10101010010计算的结果为:11000把二进制11000转10进制结果为24,所以下面的打印结果应该为24\"\"\"print(a ^ b) # 打印结果为24\"\"\"按位取反运算符:~ : 对数据的每个二进制位取反,即把1变为0,把0变为1 01010计算的结果为:10101把二进制10101转10进制结果为-11,所以下面的打印结果应该为-11\"\"\"print(~a) # 打印结果为-11 下面描述正确的是。ABC A. 在python中逻辑与运算符不能写作&amp;&amp;，要写作and B.&amp;是两个数字按二进制位作与运算的操作符 C.3&amp;2的结果为2 00011 00010=&gt;00010=2 D.3&amp;3的结果为0 00011 00011=&gt;00011=3 python保留字符 以下哪些是Python中的保留字符?ABCD A.def B.global C.finally D.yield 可变数据类型和不可变数据类型 可变数据类型：list(列表)、dict(字典)、set(集合) 不可变数据类型：数值类型(int、float、bool)、string(字符串)、tuple(元组) 下列选项属于不可变类型的是。CD A.列表 B.字典 C.元组 D.字符串 python内置函数 内置函数 Aabs()aiter()all()any()anext()ascii() Bbin()bool()breakpoint()bytearray()bytes() Ccallable()chr()classmethod()compile()complex() Ddelattr()dict()dir()divmod() Eenumerate()eval()exec() Ffilter()float()format()frozenset() Ggetattr()globals() Hhasattr()hash()help()hex() Iid()input()int()isinstance()issubclass()iter() Llen()list()locals() Mmap()max()memoryview()min() Nnext() Oobject()oct()open()ord() Ppow()print()property() Rrange()repr()reversed()round() Sset()setattr()slice()sorted()staticmethod()str()sum()super() Ttuple()type() Vvars() Zzip() **_**__import__() 以下属于python3内置函数的是。ABCD A.str() B.sum() C.zip() D.sorted() python数据类型 python中有六个标准的数据类型： Number(数字) String(字符串) List(列表) Dict(字典) Tuple(元组) Set(集合) 其中Number里包含了int、float、bool、complex(复数)。在python3中只有一种整数类型int，没有python2中的长整型long。 以下哪些是Python的数字类型。ACD A.long B.double C.float D.complex 控制循环语句 continue：将控制返回到循环的开始 break：将控制带出循环 pass：编写空循环，除此之外还用于空的控制语句、函数和类 Python中，循环控制语句有。BCD A.goto B.break C.continue D.pass __name__ __name__是python的一个内置类属性，它存储模块的名称。 python模块既可以被调用，也可以独立运行。而调用时__name__存储的是py文件名（模块名称），独立运行时存储的是__main__。其作用主要是用来区分当前模块是独立运行还是被调用。 关于__name__的说法，下列描述正确的是。BCD A.它是Python提供的一个方法 B.每个模块内部都有一个__name__属性 C.当它的值为’main‘时，表示模块自身在运行 D.当它的值不为’main’时，表示模块被引用 json.dumps()与json.loads() json.dumps()：将python对象编码成Json字符串 json.dump()：将python对象转化成Json储存到文件中 json.loads()：将Json字符串解码成python对象 json.load()：将文件中的json格式转化成python对象提取 运行下列代码段，输出结果为True的是（ ）。BD 1234import jsondata='&#123;\"one\":\"1\",\"two\":\"2\",\"three\":\"3\",\"four\":\"4\",\"five\":\"5\"&#125;'text = json.loads(data)print(type(data)==type(text)) 12data='&#123;\"one\":\"1\",\"two\":\"2\",\"three\":\"3\",\"four\":\"4\",\"five\":\"5\"&#125;'print(type(data)==type('123')) 1234import jsondata='&#123;\"one\":\"1\",\"two\":\"2\",\"three\":\"3\",\"four\":\"4\",\"five\":\"5\"&#125;'text = json.loads(data)print('1' in text) 1234import jsondata = '&#123;\"one\":\"1\",\"two\":\"2\",\"three\":\"3\",\"four\":\"4\",\"five\":\"5\"&#125;'text = json.dumps(data)print('1' in text) 类定义体组成 类定义体组成： 成员的控制访问信息（public、protected、private) 数据成员 成员函数 在类的定义形式中,组成了类定义体是。ABC A.成员的访问控制信息 B.数据成员 C.成员函数 D.私有消息 关于return函数 在python中，关于函数return语句的正确说法是。ACD A.return指定函数返回值，用来结束函数 B.在python中return语句只可返回一个值 C.无返回值函数中可以没有return语句 D.如果不给return，函数默认返回None 无返回值函数是指void这一类的函数。 万物皆为对象 容器对象（list、dict、set等）中可以存放任何对象，包括整数、字符串，函数也可以作存放到容器对象中。 Python中函数是对象，描述正确的是。ABCD A.函数可以赋值给一个变量 B.函数可以作为元素添加到集合对象中 C.函数可以作为参数值传递给其它函数 D.函数可以当做函数的返回值 切片取数 L[0:3]表示从索引0开始取数，直到索引3为止，但不包括索引3的元素。 若输入的字符串str=’asdfgh’，想要输出为’asdfg’，则可以使用以下方法。AC A.str[:-1] B.str[:-2] C.str[:5] D.str[:4] 下列可以得到字符串'ccc'的Python语句是。ABD A.cc'+'c' B.'c'*3 C.'bcccb'[1:3] D.'bcccb'[1:4] 若a = range(100)，以下哪些操作是合法的。ABCD A.a[-3] B.a[2:13] C.a[::3] D.a[2-3] 函数调用 在模块A导入B模块的函数func（），并执行函数调用，下列写法正确的是。AC A. 导入：import B 调用 B.func() B. 导入：import B 调用 func() C. 导入：form B import func 调用 func() D. 导入：form B import func 调用B. func() python不能正常启动 python不能正常启动的项有： 拼写错误 错误表达式 缩进错误 只有手动抛出异常才能正常启动。 python的六种进程间通信方式 msg_queue(消息队列) pipeline for single duplex(单工管道) pipeline for half duplex(双工管道) name pipeline(命名管道) share memory(共享内存) semaphore(信号量) 在python3中进程之间通信通常可以采用如下哪些方式。ABD A.Queue B.Pipe C.全局变量 D.共享数据 __new__和__init__的区别 相同点： 两者都是python面向对象语言的函数。 不同点： __new__是在实例创建之前被调用的，是个静态方法。因为它的任务是创建实例然后返回该实例对象。 __init__是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值，是一个实例方法。通常用于初始化一个类实例。 关于__new__与__init__的区别，说法正确的是。ABCD A.__new__是一个静态方法，而__init__是一个实例方法 B.__new__方法会返回一个创建的实例，而__init__什么都不返回 C.只有在__new__返回一个创建的实例时，后面的__init__才能被调用 D.当创建一个新实例时调用__new__,初始化一个实例时用__init__ 输入输出总结 单行输入 同一行里空格分隔输入两个数：a,b=list(map(int,input().split())) 同一行里逗号分隔输入两个数：a,b=list(map(int,input().split(','))) 使用sys模块输入多位数： 123456789101112import sys#输入数据，返回一个包含多个字符串的列表a,strip()用于截取掉末尾的换行符a=sys.stdin.readline().strip()#a中的数据以逗号分隔时，去掉逗号，返回一个包含多个字符串的列表bb=list(map(int,a.split(',')))#a中的数据以空格分隔时，去掉空格，返回一个包含多个字符串的列表cc=list(map(int,a.split()))#同一行中输入以空格分隔的两位数n,mn,m=list(map(int,sys.stdin.readline().strip().split())) 多行输入 把所有行合在一个列表中： 12345678910111213141516171819202122import syslist=[]list_new=[]for line in sys.stdin: list_new=line.split() list.append(list_new) # list.extend(list_new) print(list)#使用append的输出结果：3 2[['3', '2']]1 5 6[['3', '2'], ['1', '5', '6']]1 3[['3', '2'], ['1', '5', '6'], ['1', '3']]#使用extend的输出结果：3 2['3', '2']1 5 6['3', '2', '1', '5', '6']1 3['3', '2', '1', '5', '6', '1', '3'] 行数固定且第一行给出，各行独立获取： 12345678910111213141516import syslines=sys.stdin.readlines()n=int(lines[0])x1=list(map(int,lines[1].split()))x2=list(map(int,lines[2].split()))x3=list(map(int,lines[3].split()))print(n,x1,x2,x3)#运行结果如下：输入：31 5 61 8windows系统同时按下ctrl+z+enter结束输入输出结果为：3 [1, 5, 6] [1] [8] 第一行输入人数n和科目m，后续每行录入每人的m科成绩： 123456789101112n,m=list(map(int,input().split()))lines=[]for i in range(n): lines.append(list(map(int,input().split())))print(lines)#运行结果如下：输入：2 315 32 2358 20 69输出结果为：[[15, 32, 23], [58, 20, 69]] 行数未知时，输入多行数字序列： 12345678910111213141516res=[]while True: try: res.append(list(map(int,input().split()))) except: breakprint(res)#运行结果如下：输入：3 63 72 72 11 52 62 5 1 2 4 75 8 9 3 53 12 74windows系统同时按下ctrl+z+enter结束输入输出结果为：[[3, 63, 72, 72, 1], [1, 52, 62, 5, 1], [2, 4, 7], [5, 8, 9, 3, 53, 12, 74]] 单行输出 同一行里逗号分隔输出两个数：print(str(a)+','+str(b)) 多行输出 按行遍历输出多行输入中的元素，注意：不是输出一个list或tuple： 123456789101112131415161718192021222324252627import sysdata=[]while True: line=sys.stdin.readline().strip() if not line: break tmp=list(map(int,line.split())) data.append(tmp)for i in range(0,len(data)): for j in range(0,len(data[i])): # print(i[k]) if j==(len(data[i])-1): print(data[i][j]) else: print(str(data[i][j])+' ',end=\"\")#运行结果如下：输入：3 63 72 72 11 52 62 5 1 2 4 75 8 9 3 53 12 74windows系统同时按下ctrl+z+enter结束输入输出结果为：3 63 71 71 11 52 62 5 12 4 75 8 9 3 53 12 74 补充 标准库OS的listdir()方法默认只能列出指定文件夹中当前层级的文件和文件夹列表，而不能列出其子文件夹中的文件。 递归是从问题的最终目标出发，逐渐将复杂问题化为简单问题，最终求得问题。递推是从简单问题触发，一步步的向前，最终求得问题。 列表对象的extend()方法属于原地操作，调用前后列表对象的地址不变。 Python中子类能继承父类全部的公有属性和方法。 使用print()函数可以将信息写入文件：print(\"Hello, World!\", file=open('file.txt', 'w'))。 两个特殊的形参关键字形参和命名关键字形参不能设定默认值，或者说它们默认值就是空元组和空字典。 为了限制开头几个参数只能按位置传递，从python3.8开始，正式引入限定位置形参，它们必须放在形参表的最前面，并在后面使用斜杠/（独占一个参数位）与普通形参分隔。如def fun(a,b,c,/,d) #a,b,c成为限定位置形参。 默认值可以从限定位置形参或普通形参中的任意一个开始设定，除了命名关键字形参，所有带默认值的形参必须位于五默认值的形参之后。 定义函数时，带有默认值的参数必须出现在参数列表的最右端，任何一个带有默认值的参数右边不允许出现没有默认值的参数。 使用print()函数时，使用\\n可以进行换行输出。 表达式[1,3,2] &gt; [1,2,3]的值为True，{1,3,2} &gt; {1,2,3}的值为False。 使用if '__name__'== '__main__'，可以保证模块被导入时，其内的代码不会被执行。 表达式pow(3, 2)==3**2的值为True。其中**代表乘方。 所有的except子句一定在else和finally的前面。 Python中break和continue语句不可以单独使用，只能在循环中使用。 split()将一个字符串分割为子字符串，然后将结果作为字符数组返回。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://tangmenjue.top/tags/python/"}]},{"title":"Flask Web开发学习笔记（一）","slug":"Flask Web开发学习笔记（一）","date":"2022-10-18T08:29:33.000Z","updated":"2022-11-10T15:48:44.334Z","comments":true,"path":"2022/10/18/Flask Web开发学习笔记（一）/","link":"","permalink":"http://tangmenjue.top/2022/10/18/Flask%20Web%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"安装部署 创建环境 使用pip分别安装virtualenv、simplejson、flask、sqlalchemy模块，其命令用法为：pip install 安装的模块名。 virtualenv安装完毕后，新建一个项目文件夹myproject，打开cmd，使用cd切换到myproject目录，通过下列命令来创建虚拟环境venv，命令完成后会在myproject文件夹里生成一个venv文件夹。 12cd myprojectvirtualenv venv 激活venv环境 1venv\\scripts\\activate 激活virtualenv中的Flask 1pip install Flask 快速入门 一个最小的应用 在一个.py文件中输入以下代码，并运行，可以得到一个最小的Flask应用。 123456789from flask import Flask #导出Flask类# 创建了该类的实例，第一个参数为应用模块名，单一模块使用__name__app=Flask(__name__)@app.route('/')# 使用装饰器告诉Flask什么样的URL能触发函数def hello_world(): return 'Hello World!'if __name__=='__main__': app.run()# run函数让应用运行在本地服务器上 运行代码后访问http://127.0.0.1:5000，可以在页面中看到Hello World!的问候。 外部可访问的服务器： 若运行这个服务器时，会发现它只能从本地的计算机上访问，网络中其他的用户都不能访问。在调试模式下，用户可以在本地计算机上执行任意Python代码。因此这个行为是默认的。 若禁用了debug或信任所在网络的用户，可以修改调用run()方法来使服务器是公开可用的： 1app.run(host='0.0.0.0')# 让操作系统监听所有公网IP 调试模式 若启动了调试支持，服务器会在代码修改后自动重新载入，并在发送错误时提供一个相对有用的调试器。 方法一启动调试模式： 直接在应用对象上设置： 12app.debug=Trueapp.run() 方法二启动调试模式： 作为run方法的一个参数传入： 1app.run(debug=True) 注意：交互式调试器绝对不能用于生产环境。 路由 Web应用的URL易于人们辨识记忆，对于面向使用低速网络连接移动设备访问的应用特别有用。用route()装饰器把一个函数绑定到对于的URL上，可以实现不访问索引页，直接访问想要的页面。例如： 12345678910111213141516from flask import Flask app=Flask(__name__)@app.route('/')def index(): return 'Index Page'@app.route('/hello') def hello_world(): return 'Hello World!'if __name__=='__main__': app.run()#运行结果如下：默认页面 Index Page输入127.0.0.1:5000/hello路由时，跳转到Hello World!的页面 不仅如此，还可以构造含有动态部分的URL，也可以在一个函数上附着多个规则。 变量规则 给URL添加变量部分，可以把这些特殊的字段标记为&lt;variable_name&gt;，这个部分将会作为命名参数传递到函数中。规则可以用&lt;converter:variable_name&gt;指定一个可选的转换器。例如： 1234567891011121314151617181920from flask import Flask app=Flask(__name__)@app.route('/')def index(): return 'Index Page'@app.route('/user/&lt;username&gt;') def show_user_profile(username): return 'User %s' % username@app.route('/post/&lt;int:post_id&gt;')def show_post(post_id): return 'Post %d' % post_idif __name__=='__main__': app.run()#运行结果如下：默认页面 Index Page输入127.0.0.1:5000/user/ok路由时，跳转到User ok的页面输入127.0.0.1:5000/post/8080路由时，跳转到Post 8080的页面 转换器有下面几种： int 接受整数 float 同 int ，但是接受浮点数 path 和默认的相似，但也接受斜线 唯一URL/重定向行为： Flack的URL规则基于Werkzeug的路由模块，该模块基于Apache以及更早的HTTP服务器主张的先例，保证优雅且唯一的URL。例如： 123456789101112131415161718192021from flask import Flask app=Flask(__name__)@app.route('/')def index(): return 'Index Page'@app.route('/projects/')def projects(): return 'The project page'@app.route('/about') def about(): return 'The about page'if __name__=='__main__': app.run()#运行结果如下：默认页面 Index Page 输入127.0.0.1:5000/projects/路由时，跳转到The project page的页面输入127.0.0.1:5000/projects路由时，跳转到The project page的页面输入127.0.0.1:5000/about路由时，跳转到The about page的页面 输入127.0.0.1:5000/about/路由时，跳转到404 Not Found的页面 如此可见，指向projects的规范带结尾斜线，访问结尾不带斜线的URL会被Flask重定向到带斜线的规范URL中。而指向about的规范不带结尾斜线，访问结尾带斜线的URL会产生一个404\"Not Found\"错误。 这一行为使得在遗忘结尾斜线时，允许关联的URL接任工作，同时也保证了URL的唯一，有助于避免搜索引擎索引同一个页面两次。 构造URL FLask不仅可以匹配URL，还可以用url_for()来给指定的函数构造URL。它接收函数名作为第一个参数，也接受对于URL规则的变量部分的命名函数。位置变量部分会添加到URL末尾作为查询函数。例如： 12345678910111213141516171819202122232425262728from flask import Flask,url_forapp=Flask(__name__)@app.route('/')def index(): return 'The index page'@app.route('/login')def login(): return 'The login page'@app.route('/user/&lt;username&gt;')def profile(username): return 'The profile page'with app.test_request_context(): print(url_for('index')) print(url_for('login')) print(url_for('login',next='/')) print(url_for('profile',username='Bob'))if __name__=='__main__': app.run()#运行结果如下：默认页面 Index Page 输入127.0.0.1:5000/login路由时，跳转到The login page的页面输入127.0.0.1:5000/login?next=路由时，跳转到The login page的页面输入127.0.0.1:5000/user/Bob路由时，跳转到The profile page的页面 构建URL而非在模板中硬编码的理由： 反向构建通常比硬编码的描述性更好，它允许一次性修改URL，而不是到处边找边改 URL构建会转义特殊字符和Unicode数据 若应用不位于URL的根路径，url_for()会妥善处理这个问题 HTTP方法 HTTP方法告知服务器，客户端想对请求的页面做些什么，下面是常见的HTTP方法： GET 浏览器告知服务器：只获取页面上的信息并发给我。 HEAD 浏览器告诉服务器：欲获取信息，但是只关心消息头。应用应像处理GET请求一样来处理它，但不分发实际内容。在Flask中完全无需人工干预。 POST 浏览器告诉服务器：想在URL上发布新消息。并且服务器必须确保数据已存储且只存储一次。这是HTML表通常发送数据到服务器的方法。 PUT 类似于POST但服务器可能触发了存储过程多次，多次覆盖掉旧值。考虑到传输中连接可能会丢失，在这种情况下浏览器和服务器之间的系统可能安全地第二次接收请求，而不破坏其他东西。 DELETE 删除给定位置的信息。 OPTIONS 给客户端提供一个途径来弄清这个URL支持哪些HTTP方法。 HTTP有许多不同的访问URL方法。默认情况下，路由只回应GET请求，但是通过route()装饰器传递methods参数可以改变这个行为。例如： 123456@app.route('login',methods=['GET','POST'])def login(): if request.method=='POST': de_the_login() else: show_the_login_form() 若存在GET，会自动添加HEAD，无需干预，确保遵照HTTP协议处理HEAD请求。 静态文件 动态web应用也会需要静态文件，通常是CSS和JavaScript文件。理想状况下，已经配置好Web服务器来提供静态文件，但在开发中，Flask也可以做到。只要在包中或是，模块所在的目录中创建一个名为static的文件夹，在应用中使用/static即可访问。 给静态文件生成URL，使用特殊的static端，所生成的文件应该存储在static/style.css： 1url_for('static',filename='style.css') 模板渲染 Flask配备了Jinja2模板引擎来生成HTML，可以使用render_template()方法来渲染模板，将模板名和关键字参数传入模板的变量。例如： 12345from flask import render_template@app.route('/hello/')@app.route('hello/&lt;name&gt;')def hello(name=None): return render_template('hello.html',name=name) Flask会在templates文件夹里寻找模板，若应用是个模块，则该文件夹与模块通缉，它是个包，则该文件夹作为包的子目录： 123456789#应用是个模块/application.py/templates /hello.html#应用是个包 /application.py /__init__.py /templates /hello.html 自动转义功能在.html、.htm、.xml、xhtml扩展名的模板中是默认是开启的，若name包含HTML，它将会被自动转义。从字符串加载的模板禁用自动转义。若信任一个变量，并且知道它是安全的，可以用Markup类或|safe过滤器在模板中把它标记为安全的。 访问请求数据 对于Web应用，与客户端发送给服务端的数据交互至关重要。在Flask中由全局的request对象来提供这些信息。环境作用域保证了对象是全局的情况下，线程也是安全的。 环境局部变量 依赖于一段请求对象的代码，因没有请求对象无法正常运行，需要自行创建一个请求对象并把它绑定到环境中。做单元测试最简单的解决方案是：用test_request_context()环境管理器，结合with声明，绑定一个测试请求使之能进行交互。例如： 1234567from flask import request with app.test_request_context('/hello',method='POST'): assert request.path=='/hello' assert request.method=='POST'#或者传递整个WSGI环境给request_context()方法with app.request_context(environ): assert request.method=='POST' 请求对象 当前请求的HTTP方法可通过method属性来访问，通过request.form属性来访问表单数据。例如： 123456789@app.route('login',methods=['GET','POST'])def login(): error=None if request.method=='POST': if valid_login(request.form['username'],request.form['password']): return log_the_user_in(request.form['username']) else: error='Invalid username/password' return render_template('login.html',error=error) 当访问form属性中不存在的键时会抛出一个特殊的KeyError异常，可以想捕获标准的KeyError一样来捕获它，若对其不做处理，他会显示一个HTTP 400 Bad Request页面。 可以通过args属性来访问URL中 提交的参数，可以用get参数或捕获KeyError。： 1searchword=request.args.get('q','') 文件上传 上传文件需要先在HTML表单中设置`enctype=\"multipart/form-data\"属性。已上传的文件存储在内存或者是临时文件夹里，可以通过请求对象的files属性访问它们。每个上传的文件都会存储在这个字典里，可以通过save()方法把文件保存到服务器的文件系统上。例如： 123456from flask import request@app.route('/upload',methods=['GET','POST'])def upload_file(): if request.method=='POST': f=request.files['the file'] f.save(/var/www/uploads/uploaded_file.txt) 若想知道上传前文件在客户端的文件名是什么，可以访问filename属性，但由于这个值是可以伪造的，故不要信任这个值。若要把文件按客户端提供的文件名存储在服务器上，可以把它传递给Werkzrug提供的secure_filename()函数： 12345678from flask import requestfrom werkzeug import secure_filename@app.route('/upload',methods=['GET','POST'])def upload_file(): if request.method=='POST': f=request.files['the file'] f.save('/var/www/uploads/'+secure_filename(f.filename)) Cookies 可以通过cookies属性来访问Cookies，用响应对象的set_cookie方法来设置Cookies。请求对象的cookies属性是一个内容为客户端提交的所有Cookies的字典。 读取Cookies: 1234from flask import request@app.route('/')def index(): username=request.cookies.get('username') 存储Cookies： 123456from flask import request@app.route('/')def index(): resp=make_response(render_template(...)) resp.set_cookie('username','the username') return resp Cookie是设置在响应对象上的。由于通常视图函数只是返回字符串，之后Flask将字符串转换为响应对象。若要显式地转换，可以使用make_response()函数然后再进行修改。 重定向和错误 用redirect()函数把用户重定向到其他地方。用abort()函数放弃请求并返回错误代码。例如： 12345678910111213from flask import Flask,requestapp=Flask(__name__)@app.route('/')def index(): return redirect(url_for('login'))@app.route('/login') def login(): abort(401) this_is_never_executed()if __name__=='__main__': app.run() 默认情况下，错误代码会显示一个黑白的错误页面。可以用errorhandler()装饰器来定制错误页面： 12345from flask import render_template@app.errorhandler(404) def page_not_found(error): return render_template('page_not_found.html'),404#404即告诉Flask该页的错误代码是404，即没有找到，默认为200，即一切正常 关于响应 视图函数的返回值会被自动转换为一个响应对象。若返回值是一个字符串，它 被转换为该字符串为主体的、状态码为200 OK，MIME类型是text/html的响应对象。 Flask把返回值转换为响应对象的逻辑如下： 若返回的是一个合法的响应对象，它会从视图直接返回。 若返回的是一个字符串，响应对象会用字符串数据和默认参数创建。 若返回的是一个元组且元组中的元素可以提供额外的信息。这样的元组必须是(response,status,headers)的形式，且至少包含一个元素。status值会覆盖状态代码，headers可以是一个列表或字典，作为额外的消息标头值。 若上述条件都不满足，、Flask会假设返回值是一个合法的WSGI应用程序，并转换为一个请求对象。 若想再视图里操纵上述步骤结果的响应对象，可以使用make_response()函数。 12345678910#假设有以下视图@app.errorhandler(404) def not_found(error): return render_template('error.html'),404#只需要把返回值表达式传递给make_response()，获取结果对象并修改，然后再返回它@app.errorhandler(404) def not_found(error): resp=make_response(render_template('error.html'),404) resp.headers['X-Somthing']='A value' return resp 会话 除请求对象外，还有一个会话（session）对象。它允许在不同请求间存储特定用户的信息。他说在Cookies的基础上实现的，并且对Cookies进行密钥签名。这意味着用户可以查看Cookies内容但由于没有签名的密钥不能修改它。会话工作的例子如下： 123456789101112131415161718192021222324252627from flask import Flask,session,redirect,url_for,escape,requestapp=Flask(__name__)@app.route('/')def index(): if 'username' in session: return 'Logged in as %s' % escape(session['username']) return 'You are not logged in'@app.route('/login',methods=['GET','POST']) def login(): if request.method=='POST': session['username']=request.form['username'] return redirect(url_for('index')) return ''' &lt;form action=\"\" method=\"post\"&gt; &lt;p&gt;&lt;input type=text name=username&gt; &lt;p&gt;&lt;input type=submit value=Login&gt; &lt;/form&gt; '''@app.route('/logout')def logout(): session.pop('username',None) return redirect(url_for('index'))app.secret_kry='A0Zr98j/3yX R~XHH!jmN]LWX/,?R' if __name__=='__main__': app.run() 生成强密钥： 1234import os print(os.urandom(24))#运行结果如下b'\\x9b\\xc9@\\x9bN]\\xd9]H\\xd6,\\xfam\\x9c\\x90\\xddu\\x19^\\x14COG\\x93' 使用基于cookie的会话需注意：Flask会将放进会话对象的值序列化值Cookies。若发现某些值在请求之间没有持久存在，而Cookies已经启用且没有明显的错误信息。此时应检查页面响应中Cookies的大小，并与Web浏览器所支持的大小对比。 消息闪现 Flask提供了消息闪现系统，可以简单地给用户返回。消息闪现系统通常会在请求结束时记录信息，并在下一个（且仅在下一个）请求中访问记录的信息。展现这些信息通常要结果模板布局。使用flash()方法可以闪现一条消息，在模板中也可以使用。 日志记录 Flask预置了日志系统，附带的logger是一个标准日志类Logger： 123app.logger.debug('A value for debugging')app.logger.warning('A warning occurred (%d apples)',42)app.logger.error('An error occurred') 整合WSGI中间件 若想给应用添加WSGI中间件，可以封装内部WSGI应用。如想用Werkzrug包中的某个中间件来应付lighttpd中的bugs： 12from werkzeug.contrib.fixers import LighttpdCGIRootFixapp.wsgi_app=LighttpdCGIRootFix(app.wsgi_app)","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Web框架","slug":"Web框架","permalink":"http://tangmenjue.top/categories/Web%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Flask Web","slug":"Flask-Web","permalink":"http://tangmenjue.top/tags/Flask-Web/"},{"name":"后端","slug":"后端","permalink":"http://tangmenjue.top/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Web框架","slug":"Web框架","permalink":"http://tangmenjue.top/tags/Web%E6%A1%86%E6%9E%B6/"}]},{"title":"PgSQL数据库学习笔记（三）","slug":"PgSQL数据库学习笔记（三）","date":"2022-10-17T08:08:18.000Z","updated":"2022-11-10T15:48:04.647Z","comments":true,"path":"2022/10/17/PgSQL数据库学习笔记（三）/","link":"","permalink":"http://tangmenjue.top/2022/10/17/PgSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"PostgreSQL命令 由于Pgsql数据库的命令在运行时会自动转换为小写英文字母，故命令语句也可以用小写字母编写。 使用pgAdmin工具创建数据库 右键点击batabases，选择弹出的数据库的菜单。 pgAdmin工具界面语言设成中文 左键点击File，弹出的Preferences。 选择左下角的User language，点击右上角的箭头，选择Chinese(Simplified)，点击Save保存。在弹出的Refresh required窗口中点击Refresh保存即可。 pgAdmin创建SQL脚本 在已经创建好的数据库名称中右键点击，选择CREATE 脚本，即可创建SQL脚本。可以在SQL脚本里编写PgSQL语句。 注意：SQL脚本中尽量不要直接点击运行代码。这样在创建过一次表后，直接点击运行代码时会再次运行建表的语句，会报表格已存在的错。通常是选中需要运行的代码块后再点击执行按钮。数据库只运行选中的代码，这样不会重复执行先前写好的代码，若没有选中任何代码，则默认为选中全部。 PgSQL创建数据库 123456789101112-- create database 数据库名-- with-- 关于数据库的说明create database postgres with owner=postgres -- 该数据库的拥有者 encoding='UTF8' -- 数据库中使用的字符集编码 lc_collate='Chinese (Simplified)_China.936' -- 在数据库中使用的排序规则顺序 lc_ctype='Chinese (Simplified)_China.936'-- 在数据库中使用的字符分类 tablespace=pg_default-- 与数据库相关联的表空间名称 connection limit=-1 -- 数据库允许多少并发连接，-1表示没有限制 is_template=false; -- 若为真，则具有CREATEDB特权的用户都可以从 这个数据库克隆。如果为假（默认），则只有超级用户或者该数据库的拥有者 可以克隆它。 PgSQL的CRUD语句 create建表 使用create语句创建表： 123456789-- create table 表名( -- 属性名 数据类型 条件约束 -- )create table rpt_tutorial( id serial primary key not null,-- 建立自增id name text not null,-- 建立文本型属性 age int not null,-- 建立整数型属性 datetime date not null-- 建立日期型属性); create创建复合类型 使用create语句创建复合类型： 12-- create type 复合类型名 as （类型名 数据类型)create type profession as (profession char(50)); 创建复合类型后，可实现在表中自定义字段名称，其格式为：属性名 复合类型名 条件约束 insert插入数据 使用insert语句查询数据： 12insert into rpt_tutorial(name,age,datetime,prof)values('Zhangsan',30,'2022-10-14','(teacher)'); read读数据 使用select语句查询数据： 123-- select 属性名 form 表名 where 条件约束select * from rpt_tutorial;select name from rpt_tutorial where age&gt;=30; update更新数据 使用update...set语句更新数据： 12-- update 表名 set 更新的属性名=更新的数值 where 条件约束更新的属性名=原数值update rpt_tutorial set datetime='2022-10-17' where datetime='2022-10-14'; delete&amp;drop删除数据 使用delete或drop语句删除数据： 12345678910-- 删除表中的记录-- delete from 表名 delete from rpt_tutorial-- 删除表-- delete table 表名 drop table rpt_tutorial-- 删除复合类型drop type profession-- 重置自增id为1，删除所有数据truncate table rpt_tutorial restart identity; 使用python进行PgSQL数据库连接 Psycopy是针对python的Postgres数据库的适配模块，安装psycopg2可以整合python和Postgres。可在cmd中输入命令进行安装： 1pip install psycopg2 导入psycopg2模块，并进行sql操作，其语句格式如下。 123456789conn=psycopg2.connect(database=\"数据库名\",user=\"数据库用户名\",password=\"数据库密码\",host=\"127.0.0.1\",port=\"5432\")#127.0.0.1为默认的本地ip地址，port为数据库默认地址print(\"Opened database successfully\")cur=conn.cursor()#创建一个cursor对象cur.execute('''sql操作语句);''')conn.commit()cur.close()conn.close() 使用python将csv文本的数据导入导出至pqsql 方法一： 使用psycopg2模块中的copy语句操作文本，由于csv文件默认以逗号分隔单元格，故导入导出时要注意加上或减去逗号： 123456789101112131415161718192021#读csv文件#resourcefilenames为csv文件地址#targettablename为要导入的数据库表名with open(resourcefilenames,'r',encoding='utf-8') as f: next(f) cur.copy_from(f,targettablename,sep=',',) #写文本#targetfilenames为导出的csv文件名write_head=Truewith open(targetfilenames,'w',encoding='utf-8') as f: columns=['id','name','age','datetime'] if write_head: s='' for k in columns: s+=k+',' s=s[:-1] f.write(s+'\\n') write_head=False cur.copy_to(f,targettablename,sep=',',columns=columns) print(\"Export csv successfully\") 方法二： 运用xlrd、xlwt模块导入导出数据： 1234567891011121314151617181920212223242526272829303132333435363738394041#导入数据import xlrdworkbook = xlrd.open_workbook(filename='C:/文件名')#仅支持xls文件# 需要先指定sheet工作表table = workbook.sheet_by_name(sheet_name='sheet表名')# 获取行数rows = table.nrows# 获取列数cols = table.ncols# 循环获取每行的数据for row in range(rows): for col in range(cols): value = table.cell_value(row, col) print('第&#123;&#125;行&#123;&#125;列的数据为：&#123;&#125;'.format(row, col, value))#导出数据import xlwt# 创建一个workbook并设置编码workbook = xlwt.Workbook(encoding = 'utf-8')# 添加sheetworksheet = workbook.add_sheet('text2')# 写入excel, 参数对应 行, 列, 值for row in range(rows): for col in range(cols): value = table.cell_value(row, col) worksheet.write(row, col, value)workbook.save('text2.csv') #导出数据方法2def outdata(data,file,sheetname): # work_book=xlrd.open_workbook(filename=file) work_book=xlwt.Workbook(encoding='utf-8') sheet=work_book.add_sheet(sheetname) sheet.write(0,0,'id') sheet.write(0,1,'name') sheet.write(0,2,'age') sheet.write(0,3,'datetime') for i in range(len(data)): for j in range(len(data[i])): sheet.write(i+1,j,'%s' % data[i][j]) work_book.save(file) print(\"Data output successfully\") outdata(rows,targetfilenames,'test') 方法三： 运用csv模块导入导出数据 123456789101112131415161718192021#导入数据import csvfrom re import Adef readfile(): f = open('文件名', 'r') csv_reader = csv.reader(f) a=[] for row_data in csv_reader: a.append(row_data) print(a) f.close() return a#导出数据 a=readfile()csvFile3 = open('新文件名','w',encoding='utf-8',newline='')writer2 = csv.DictWriter(csvFile3,fieldnames=['属性名'])key=a[0]for t in range(len(key)): writer2 = csv.writer(csvFile3) writer2.writerow(a[t])csvFile3.close()","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"http://tangmenjue.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"PgSQL","slug":"PgSQL","permalink":"http://tangmenjue.top/tags/PgSQL/"},{"name":"数据库","slug":"数据库","permalink":"http://tangmenjue.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"PgSQL数据库学习笔记（二）","slug":"PgSQL数据库学习笔记（二）","date":"2022-10-14T08:08:18.000Z","updated":"2022-11-10T15:48:11.663Z","comments":true,"path":"2022/10/14/PgSQL数据库学习笔记（二）/","link":"","permalink":"http://tangmenjue.top/2022/10/14/PgSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"PostgreSQL数据类型 数值类型 数值类型由 2 字节、4 字节或 8 字节的整数以及 4 字节或 8 字节的浮点数和可选精度的十进制数组成。 下表列出了PgSQL所支持的数值类型： 名字 存储长度 描述 范围 smallint 2 字节 小范围整数 -32768 到 +32767 integer 4 字节 常用的整数 -2147483648 到 +2147483647 bigint 8 字节 大范围整数 -9223372036854775808 到 +9223372036854775807 decimal 可变长 用户指定的精度，精确 小数点前 131072 位；小数点后 16383 位 numeric 可变长 用户指定的精度，精确 小数点前 131072 位；小数点后 16383 位 real 4 字节 可变精度，不精确 6 位十进制数字精度 double precision 8 字节 可变精度，不精确 15 位十进制数字精度 smallserial 2 字节 自增的小范围整数 1 到 32767 serial 4 字节 自增整数 1 到 2147483647 bigserial 8 字节 自增的大范围整数 1 到 9223372036854775807 货币类型 money类型存储带有固定小数精度的货币金额。numeric、int和bigint类型的值可以转换为money。 名字 存储容量 描述 范围 money 8 字节 货币金额 -92233720368547758.08 到 +92233720368547758.07 字符类型 下表列出了PgSQL所支持的字符类型： 名字 描述 character varying(n),varchar(n) 变长，有长度限制 character(n), char(n) f定长,不足补空白 text 变长，无长度限制 日期/时间类型 下表列出了PgSQL所支持的日期和时间类型： 名字 存储空间 描述 最低值 最高值 分辨率 timestamp [ ( p ) ] [ without time zone ] 8 字节 日期和时间(无时区) 4713 BC 294276 AD 1 毫秒 / 14 位 timestamp [ ( p ) ] with time zone 8 字节 日期和时间，有时区 4713 BC 294276 AD 1 毫秒 / 14 位 date 4 字节 只用于日期 4713 BC 5874897 AD 1 天 time [ ( p ) ] [ without time zone ] 8 字节 只用于一日内时间 00:00:00 24:00:00 1 毫秒 / 14 位 time [ ( p ) ] with time zone 12 字节 只用于一日内时间，带时区 00:00:00+1459 24:00:00-1459 1 毫秒 / 14 位 interval [ fields ] [ ( p ) ] 12 字节 时间间隔 -178000000 年 178000000 年 1 毫秒 / 14 位 布尔类型 boolean有true或false两个状态，第三种未知状态（unknown）用NULL表示。 名称 存储格式 描述 boolean 1 字节 true/false 枚举类型 PgSQL种的枚举类型类似于C语言中的enum类型，包含静态和值的有序集合的数据类型。与其他类型不同的是枚举类型需要使用create type命令创建。枚举类型一旦创建，便可用于变和函数定义。 1create type mood as enum('sad','ok','happy') 几何类型 几何类型表示二维的平面物体。 名字 存储空间 说明 表现形式 point 16 字节 平面中的点 (x,y) line 32 字节 (无穷)直线(未完全实现) ( ( x1,y1 ) , ( x2,y2 ) ) lseg 32 字节 (有限)线段 ( ( x1,y1 ), ( x2,y2 ) ) box 32 字节 矩形 ( ( x1,y1 ), ( x2,y2 ) ) path 16+16n 字节 闭合路径(与多边形类似) ( ( x1,y1 ), ... ) path 16+16n 字节 开放路径 [ ( x1,y1 ) , ... ] polygon 40+16n 字节 多边形(与闭合路径相似) ( ( x1,y1 ) , ... ) circle 24 字节 圆 &lt; ( x,y ) , r &gt; (圆心和半径) 网络地址类型 PgSQL提供用于存储IPv4、IPv6、MAC地址的数据类型。在对inet或cidr数据类型进行排序时，IPv4地址总是排在IPv6前面，包括那些封装或是映射在IPv6地址里的IPv4地址。 名字 存储空间 描述 cidr 7 或 19 字节 IPv4 或 IPv6 网络 inet 7 或 19 字节 IPv4 或 IPv6 主机和网络 macaddr 6 字节 MAC 地址 位串类型 位串是一串1和0的字符串，可以用于存储和直观化位掩码。 名字 描述 bit(n) 必须准确匹配长度n(n位正整数) bit var ying(n) 最长n的变长类型 文本搜索类型 全文检索即通过自然语言文档的集合来找到那些匹配一个查询的检索。 名字 描述 tsvector 其值是一个无重复值的lexemes排序列表，即一些同一个词的不同变种的标准化 tsquery 存储用于检索的词汇，且使用布尔操作符&amp;(AND),|(OR)和!(NOT)来组合它们，括号用来强调操作符的分组。 UUID类型 uuid 数据类型用来存储 RFC 4122，ISO/IEF 9834-8:2005 以及相关标准定义的通用唯一标识符（UUID）。在一些系统里也叫GUID。这个标识符是一个由算法产生的 128 位标识符，使它不可能在已知使用相同算法的模块中和其他方式产生的标识符相同。 其用小写的十六进制数字序列表示。 XML类型 要使用这个数据类型，编译时必须使用configure --with -libxml。 xmlvalue IS DOCUMENT 表达式可以用来判断一个特定的 xml 值是一个完整的文件还是内容片段。 使用xmlparse来从字符数据产生xml类型的值： 12XMLPARSE (DOCUMENT '&lt;?xml version=\"1.0\"?&gt;&lt;book&gt;&lt;title&gt;Manual&lt;/title&gt;&lt;chapter&gt;...&lt;/chapter&gt;&lt;/book&gt;')XMLPARSE (CONTENT 'abc&lt;foo&gt;bar&lt;/foo&gt;&lt;bar&gt;foo&lt;/bar&gt;') json类型 json 数据类型可以用来存储 JSON（JavaScript Object Notation）数据， 这样的数据也可以存储为 text，但是 json 数据类型更有利于检查每个存储的数值是可用的 JSON 值。 此外还有相关的函数来处理 json 数据： 实例 实例结果 array_to_json('{ {1,5},{99,100} }'::int[]) [ [1,5],[99,100] ] row_to_json(row(1,'foo')) {\"f1\":1,\"f2\":\"foo\"} 数组类型 数组类型可以是任何基本类型或用户定义类型，枚举类型或复合类型。 声明数组： 123456CREATE TABLE sal_emp ( name text, pay_by_quarter integer[], schedule text[][]， pay_by_quarter integer ARRAY[4]); 插入值： 插入值使用花括号 {}，元素在 {} 使用逗号隔开： 1234INSERT INTO sal_emp VALUES ('Bill', '&#123;10000, 10000, 10000, 10000&#125;', '&#123; &#123; \"meeting\", \"lunch\" &#125;, &#123; \"training\", \"presentation\" &#125; &#125;'); 访问数组： 数组的下标数字是写在方括号里的。 1SELECT name FROM sal_emp WHERE pay_by_quarter[1] &lt;&gt; pay_by_quarter[2]; 修改数组： 1234UPDATE sal_emp SET pay_by_quarter = '&#123;25000,25000,27000,27000&#125;' WHERE name = 'Carol';UPDATE sal_emp SET pay_by_quarter = ARRAY[25000,25000,27000,27000] WHERE name = 'Carol'; 数组中检索： 要搜索一个数组中的数值，就必须检查该数组的每一个值。 1234567SELECT * FROM sal_emp WHERE 10000 = ALL (pay_by_quarter);SELECT * FROM (SELECT pay_by_quarter, generate_subscripts(pay_by_quarter, 1) AS s FROM sal_emp) AS foo WHERE pay_by_quarter[s] = 10000; 复合类型 复合类型表示一行或一条记录的结构，它实际上只是一个字段名和它们的数据类型的列表。复合类型可以实现建表时可以自定义字段。 声明复合类型的语法类似于create table，只是这里只可以声明字段名字和类型，定义类型后就可以用它来创建表： 123456789101112131415CREATE TYPE complex AS ( r double precision, i double precision);CREATE TYPE inventory_item AS ( name text, supplier_id integer, price numeric);CREATE TABLE on_hand ( item inventory_item, count integer);INSERT INTO on_hand VALUES (ROW('fuzzy dice', 42, 1.99), 1000); 复合类型输入 要用文本常量属性复合类型值，在圆括号里包围字段值并用逗号分隔他们。可以在任何字段周围放上双引号，若值本身包含逗号或圆括号，则必须要用双引号括起来。 复合类型常量的一般格式如下： 12'( value1 , value2 , ... )''(\"fuzzy dice\",42,1.99)' 访问复合类型 若要访问复合类型字段的一个域，则必须要用圆括号把域的名字括起来： 12SELECT (item).name FROM on_hand WHERE (item).price &gt; 9.99;SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price &gt; 9.99;#需要用到表名时的写法 范围类型 范围类型代表这某一元素类型在一定范围内的值。 PostgreSQL 内置的范围类型有： integer的范围：int4range bigint的范围：int8range numeric的范围：numrange timestamp without time zone的范围：tsrange timestamp with time zone的范围：tstzrange date的范围：daterange 此外也可以定义自己的范围类型： 123456789101112131415161718CREATE TABLE reservation (room int, during tsrange);INSERT INTO reservation VALUES (1108, '[2010-01-01 14:30, 2010-01-01 15:30)');-- 包含SELECT int4range(10, 20) @&gt; 3;-- 重叠SELECT numrange(11.1, 22.2) &amp;&amp; numrange(20.0, 30.0);-- 提取上边界SELECT upper(int8range(15, 25));-- 计算交叉SELECT int4range(10, 20) * int4range(15, 25);-- 范围是否为空SELECT isempty(numrange(1, 5)); 范围值的输入必须遵循下面的格式：()、(]、[)、[]和空。圆括号或者方括号显示下边界和上边界是不包含的还是包含的。注意最后的格式是 空，代表着一个空的范围（一个不含有值的范围）。 1234567891011-- 包括3，不包括7，并且包括二者之间的所有点SELECT '[3,7)'::int4range;-- 不包括3和7，但是包括二者之间所有点SELECT '(3,7)'::int4range;-- 只包括单一值4SELECT '[4,4]'::int4range;-- 不包括点（被标准化为‘空’）SELECT '[4,4)'::int4range; 对象标识符类型 PgSQL 在内部使用对象标识符(OID)作为各种系统表的主键。 名字 引用 描述 数值例子 oid 任意 数字化的对象标识符 564182 regproc pg_proc 函数名字 sum regprocedure pg_proc 带参数类型的函数 sum(int4) regoper pg_operator 操作符名 + regoperator pg_operator 带参数类型的操作符 *(integer,integer) 或 -(NONE,integer) regclass pg_class 关系名 pg_type regtype pg_type 数据类型名 integer regconfig pg_ts_config 文本搜索配置 english regdictionary pg_ts_dict 文本搜索字典 simple 伪类型 PgSQL类型系统包含一系列特殊用途的条目， 它们按照类别来说叫做伪类型。伪类型不能作为字段的数据类型， 但是它可以用于声明一个函数的参数或者结果类型。 伪类型在一个函数不只是简单地接受并返回某种SQL 数据类型的情况下很有用。 下表列出了所有的伪类型： 名字 描述 any 表示一个函数接受任何输入数据类型。 anyelement 表示一个函数接受任何数据类型。 anyarray 表示一个函数接受任意数组数据类型。 anynonarray 表示一个函数接受任意非数组数据类型。 anyenum 表示一个函数接受任意枚举数据类型。 anyrange 表示一个函数接受任意范围数据类型。 cstring 表示一个函数接受或者返回一个空结尾的 C 字符串。 internal 表示一个函数接受或者返回一种服务器内部的数据类型。 language_handler 一个过程语言调用处理器声明为返回language_handler。 fdw_handler 一个外部数据封装器声明为返回fdw_handler。 record 标识一个函数返回一个未声明的行类型。 trigger 一个触发器函数声明为返回trigger。 void 表示一个函数不返回数值。 opaque 一个已经过时的类型，以前用于所有上面这些用途。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"http://tangmenjue.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"PgSQL","slug":"PgSQL","permalink":"http://tangmenjue.top/tags/PgSQL/"},{"name":"数据库","slug":"数据库","permalink":"http://tangmenjue.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"PgSQL数据库学习笔记（一）","slug":"PgSQL数据库学习笔记（一）","date":"2022-10-14T03:32:49.000Z","updated":"2022-11-10T15:47:53.532Z","comments":true,"path":"2022/10/14/PgSQL数据库学习笔记（一）/","link":"","permalink":"http://tangmenjue.top/2022/10/14/PgSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"写在前头 本笔记前两篇主要列出PgSQL的常用命令和数据类型。具体的实操命令从第三篇开始讲解。 Windows上安装PostgreSQL 使用EnterpriseDB来下载安装，根据安装指引安装即可。下载地址：Download PostgreSQL (enterprisedb.com) PostgreSQL语法 默认情况下PostgreSQL安装完成后，自带了个命令行工具SQL Shell(psql)。 进入命令行工具，可以使用\\help 命令来查看各个命令的语法。 若要查看具体命令的用法，可到PostgreSQL的API文档中查看。PostgreSQL 14.3 中文 (runebook.dev) PostgreSQL语句 常用语句 在表和文件之间拷贝数据：copy 具体语句用法如下： 12-- 使用竖线（|）作为域定界符把一个表复制到客户端copy country to stdout (delimiter '|'); 定义访问权限：grant 具体语句用法如下： 12-- 把表films上的插入特权授予给所有用户grant insert on films to public; 从一个查询的结果中定义一个新表：select into 具体语句用法如下： 12-- 创建一个只由来自films的最近项构成的 新表films_recentselect * into films_recent from films where date_prod &gt;= '2002-01-01'; 清空一个或一组表：truncate 具体语句用法如下： 12-- 清除 COMPANY 表w3cschooldb=# truncate table company; 修改运行时参数：set 具体语句用法如下： 12345exec sql set descriptor indesc count = 1;exec sql set descriptor indesc value 1 data = 2;exec sql set descriptor indesc value 1 data = :val1;exec sql set descriptor indesc value 2 indicator = :val1, data = 'some string';exec sql set descriptor indesc value 2 indicator = :val2null, data = :val2; 把一个运行时参数值恢复为默认值：reset 具体语句用法如下： 12-- 把timezone配置变量设置为默认值reset timezone; 显示运行时的参数值：show 具体语句用法如下： 123-- 显示参数DateStyle的当前设置show datestyle; datestyle 更新一个表中的行：update 具体语句用法如下： 12-- 把表films的列kind 中的单词Drama改成Dramaticupdate films set kind = 'dramatic' where kind = 'drama'; 创建一个准备好的查询：prepare 具体语句用法如下： 12-- 提交由事务标识符foobar标识的事务commit prepared 'foobar'; 执行一个准备好的查询：execute 具体语句用法如下： 1execute query(100, 200); 显示一个语句的执行规则：explain 具体语句用法如下： 1234-- 有一个具有单个integer列和 10000 行的表，要显示在其上的一个简单查询的计划explain select * from foo; query plan 在表中创建新行：insert 具体语句用法如下： 123-- 向films中插入一行insert into films values ('ua502', 'bananas', 105, '1971-07-13', 'comedy', '82 minutes'); 重建索引：reindex 具体语句用法如下： 1234-- 重建单个索引reindex index my_index;-- 重建表my_table上的所有索引reindex table my_table; 收集与数据库有关的统计：analyze 具体语句用法如下： 1analyze; 生成一个通知：notify 具体语句用法如下： 12345678910-- 从psql配置和执行一个监听/通知序列listen virtual;notify virtual;asynchronous notification \"virtual\" received from server process with pid 8448.notify virtual, 'this is the payload';asynchronous notification \"virtual\" with payload \"this is the payload\" received from server process with pid 8448.listen foo;select pg_notify('fo' || 'o', 'pay' || 'load');asynchronous notification \"foo\" with payload \"payload\" received from server process with pid 14728. 监听一个通知：listen 具体语句用法如下： 1234-- 从psql中配置并执行一个监听/通知序列listen virtual;notify virtual;asynchronous notification \"virtual\" received from server process with pid 8448. 停止监听通知信息：unlisten 具体语句用法如下： 12345678-- 做一次注册listen virtual;notify virtual;asynchronous notification \"virtual\" received from server process with pid 8448.-- 一旦执行了UNLISTEN，进一步的NOTIFY 消息将被忽略unlisten virtual;notify virtual;-- no notify event is received 锁定一个表：lock 具体语句用法如下： 12-- 将数据库中的 COMPANY 表锁定为 ACCESS EXCLUSIVE 模式lock table company1 in access exclusive mode; 根据一个索引聚簇一个表：cluster 具体语句用法如下： 12-- 基于索引employees_ind聚簇表 employeescluster employees using employees_ind; 定义或者改变一个对象的注释：comment 具体语句用法如下： 12-- 为表mytable附加一段注释comment on table mytable is 'this is my table.'; 垃圾收集以及可选地分析一个数据库：vacuum 具体语句用法如下： 12-- 清理单一表onek，为优化器分析它并且打印出详细的清理活动报告vacuum (verbose, analyze) onek; 为当前会话设置会话用户标识符和当前用户标识符：set session authorization 具体语句用法如下： 1set session authorization 'paul'; 删除访问权限：revoke 具体语句用法如下： 12-- 从 public 收回表films上的插入特权revoke insert on films from public; 事务相关命令 开始一个事务：begin 具体语句用法如下： 1begin; 提交当前事务：commit 具体语句用法如下： 12-- 要提交当前事务并且让所有更改持久化commit; 提交当前事务：end 具体语句用法如下： 12-- 提交当前事务并且让所有更改持久化end; 强制一个事务日志检查点：checkpoint 具体语句用法如下： 1checkpoint; 中止当前事务：rollback 回滚当前事务并且导致该事务所作的所有更新都被抛弃。具体语句用法如下： 12-- 中止所有更改rollback; 中止当前事务：abort 回滚当前事务并且导致由该事务所作的所有更新被丢弃。具体语句用法如下： 1abort; 开始一个事务块：set transaction 具体语句用法如下： 1234-- 要用一个已经存在的事务的同一快照开始一个新事务，首先要从该现有 事务导出快照。这将会返回快照标识符begin transaction isolation level repeatable read;select pg_export_snapshot(); pg_export_snapshot 开始一个事务块：start transaction 具体语句用法如下： 12-- 中止所有更改rollback; 在当前事务里定义一个新的保存点：savepoint 具体语句用法如下： 12345678-- 建立一个保存点并且后来撤销在它建立之后执行的所有命令的效果begin; insert into table1 values (1); savepoint my_savepoint; insert into table1 values (2); rollback to savepoint my_savepoint; insert into table1 values (3);commit; 回滚到一个保存点：rollback to savepoint 具体语句用法如下： 12-- 撤销在my_savepoint建立后执行的命令的效果rollback to savepoint my_savepoint; 删除一个前面定义的保存点：release savepoint 具体语句用法如下： 1234567-- 建立并且销毁一个保存点begin; insert into table1 values (3); savepoint my_savepoint; insert into table1 values (4); release savepoint my_savepoint;commit; 游标相关命令 定义一个游标：declare 具体语句用法如下： 12-- 声明一个游标declare liahona cursor for select * from films; 定位一个游标：move 具体语句用法如下： 123456BEGIN WORK;DECLARE liahona CURSOR FOR SELECT * FROM films;-- 跳过前 5 行：MOVE FORWARD 5 IN liahona;MOVE 5 用游标从查询中抓取行：fetch 具体语句用法如下： 12-- 在游标 liahona 中取出前 5 行：FETCH FORWARD 5 FROM liahona; 关闭游标：close 具体语句用法如下： 12-- 关闭游标liahonaclose liahona; alter修改命令 修改一个聚集函数的定义：alter aggregate 具体语句用法如下： 1alter aggregate myavg(integer) rename to my_average; 修改一个排序规则定义：alter collation 具体语句用法如下： 12-- 把排序规则de_DE重命名为germanalter collation \"de_de\" rename to german; 修改一个编码转换的定义：alter conversion 具体语句用法如下： 12-- 把转换iso_8859_1_to_utf8的拥有者改成joealter conversion iso_8859_1_to_utf8 owner to joe; 修改一个数据库：alter database 具体语句用法如下： 12-- 在数据库test中默认禁用索引扫描alter database test set enable_indexscan to off; 定义默认的访问权限：alter default privileges 具体语句用法如下： 123-- 在模式myschema中创建的所有表（和视图）授予 SELECT 特权，并且也允许角色webuser向它们之中 INSERT 数据alter default privileges in schema myschema grant select on tables to public;alter default privileges in schema myschema grant insert on tables to webuser; 修改一个域的定义：alter domain 具体语句用法如下： 12-- 把一个NOT NULL约束加到一个域alter domain zipcode set not null; 修改一个函数的定义：alter function 具体语句用法如下： 12-- 把用于类型integer的函数sqrt 重命名为square_rootalter function sqrt(integer) rename to square_root; 修改角色名称或成员关系：alter group 具体语句用法如下： 1234-- 向一个组增加用户alter group staff add user karl, john;-- 从一个组移除一个用户alter group workers drop user beth; 修改一个索引的定义：alter index 具体语句用法如下： 12-- 把一个索引移动到一个不同的表空间alter index distributors set tablespace fasttablespace; 修改一个操作符的定义：alter operator 具体语句用法如下： 12-- 更改类型text的一个自定义操作符a @@ b 的拥有者alter operator @@ (text, text) owner to joe; 修改一个模式的定义：alter schema 具体语句用法如下： 12-- 把一个索引移动到一个不同的表空间alter index distributors set tablespace fasttablespace; 修改一个数据库角色：alter role 具体语句用法如下： 12-- 更改一个角色alter role davide with password 'hu8jmn3'; 修改一个序列生成器的定义：alter sequence 具体语句用法如下： 12-- 在 105 重启一个被称为serial的序列alter sequence serial restart with 105; 修改表的定义：alter table 具体语句用法如下： 12-- 向一个表增加一个类型为varchar的列alter table distributors add column address varchar(30); 修改一个表空间：alter tablespace 具体语句用法如下： 12-- 将表空间index_space重命名为fast_raidalter tablespace index_space rename to fast_raid; 修改一个事件触发器的定义：alter event trigger 具体语句用法如下： 12-- 重命名一个现有的触发器alter event trigger name rename to new_name 修改一个类型的定义：alter type 具体语句用法如下： 12-- 重命名一个数据类型alter type electronic_mail rename to email; create定义命令 定义一个新的约束触发器：constraint trigger 具体语句用法如下： 12345-- 只要表accounts的一行即将要被更新时会执行函数check_account_updatecreate trigger check_update before update on accounts for each row execute function check_account_update(); 定义一个新的编码转换：create conversion 具体语句用法如下： 12-- 使用myfunc创建一个从编码UTF8到 LATIN1的转换create conversion myconv for 'utf8' to 'latin1' from myfunc; 创建一个新数据库：create database 具体语句用法如下： 12-- 创建一个新数据库create database lusiadas; 定义一个新域：create domain 具体语句用法如下： 123456789101112131415-- 创建us_postal_code数据类型并且把它用在 一个表定义中。一个正则表达式测试被用来验证值是否看起来像一个 合法的 US 邮政编码create domain us_postal_code as textcheck( value ~ '^\\d&#123;5&#125;$'or value ~ '^\\d&#123;5&#125;-\\d&#123;4&#125;$');create table us_snail_addy ( address_id serial primary key, street1 text not null, street2 text, street3 text, city text not null, postal us_postal_code not null); 定义一个新函数：create function 具体语句用法如下： 12345create function add(integer, integer) returns integer as 'select $1 + $2;' language sql immutable returns null on null input; 定义一个新索引：create index 具体语句用法如下： 12-- 在表films中的列title上创建一个 B-树索引create unique index title_idx on films (title); 定义一种新的过程语言：create language 具体语句用法如下： 123456-- 创建新的过程语言的最小顺序create function plsample_call_handler() returns language_handler as '$libdir/plsample' language c;create language plsample handler plsample_call_handler; 定义一个新的操作符：create operator 具体语句用法如下： 1234567891011-- 为数据类型box定义一种新的操作符--面积相等create operator === ( leftarg = box, rightarg = box, function = area_equal_function, commutator = ===, negator = !==, restrict = area_restriction_function, join = area_join_function, hashes, merges); 定义一个新的操作符表：create operator class 具体语句用法如下： 123456789101112131415-- 为数据类型_int4（int4数组） 定义了一个 GiST 索引操作符create operator class gist__int_ops default for type _int4 using gist as operator 3 &amp;&amp;, operator 6 = (anyarray, anyarray), operator 7 @&gt;, operator 8 &lt;@, operator 20 @@ (_int4, query_int), function 1 g_int_consistent (internal, _int4, smallint, oid, internal), function 2 g_int_union (internal, internal), function 3 g_int_compress (internal), function 4 g_int_decompress (internal), function 5 g_int_penalty (internal, internal, internal), function 6 g_int_picksplit (internal, internal), function 7 g_int_same (_int4, _int4, internal); 定义一个新的数据库角色：create role 具体语句用法如下： 12-- 创建一个有口令的角色create user davide with password 'jw8s0f4'; 定义一个新重写规则：create rule 具体语句用法如下： 1create rule notify_me as on update to mytable do also notify mytable; 定义一个新模式：create schema 具体语句用法如下： 1234-- 创建一个模式create schema myschema;-- 为用户joe创建一个模式，该模式也将被命名为 joecreate schema authorization joe; 定义一个新的外部服务器：create server 具体语句用法如下： 12-- 创建使用外部数据包装器postgres_fdw 的服务器myservercreate server myserver foreign data wrapper postgres_fdw options (host 'foo', dbname 'foodb', port '5432'); 定义一个新序列发生器：create sequence 具体语句用法如下： 12-- 创建一个称作serial的上升序列，从 101 开始create sequence serial start 101; 定义一个新表：create table 具体语句用法如下： 123456789-- 创建表distributorscreate table distributors ( did integer primary key generated by default as identity, name varchar(40) not null check (name ''));-- 创建有一个二维数组的表create table array_int ( vector int[][]); 从一条查询的结果中创建一个新表：create table as 具体语句用法如下： 123-- 创建一个新表films_recent，它只由表 films中最近的项组成create table films_recent as select * from films where date_prod &gt;= '2002-01-01'; 定义一个新的表空间：create tablespace 具体语句用法如下： 123456789-- 要在文件系统位置/data/dbs创建表空间dbspace，请首先使用操作系统工具创建目录并设置正确的所有权mkdir /data/dbschown postgres:postgres /data/dbs-- 然后在内部发出表空间创建命令 PostgreSQL--create tablespace dbspace location '/data/dbs';-- 要创建由不同数据库用户拥有的表空间create tablespace indexspace owner genevieve location '/data/indexes'; 定义一个新的触发器：create trigger 具体语句用法如下： 123456789101112-- 禁止执行任何DDL命令create or replace function abort_any_command() returns event_trigger language plpgsql as $$begin raise exception 'command % is disabled', tg_tag;end;$$;create event trigger abort_ddl on ddl_command_start execute function abort_any_command(); 定义一个新的数据类型：create type 具体语句用法如下： 12345678-- 创建一个枚举类型并且将其用在一个表定义中create type bug_status as enum ('new', 'open', 'closed');create table bug ( id serial, description text, status bug_status); 定义一个视图：create view 具体语句用法如下： 12345-- 创建一个由所有喜剧电影组成的视图create view comedies as select * from films where kind = 'comedy'; drop删除命令 删除一个表中的行：delete 具体语句用法如下： 12-- 删除所有电影，但音乐剧除外delete from films where kind 'musical'; 删除一个用户定义的聚类函数：drop aggregate 具体语句用法如下： 12-- 为类型integer移除聚集函数myavgdrop aggregate myavg(integer); 删除一个用户定义的类型转换：drop cast 具体语句用法如下： 12-- 移除从类型text到类型int的类型drop cast (text as int); 删除一个用户定义的编码转换：drop conversion 具体语句用法如下： 12-- 删除名为myname的转换drop conversion myname; 删除一个数据库：drop database 具体语句用法如下： 12-- 删除名为myname的数据库drop database myname; 删除一个用户定义的域：drop domain 具体语句用法如下： 12-- 移除域boxdrop domain box; 删除一个函数：drop function 具体语句用法如下： 12-- 移除域boxdrop domain box; 删除一个索引：drop index 具体语句用法如下： 12-- 移除索引title_idxdrop index title_idx; 删除一个过程语言：drop language 具体语句用法如下： 12-- 移除过程语言plsampledrop language plsample; 删除一个操作符：drop operator 具体语句用法如下： 12-- 为类型integer移除幂操作符 a^bdrop operator ^ (integer, integer); 删除一个操作符表：drop operator class 具体语句用法如下： 12-- 移除 B-树操作符类widget_opsdrop operator class widget_ops using btree; 删除一个数据库角色：drop role 具体语句用法如下： 12-- 删除一个角色drop role jonathan; 删除一个重写规则：drop rule 具体语句用法如下： 12-- 删除重写规则newruledrop rule newrule on mytable; 删除一个模式：drop schema 具体语句用法如下： 12-- 移除序列serialdrop sequence serial; 删除一个表：drop table 具体语句用法如下： 12-- 销毁两个表films和 distributorsdrop table films, distributors; 删除一个表空间：drop tablespace 具体语句用法如下： 12-- 从系统移除表空间mystuffdrop tablespace mystuff; 删除一个触发器定义：drop trigger 具体语句用法如下： 12-- 销毁表films上的触发器 if_dist_existsdrop trigger if_dist_exists on films; 删除一个用户定义数据类型：drop type 具体语句用法如下： 12-- 移除数据类型boxdrop type box; 删除一个视图：drop view 具体语句用法如下： 12-- 将移除名为kinds的视图drop view kinds;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"http://tangmenjue.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"PgSQL","slug":"PgSQL","permalink":"http://tangmenjue.top/tags/PgSQL/"},{"name":"数据库","slug":"数据库","permalink":"http://tangmenjue.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"python学习笔记（十一）","slug":"python学习笔记（十一）","date":"2022-10-13T09:33:36.000Z","updated":"2022-10-27T01:05:23.000Z","comments":true,"path":"2022/10/13/python学习笔记（十一）/","link":"","permalink":"http://tangmenjue.top/2022/10/13/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/","excerpt":"","text":"正则表达式 正则表达式是一种用来匹配字符串强有力的武器。凡是符合规则的字符串，就认为它“匹配”了，否则该批字符串就是不合法的。正则表达式是用字符串表示，其用字符匹配规则为： 若在正则表达式中直接给出字符，就是精确匹配。 匹配一个数字: \\d 如'00\\d'可以匹配'007'但无法匹配'00A' '\\d\\d\\d'可以匹配'029' 匹配一个字母或数字: \\w 如'\\w\\w\\d'可以匹配'as2' 匹配任意一个字符：. 如'py.'可以匹配'pya'、'py@'、'py2'等。 匹配任意个字符（包括0个）： * 匹配至少一个字符： + 匹配零个或一个字符： ? 匹配n个字符： {n} 匹配n-m个字符： {n-m} 匹配一个空格（包括Tab等空白符）： \\s 匹配至少一个空格（包括Tab等空白符）： \\s+ 特殊字符要用\\+特殊字符转义。 进阶 若要做更精确地匹配，可以用[]表示范围。 匹配一个数字、字母或者下划线： [0-9a-zA-Z\\_] 注意： [0-9a-zA-Z\\_]中的0-9代表数字，a-zA-Z代表字母，\\_代表下划线。 匹配至少由一个数字、字母或者下划线组成的字符串： [0-9a-zA-Z\\_]+ 注意： [0-9a-zA-Z\\_]+中的+代表大于等于1次的匹配前面的子表达式。 匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串： [a-zA-Z\\_][0-9a-zA-Z\\_]* 匹配长度为1-20个字符的变量（前面1个字符+后面最多19个字符）： [a-zA-Z\\_][0-9a-zA-Z\\_]{0,19} 匹配A或B： A|B 表示行的开头： ^ 表示必须以数字开头： ^\\d 表示行的结束： $ 表示必须以数字结束： \\d$ re模块 python提供了re模块，包含所有正则表达式的功能，由于python的字符串本身也用\\转义，所以在字符串需要转义时，在字符串前面加r前缀。如 12s='ABc\\\\-001'#python的字符串，其对应的正则表达式字符串变成'ABc\\-001's=r'ABc\\-001'#其对应的正则表达式字符串不变'ABc\\-001' 用re模块的match()方法判断正则表达式是否匹配，若匹配成功，返回一个match对象，否则返回None： 123456import reprint(re.match(r'^\\d&#123;3&#125;\\-\\d&#123;3,8&#125;$','010-12345'))print(re.match(r'^\\d&#123;3&#125;\\-\\d&#123;3,8&#125;$','010 12345'))#运行结果如下：&lt;re.Match object; span=(0, 9), match='010-12345'&gt;None 常见的判断方法是： 12345test='用户输入的字符串'if re.match(r'正则表达式',test): print('ok')else: print('failed') 切分字符串 如果用户输入了一组标签，记得用正则表达式把不规范的输转化成正确的数组。 正常的切分代码： 123print('a b c'.split(' '))#运行结果如下：['a', 'b', '', '', 'c'] 用正则表达式切分字符串： 1234import reprint(re.split(r'\\s+','a b c'))#运行结果如下：['a', 'b', 'c'] 往字符串里增加,，:，;等符号，正则表达式切分： 1234import reprint(re.split(r'[\\s+\\,\\:\\;]+','a b c,d : ; c'))#运行结果如下：['a', 'b', 'c', 'd', 'c'] 分组 除了简单判断是否匹配外，正则表达式还有提取子串的强大功能。用()表示的是要提取的分组。 比如^(\\d{3})-(\\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取 出区号和本地号码： 1234567891011import rem=re.match(r'^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$','010-12345')print(m)print(m.group(0))print(m.group(1))print(m.group(2))#运行结果如下：&lt;re.Match object; span=(0, 9), match='010-12345'&gt;010-1234501012345 正则表达式可以直接识别合法的时间，但有时用正则表达式也无法做到完全验证。 比如识别日期： 123456789101112import ret='19:05:30'g='2-30'#2-30为非法日期#识别时间m=re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$',t)#识别日期x=re.match(r'^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$',g)print(m.groups())print(x.groups())#运行结果如下：('19', '05', '30')('2', '30') 贪婪匹配 正则匹配默认是贪婪匹配，即匹配尽可能多的字符。若要采用非贪婪匹配，则需要在需要采用非贪婪匹配的字符后面加个?号。 如要匹配出数字后面的0： 123456import reprint(re.match(r'^(\\d+)(0*)$','102300').groups())#\\d+采用的是贪婪匹配print(re.match(r'^(\\d+?)(0*)$','102300').groups())#\\d+采用非贪婪匹配#运行结果如下：('102300', '')('1023', '00') 编译 当在python中使用正则表达式时，re模块内部会干两件事： 编译正则表达式，若正则表达式的字符串本身不合法，会报错 用编译后的正则表达式取匹配字符串 若一个正则表达式需要重复使用几千次，处于效率考虑，可以对该正则表达式进行预编译，这样后面重复使用时就不需要编译了，可直接匹配。编译后生成Regular Expression对象，由于该对象已经包含了正则表达式，因而调用对应的方法时不用给出正则字符串。 12345678import rere_telephone=re.compile(r'^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$')#编译#使用print(re_telephone.match('010-12345').groups())print(re_telephone.match('010-1225').groups())#运行结果如下：('010', '12345')('010', '1225') 练习题 请尝试写一个验证Email地址的正则表达式。版本一应该可以验证出类似的Email： someone@gmail.com bill.gates@microsoft.com 代码如下： 123456789101112import redef is_valid_email(addr): if re.match(r'^([a-zA-Z\\.]+)@([0-9a-zA-Z]+).com$',addr): return Trueassert is_valid_email('someone@gmail.com')assert is_valid_email('bill.gates@microsoft.com')assert not is_valid_email('bob#example.com')assert not is_valid_email('mr-bob@example.com')print('ok') #运行结果如下：ok 版本二可以提取出带名字的Email地址： tom@voyager.org =&gt; Tom Paris bob@example.com =&gt; bob 12345678910import redef name_of_email(addr): t=re.match(r'^&lt;?([a-zA-Z]+\\s?[a-zA-Z]+)&gt;?\\s?([a-zA-Z])*@([a-zA-Z]+\\.[a-zA-Z]+)$',addr) return t.group(1)# 测试:assert name_of_email('&lt;Tom Paris&gt; tom@voyager.org') == 'Tom Paris'assert name_of_email('tom@voyager.org') == 'tom'print('ok')#运行结果如下：ok 访问数据库 使用SQLite 一个数据库连接称为connection，连接到数据库后，需要打开游标，称之为Cursor，通过Cursor执行SQL语句，然后获得执行结果。执行插入等操作后要调用commit()提交事务。 由于SQLite的驱动内置在python标准库中，故可以直接操作SQLite数据库。 1234567891011121314151617181920import sqlite3#导入数据库#连接到数据库，数据库文件是test.db。若文件不存在会自动在当前目录创建conn=sqlite3.connect('test.db')cursor=conn.cursor()#创建一个cursor#print(cursor.execute('drop table user'))#删除user表print(cursor.execute('create table user (id varchar(20) primary key, name varchar(20))'))#创建user表print(cursor.execute('insert into user (id,name) values (\\'1\\',\\'Michael\\')'))#往表中插入一条记录print(cursor.rowcount)#获得插入的行数print(cursor.execute('select * from user where id=?', ('1',)))#查询表中记录print(cursor.fetchall())#输出表中记录conn.commit#提交事务conn.close()#关闭Cursorconn.close()#关闭连接#运行结果如下：&lt;sqlite3.Cursor object at 0x0000027546A17BC0&gt;&lt;sqlite3.Cursor object at 0x0000027546A17BC0&gt;1&lt;sqlite3.Cursor object at 0x0000027546A17BC0&gt;[('1', 'Michael')] 练习题 请编写函数，在Sqlite中根据分数段查找指定的名字： 1234567891011121314151617181920212223242526272829303132import os, sqlite3db_file = os.path.join(os.path.dirname(__file__), 'test.db')if os.path.isfile(db_file): os.remove(db_file)# 初始数据:conn = sqlite3.connect(db_file)cursor = conn.cursor()#cursor.execute('drop table user')cursor.execute('create table user(id varchar(20) primary key, name varchar(20), score int)')cursor.execute(r\"insert into user values ('A-001', 'Adam', 95)\")cursor.execute(r\"insert into user values ('A-002', 'Bart', 62)\")cursor.execute(r\"insert into user values ('A-003', 'Lisa', 78)\")conn.commit()def get_score_in(low, high): ' 返回指定分数区间的名字，按分数从低到高排序 ' cursor.execute('select name from user where score between ? and ? order by score',(low,high)) return [n[0] for n in cursor.fetchall()]# 测试:assert get_score_in(80, 95) == ['Adam'], get_score_in(80, 95)assert get_score_in(60, 80) == ['Bart', 'Lisa'], get_score_in(60, 80)assert get_score_in(60, 100) == ['Bart', 'Lisa', 'Adam'], get_score_in(60, 100)cursor.close()conn.close()print('Pass')#运行结果如下：Pass 使用MySQL 连接到MySQL服务器的test数据库的命令绝大部分与SQLite相同，仅在连接数据库的部分有所差别，注意MySQL的占位符是%s： 12345678# 导入MySQL驱动:import mysql.connector# 注意把password设为你的root口令:conn =mysql.connector.connect(user='root', password='password', database='test')cursor = conn.cursor()# 插入一行记录，注意MySQL的占位符是%s:cursor.execute('insert into user (id, name) values (%s, %s)', ['1', 'Michael']) 使用SQLAlchemy SQLAlchemy是有名的ORM框架，其可以把数据库表的一行记录与一个对象相互做自动转换。 1234567891011121314151617from tkinter.tix import Treefrom sqlalchemy import Column,String,create_enginefrom sqlalchemy.orm import sessionmakerfrom sqlalchemy.ext.declarative import declarative_baseBase=declarative_base()#创建对象基类class User(Base):#定义user对象 __tablename__='user'#表名 id=Column(String(20),primary_key=True) name=Column(String(20))engine=create_engine('mysql+mysqlconnector://root:password@localhost:3306/test') #初始化数据库连接DBSession=sessionmaker(bind=engine)#创建DBSession类型session=DBSession()#创建session对象new_user=User(id='5',name='Bob')#创建新User对象 session.add(new_user)#添加到sessionsession.commit()#提交到数据库session.close()#关闭session 查询数据如下： 12345678910session=DBSession()#创建session对象#创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:user=session.query(User).filter(User.id='5').one()# 打印类型和对象的name属性:print('type:',type(user))print('name:',user.name)session.close()#运行结果如下：type: &lt;class '__main__.User'&gt;name: Bob","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://tangmenjue.top/tags/python/"}]},{"title":"python学习笔记（十）","slug":"python学习笔记（十）","date":"2022-10-13T03:44:36.000Z","updated":"2022-12-06T12:36:34.033Z","comments":true,"path":"2022/10/13/python学习笔记（十）/","link":"","permalink":"http://tangmenjue.top/2022/10/13/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/","excerpt":"","text":"进程和线程 多线程 Python的标准库提供了两个模块：_thread和threading，其中_thread是低级模块，threading是高级模块，对_thread进行了封装，绝大多数情况下，只是使用高级模块thread。任何进程默认会启动一个线程，将其称之为主线程，由主线程启动的新线程称之为子线程。 启动一个线程需要把一个函数传入并创建Thread实例，然后调用start()执行： 123456789101112131415161718192021222324252627import time,threading #新线程执行的代码def loop(): print('thread %s is running...'%threading.current_thread().name) n=0 while n&lt;5: n=n+1 print('thread %s &gt;&gt;&gt;%s'% (threading.current_thread().name,n)) time.sleep(1) print('thread %s ended.'% threading.current_thread().name)# current_thread()可以返回当前线程的实例print('thread %s is running...'%threading.current_thread().name)t=threading.Thread(target=loop,name='LoopThread')#用LoopThread命名子线程，默认名字为Thread-1,Thread-2...t.start()t.join()print('thread %s ended.'% threading.current_thread().name)#运行结果如下：thread MainThread is running...#主线程为MainThreadthread LoopThread is running...thread LoopThread &gt;&gt;&gt;1thread LoopThread &gt;&gt;&gt;2thread LoopThread &gt;&gt;&gt;3thread LoopThread &gt;&gt;&gt;4thread LoopThread &gt;&gt;&gt;5thread LoopThread ended.thread MainThread ended. Lock 多进程中，同一个变量各自有一份拷贝存在于每个进程中，多个进程之间的变量之间互不影响。 多线程中，所有变量都由所有线程共享，所以任何一个变量都可以被任何线程修改，即容易发生像在sql数据库中的读脏数据的情况。若要避免线程读脏数据的情况，就要给变量上锁。 可以通过threading.Lock()来创建一个锁： 1234567891011121314151617181920212223242526import time,threadingbalance=0def change_it(n): global balance balance=balance+n balance=balance-nlock=threading.Lock()#创建锁def run_thread(n): for i in range(100000): #获取锁 lock.acquire() try: change_it(n)#可修改的变量 finally: lock.release()#释放锁t1=threading.Thread(target=run_thread,args=(5,))t2=threading.Thread(target=run_thread,args=(8,))t1.start()t2.start()t1.join()t2.join()print(balance)#运行结果如下：0 当多个线程同时执行lock.acquire（）时，只有一个线程能成功获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。获得锁的线程用完后一定要释放锁，否则其他等待的线程将永远等下去。 多核CPU 一个死循环线程会100%占用一个CPU。若有两个死循环线程，在多核CPU中会占用200%的CPU，即两个CPU核心。若想把n核CPU的核心全部跑满，就必须启动n个死循环线程。 但在6核CPU中运行python启动6个死循环线程，CPU占用率也就仅有25%。死循环线程代码如下： 12345678import threading,multiprocessingdef loop(): x=0 while True: x=x^1for i in range(multiprocessing.cpu_count()): t=threading.Thread(target=loop) t.start() GIL锁 这是因为python解释器执行代码时，有一个GIL锁（Global Interoreter Lock），任何python线程执行前，必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁。这个GIL全局锁实际上给所有线程的执行代码都上了锁。因此多线程在python中只能交替执行，即使有100个线程跑在100核CPU上，也只能用到1个核。 因此在python中可以使用多线程，却不能够有效地利用多核。python虽然不能实现多线程并发，但可以通过多线程实现多核任务。多个python进程有各自独立的GIL锁，互不影响。 ThreadLocal 在多线程环境下，每个线程都有自己的数据。一个线程使用局部变量比使用全局变量好。而全局变量的每次修改都要加锁，因此可以考虑用一个全局dict存放所有对象，然后以thread自身作为key来获得线程对应的对象，而在ThreadLocal中可以自动做这件事： 1234567891011121314151617import threadinglocal_school=threading.local()#创建全局ThreadLocal对象def process_student(): std=local_school.student#获取当前线程关联的student print('Hello,%s (in %s)'%(std,threading.current_thread().name))def process_thread(name): local_school.student=name#绑定ThreadLocal的student process_student()t1=threading.Thread(target=process_thread,args=('Alice',),name='Thread-A')t2=threading.Thread(target=process_thread,args=('Bob',),name='Thread-B') t1.start()t2.start()t1.join()t2.join()#运行结果如下：Hello,Alice (in Thread-A)Hello,Bob (in Thread-B) 可以理解为全局变量local_school是一个dict，其不但可以用local_school.student，还可以绑定其他变量。 ThreadLocal最常用在为每个线程绑定一个数据库连接、HTTP请求、用户身份信息等。 进程 vs 线程 要实现多任务通常会设计Master-Worker模式，Master复制分配任务，Worker负责执行任务，故在多任务环境下，通常是一个Master，多个Worker。 用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。 用多线程实现Master-Worker，主线程就是Master，其他进程就是Worker。 多进程模式最大的优点是稳定性高。一个子进程崩溃了不会影响主进程核其他进程。其缺点是创建进程的开销大，占用系统资源较多，且操作系统同时运行的进程数也有限。 多线程模式通常比多进程快一点，其缺点是任何一个线程挂掉都可能直接造成整个进程崩溃。 线程切换 操作系统在切换进程或线程时，需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后把新任务的执行环境准备好（恢复上次的寄存器状态、切换内存页等），才能开始执行。 计算密集型 vs IO密集型 把任务分为计算密集型和IO密集型，并以此来考虑是否采用多任务。 计算密集型任务的特点是进行大量的计算，消耗CPU资源。要最高效的利用CPU，计算密集型任务同时进行的数量应当等于CPU的核数。python做计算密集型任务的运行效率很低，故最好是用C语言编写计算密集型任务。 IO密集型任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成。对于IO密集型任务，在一定限度内的任务最多，CPU效率越高。 异步IO 若充分利用操作系统提供的异步IO支持，就能用单线程模型来执行多任务，这种全新的模型称为事件驱动模型。对于python来说，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。 分布式进程 在线程和进程中，应当优先选择进程。因为进程更稳定，而且进程可以分布到多台机器上，而线程最多只能分布到同一台机器的多个CPU上。 python的multiprocessing模块不但支持多进程，其中的managers子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。 若有一个通过Queue通信的多进程程序在同一台机器上运行，现在要把发送任务的进程和处理任务的进程分布到两台机器上。原有的Queue可以继续用，通过managers模块把Queue通过网络暴露出去，其他机器的进程就可以访问Queue了。其实现如下： 服务器端Master的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import random,time,queuefrom multiprocessing.managers import BaseManagerfrom multiprocessing import freeze_support #server启动报错，提示需要引用此包#发送任务的队列task_queue = queue.Queue()#接收结果的队列result_queue = queue.Queue()#从BaseManager继承的QueueManagerclass QueueManager(BaseManager): pass#win10 64 貌似不支持callable下调用匿名函数lambda，这里封装一下def return_task_queue(): global task_queue return task_queuedef return_result_queue(): global result_queue return result_queuedef test(): #把两个Queue注册到网络上，callable参数关联了Queue对象 #QueueManager.register('get_task_queue',callable=lambda:task_queue) #QueueManager.register('get_result_queue',callable=lambda:result_queue) QueueManager.register('get_task_queue',callable=return_task_queue) QueueManager.register('get_result_queue',callable=return_result_queue) #绑定端口5000，设置验证码‘abc’ manager = QueueManager(address=('127.0.0.1',5000),authkey=b'abc')#这里必须加上本地默认ip地址127.0.0.1 #启动Queue manager.start() print('start server master') #获得通过网络访问的Queue对象 task = manager.get_task_queue() result = manager.get_result_queue() #放几个任务进去 for i in range(10): n = random.randint(0,10000) print('put task %d...' % n) task.put(n) #从result队列读取结果 print('try get results...') for i in range(10): r = result.get(timeout=10) print('result:%s' % r) #关闭 manager.shutdown() print('master exit')if __name__ == '__main__': freeze_support() test() 在另一个文件里写非服务端Worker的代码： 123456789101112131415161718192021222324252627282930313233import time,sys,queuefrom multiprocessing.managers import BaseManager#创建类似的QueueManagerclass QueueManager(BaseManager): pass#由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字即可QueueManager.register('get_task_queue')QueueManager.register('get_result_queue')#连接到服务器，也就是运行task_master.py的机器server_addr = '127.0.0.1'print('connect to server %s...'% server_addr)#端口和验证码注意要保持完全一致m = QueueManager(address=(server_addr,5000),authkey=b'abc')#从网络连接m.connect()#获取Queue的对象task = m.get_task_queue()result = m.get_result_queue()#从task队列获取任务，并把结果写入result队列for i in range(10): try: n = task.get(timeout=1) print('run task %d * %d...'% (n,n)) r = '%d * %d = %d' % (n,n,n*n) time.sleep(1) result.put(r) except queue.Empty: print('task queue is empty')#处理结果print('worker exit') 先运行服务端Marker的代码，再运行非服务端Worker的代码，运行结果如下： 服务端Marker的运行结果如下图： 非服务端Worker的运行结果如下图：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://tangmenjue.top/tags/python/"}]},{"title":"python学习笔记（九）","slug":"python学习笔记（九）","date":"2022-10-12T09:30:22.000Z","updated":"2022-10-25T09:18:32.000Z","comments":true,"path":"2022/10/12/python学习笔记（九）/","link":"","permalink":"http://tangmenjue.top/2022/10/12/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/","excerpt":"","text":"IO编程 往外发数据的操作叫做Output，往外接收数据的操作叫做Intput。因此程序完成IO操作会有两个Intput和Output数据流。 在IO编程中存在速度不匹配的问题，其解决方法有两种： 第一种是同步IO，即让cpu等着，程序暂停执行后续的代码，等当前读写操作完成后再往下执行。 第二种是异步IO，即cpu不等待，让其慢慢读写，后续代码可以立刻执行，其复杂度远高于同步IO。 文件读写 读写文件就是请求操作系统打开一个文件对象，然后通过操作系统提供的接口从该文件对象中读取数据或把数据写入这个文件对象。 读文件 使用open()函数读文件：f=open('路径','r'),其中'r'表示读取。 文件打开后，一次读取文件全部内容：f.read() 关闭文件：f.close() 为保证无论是否出错都能正确关闭文件，可引入with语句： 12with open('路径','r') as f: print(f.read()) 每次最多读取size个字节的内容：f.read(size) 每次读取一行内容：f.readline() 一次读取所有内容并按行返回list：f.readlines() 若文件很小，使用read()一次性读取最方便，若不能确定文件大小，反复调用read(size)比较好，若是配置文件，调用readlines()最方便。 file-like Object 像open()函数返回的有个read()方法的对象，统称为file-like Object。file-like Object不要求从特定类中继承，只要写read()方法就行。除了file外，还可以是内存的字节流、网络流、自定义流等。 二级制文件 open()函数默认读取的是UTF-8编码的文本文件，若要读取二进制编码的文件，open()函数得写成：f=open('路径','rb')。 字符编码 若要读取非UTF-8编码的文件，需要给open()函数传入encoding参数。 如读取GDK编码的文件：f=open('路径',encoding='gdk')。 写文件 写文件时也是用open()函数来打开文件，此时的open()函数得写成：f=open('路径','w')，其中'w'表示写文本文件或写二进制文件。 往文件中写入内容：f.write(内容) 写完内容后要用f.close()语句来关闭文件。为保证无论是否出错都能正确关闭文件，可引入with语句： 12with open('路径','w') as f: f.write('123') 若要写入特定文本文件，需要给open()函数传入encoding参数，如f=open('路径','w'，encoding='gdk') 若写入文件时文件 已存在，会直接覆盖原文件，若需要将内容追加到文件末尾，在open()语句中传入'a'来写入。其形式为：open('路径','a') 练习题 请将本地一个文本文件读为一个str并打印出来： 12345fpath = '/etc/timezone'with open(fpath, 'r') as f: s = f.read() print(s) 代码修改如下： 123456fpath = './1.txt'with open(fpath, 'r') as f: s = f.read() print(s)#运行结果如下：helloworld! StringIO和BytesIO() StringIO StringIO就是在内存中读写str，其只能操作str数据。 要把str写入StringIO，需要先创建一个StringIO，然后在像写文件一样写入： 123456from io import StringIOf=StringIO()f.write('hello world!')print(f.getvalue())#运行结果如下：hello world! 获得写入后的str:getvalue() 要读取StringIO，需要先用一个str初始化StringIO，然后在像读文件一样读取： 123456789from io import StringIOf=StringIO('hello world!')while True: s=f.readline() if s=='': break print(s.strip())#运行结果如下：hello world! BytesIO StringIO就是在内存中读写bytes，其只能操作二进制数据。 使用BytesIO写入二进制数据如下： 123456from io import BytesIOf=BytesIO()f.write('中文'.encode('utf-8'))print(f.getvalue())#运行结果如下：b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 使用BytesIO读取二进制数据如下： 12345from io import BytesIOf=BytesIO(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87')print(f.read())#运行结果如下：b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 操作文件和目录 使用os模块可以直接调用操作系统提供的接口函数。 os模块的基本功能如下所示： 123456import osprint(os.name)#获取操作系统类型#若输出nt，说明系统是Windows系统，若输出posix,说明是Linux、Unix或Moc OS X系统print(os.uname)#获取详细的操作系统信息#uname函数在Windows上不提供 环境变量 系统定义的环境变量保存在os.environ中。 获取某个环境变量key的值：os.environ.get('key') 操作文件和目录 查看、创建和删除目录语句如下： 1234567891011121314import osprint(os.path.abspath('.'))#查看当前目录的绝对路径#在某个目录下创建新目录（新建文件并将路径加到某个目录中）os.path.join('/某个目录路径','新文件名称')#将某目录和新文件目录的路径合成一个os.mkdir('/新文件完整路径')#创建一个目录os.rmkdir('/新文件完整路径')#删除一个目录os.path.split('/新文件完整路径')#将目录拆分为某目录和文件名两个部分os.path.splitext('/新文件完整路径')#将目录拆分为某目录和文件名拓展名两个部分os.rename('文件原名','文件新名')#重命名文件os.remove('文件名')#删除文件 os模块中不存在复制文件的函数。 导入os模块后，列出当前目录下所有目录：print([x for x in os.listdir('.') if os.path.isdir(x)]) 导入os模块后，列出当前目录下所有.py文件：print([x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py']) 练习题 1.利用os模块编写一个能实现dir -l输出的程序。 这里的dir-l命令指的是在linux系统下运行的命令，其与ls -l命令类似，作用皆为查看当前目录所有的文件和目录的详细信息。代码如下： 123456789101112131415import osimport time current=os.getcwd()filenum,filesize,dirnum=0,0,0for name in os.listdir(current): if os.path.isfile(name): print('%s\\t\\t%s\\t%s' % (time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(os.path.getmtime(name))),os.path.getsize(name),name)) filenum+=1 filesize+=os.path.getsize(name) if os.path.isdir(name): print('%s\\t\\t%s\\t%s' % (time.strftime('%Y-%m-%d %H:%M:%S',time .localtime(os.path.getmtime(name))),os.path.getsize(name),name)) dirnum+=1print('\\t\\t\\t\\t%d个文件，\\t\\t%d 字节' % (filenum,filesize)) print('\\t\\t\\t\\t%d个目录' % (dirnum)) 2.编写一个程序，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出相对路径。 代码如下： 1234567891011121314from genericpath import isfileimport osimport os.pathdef find_str(current,str): for name in os.listdir(current): new_path=os.path.join(current,name) if os.path.isfile(new_path): if str in name: print('name=%s , dir=%s' % (name,('../'+name))) else: find_str(new_path,str) if __name__=='__main__': find_str(os.path.abspath(\".\"),'.py') 序列化 把变量从内存中变成可存储或传输的过程，称之为序列化(picking)。序列化后可以把序列化后的内容写入磁盘，或通过网络传输到别的机器上。把变量从序列化的对象重新读到内存里的过程，称之为反序列化(unpicking)。可以通过pickle模块来实现序列化。 将对象序列化并写入文件中： 123456789import pickled=dict(name='Bob',age=20,score=99)print(pickle.dumps(d))#把任意对象序列化成一个bytesf=open('1.txt','wb')pickle.dump(d,f)#直接把对象序列化后写入一个file-like Objectf.close()#运行结果如下：#文件1.txt中的结果€\u0004? &#125;??name攲\u0003Bob攲\u0003age擪\u0014?score擪cu. 写入的1.txt文件中的内容便是python保存的对象内容。 反序列化刚才保存的对象： 1234567import picklef=open('1.txt','rb')d=pickle.load(f)f.close()print(d)#运行结果如下：&#123;'name': 'Bob', 'age': 20, 'score': 99&#125; Pickle只能用于python，且可能不同版本的python彼此不兼容，因此只能用Pickle保存那些不重要的数据， JSON 若要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML、JSON。最好是序列化为JSON，因为其表示出来的就一个字符串，可以被所有语言读取，也更方便存储到磁盘或通过网络传输。 JSON表示的对象是标准的JavaScript语言的对象，JSON和Python内置的数据类型对象如下： JSON类型 Python类型 {} dict [] list \"string\" str 1234.56 int或float true/false True/False null None 通过json模块可以把python对象变成一个JSON： 12345import jsond=dict(name='Bob',age=20,score=99)print(json.dumps(d))#返回一个str，内容是标准的JSON#运行结果如下：&#123;\"name\": \"Bob\", \"age\": 20, \"score\": 99&#125; 把JSON反序列化为Python对象： 12345import jsonjson_str='&#123;\"age\":22,\"score\":93,\"name\":\"Lisi\"&#125;'print(json.loads(json_str))#运行结果如下：&#123;'age': 22, 'score': 93, 'name': 'Lisi'&#125; JSON进阶 默认情况下，class实例不是一个可序列化为JSON的对象。若要序列化该class实例，需要先写一个转换函数把实例转换成dict，再序列化： 1234567891011121314151617import jsonclass Student(object): def __init__(self,name,age,score): self.name=name self.age=age self.score=scoredef student2dict(std): return&#123; 'name':std.name, 'age':std.age, 'score':std.score &#125; s=Student('Bob',22,99) print(json.dumps(s,default=student2dict))#运行结果如下：&#123;\"name\": \"Bob\", \"age\": 22, \"score\": 99&#125; 不过以上代码只能应用于Student类，若要将任一class实例变为dict可将student2dict()函数以及print()语句精简为以下语句： print(json.dumps(s,default=lambda obj:obj.__dict__)) 若要把JSON反序列化为一个class对象实例，可以先用loads()方法转化出一个dict对象，然后传入object_hook函数把dict转换为Student实例： 123456789101112131415import jsonclass Student(object): def __init__(self,name,age,score): self.name=name self.age=age self.score=score def dict2student(d): return Student(d['name'],d['age'],d['score']) s=Student('Bob',22,99) json_str='&#123;\"age\":22,\"score\":99,\"name\":\"Bob\"&#125;'print(json.loads(json_str,object_hook=dict2student)) #运行结果如下：&lt;__main__.Student object at 0x0000019E34217B80&gt; 练习题 对中文进行JSON序列化时，json.dumps()提供了一个ensure_ascii参数，观察该参数对结果的影响： 12345678import jsonobj = dict(name='小明', age=20)s = json.dumps(obj, ensure_ascii=True)#当ensure_ascii的值为True时，name以ascii字符码输出#当ensure_ascii的值为False时，name以中文输出print(s)#运行结果如下：&#123;\"name\": \"\\u5c0f\\u660e\", \"age\": 20&#125; 进程和线程 对于操作系统来说，一个任务就是一个进程。线程是最小的执行单元，由于每个进程至少要干一件事，因此一个进程至少有一个线程，多个线程可以同时执行。python既支持多进程又支持多线程。 多任务的实现有3种方式： 多进程模式：启动多个进程，每个进程只有1个线程，但多个进程可以一起执行多个任务。 多线程模式：启动一个进程，在进程内启动多个线程，让多个线程一起执行多个任务。 多进程+多线程模式：启动多个进程，每个进程再启动多个线程，同时执行多个任务。 多进程 fork()是一个系统调用函数，调用一次，返回两次。其中，当前进程（父进程）复制出来了一份子进程，父进程返回子进程的ID，子进程永远返回0。子进程可以通过getppid()获取父进程的ID。 在Mac系统中，python的os模块中封装了常见的系统调用函数，使其可以在程序中创建子进程： 1234567891011import osprint('Process (%s) start...'% os.getpid())pid=os.fork()if pid==0: print('I am child process (%s) and my parent is %s.'% (os.getpid(),os.getppid()))else: print('I (%s) just created a child process(%s).'%(os.getpid(),pid)) #运行结果如下：Process (42) start...I (42) just created a child process(46).I am child process (46) and my parent is 42. 在Windows系统中没有fork调用，若要运行上面的代码，可以在onlinegdb在线编译器里选择python3语言后，编译运行。 有了fork调用，一个进程在接到新任务时就可以复制出一个子进程出来，父进程复制监听端口，子进程负责处理任务。 multiprocessing 若要在Windows上用python编写多进程程序，可以使用multiprocessing模块，其是一个跨平台版本的多进程模块，提供了一个process类来代表一个进程对象。 运用multiprocessing模块启动一个子进程并等待其结束： 12345678910111213141516from multiprocessing import Processimport osdef run_proc(name): print('Run child process %s (%s)...'%(name,os.getpid()))if __name__=='__main__': print('Parent process %s.'% os.getpid()) p=Process(target=run_proc,args=('test',))#创建进程 print('Child process will start.') p.start()#启动进程 p.join()#等待子进程结束后再继续往下运行，用于进程间的同步 print('Child process end.')#运行结果如下：Parent process 12664.Child process will start.Run child process test (9516)...Child process end. Pool 若要启动大量的子进程，可以用进程池(pool)的方式批量创建子进程： 1234567891011121314151617181920212223242526272829303132from multiprocessing import Poolimport os,time,randomdef long_time_task(name): print('Run task %s (%s)...'% (name,os.getpid())) start=time.time() time.sleep(random.random()*3) end=time.time() print('Task %s runs %0.2f seconds.'% (name,(end-start))) if __name__=='__main__': print('Parent process %s.'% os.getpid()) p=Pool(4)#设置最多同时执行4个进程，pool默认大小是cpu的核数 for i in range(5): p.apply_async(long_time_task,args=(i,)) print('Waiting for all subprocesses done...') p.close()#停止继续添加新进程 p.join()#等待所有子进程执行完毕，调用前必须先调用close() print('All subprocesses done')#运行结果如下：Parent process 1228.Waiting for all subprocesses done...Run task 1 (1233)...Run task 2 (1234)...Run task 3 (1235)...Run task 0 (1232)...Task 2 runs 0.86 seconds.Run task 4 (1234)...Task 1 runs 1.77 seconds.Task 3 runs 1.83 seconds.Task 4 runs 1.04 seconds.Task 0 runs 2.62 seconds.All subprocesses done 子进程 subprocess模块可以启动一个子进程，然后控制其输入和输出。 如用subprocess模块在python代码中运行命令nslookup www.python.org： 12345678910111213141516import subprocessprint('$ nslookup www.python.org')r=subprocess.call(['nslookup','www.python.org'])print('Exit code:',r)#运行结果如下：$ nslookup www.python.org服务器: gdad07.gd.ctc.comAddress: 10.157.160.89非权威应答:名称: dualstack.python.map.fastly.netAddresses: 2a04:4e42:8c::223 151.101.108.223Aliases: www.python.orgExit code: 0 若子进程需要输入，可以调用communicate()方法来实现： 123456789101112131415161718192021import subprocessprint('$ nslookup')p = subprocess.Popen(['nslookup'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)output, err = p.communicate(b'set q=mx\\npython.org\\nexit\\n')#输入语句a=output.decode('unicode_escape')#对unicode编码的output进行反编码print(a)print('Exit code:', p.returncode)#运行结果如下：$ nslookupÄ¬ÈÏ·þÎñÆ÷: gdad07.gd.ctc.comAddress: 10.157.160.89&gt; &gt; ·þÎñÆ÷: gdad07.gd.ctc.comAddress: 10.157.160.89python.org MX preference = 50, mail exchanger = mail.python.orgmail.python.org internet address = 188.166.95.178mail.python.org AAAA IPv6 address = 2a03:b0c0:2:d0::71:1&gt;Exit code: 0 进程间通信 multiiprocessing模块包装了底层的机制，提供了Queue、Pips等多种方式来交换数据，以实现进程间的通信。 以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，另一个从Queue里读数据： 1234567891011121314151617181920212223242526272829303132333435from multiprocessing import Process,Queueimport os,time,random#写数据进程所执行的代码def write(q): print('Process to write: %s'%os.getpid()) for value in ['A','B','C']: print('Put %s to queue...'% value) q.put(value) time.sleep(random.random())#读数据进程所执行的代码 def read(q): print('Process to read: %s' %os.getpid()) while True: value=q.get(True) print('Get %s from queue.' %value)if __name__=='__main__': q=Queue()#父进程创建Queue，并传给各个子进程 pw=Process(target=write,args=(q,)) pr=Process(target=read,args=(q,)) pw.start()#启动子进程pw，写入 pr.start()#启动子进程pw，读取 pw.join()#等待pw结束 pr.join()#pr进程里是 死循环，无法等待其结束，只能强行终止 pr.terminate()#运行结果如下：Process to write: 4684Process to read: 3796Put A to queue...Get A from queue.Put B to queue...Get B from queue.Put C to queue...Get C from queue. 在Unix/Linix下，multiprocessing模块封装了fork()调用，由于Windows没有fork调用，所以父进程所有python对象都必须通过pickle序列化再传到子进程去。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://tangmenjue.top/tags/python/"}]},{"title":"python学习笔记（八）","slug":"python学习笔记（八）","date":"2022-10-12T02:30:22.000Z","updated":"2022-12-06T12:31:10.503Z","comments":true,"path":"2022/10/12/python学习笔记（八）/","link":"","permalink":"http://tangmenjue.top/2022/10/12/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/","excerpt":"","text":"错误、调试和测试 错误处理 在程序运行过程中，可以实现设定发生错误时返回一个错误代码，这样就可以知道是否出错及其出错原因是什么。 错误处理机制python的错误处理机制:try...except...finally..。 当认为某段代码可能会出错时，用try来运行这段代码，如果执行出错，则后续的代码不会继续执行，而是直接跳转到错误处理代码except语句块中，执行完except语句块后，如果还有finally语句块，则执行语句块，错误处理机制执行完毕。例如： 12345678910111213141516171819try: print('try...') r=10/int('a') print('result:',r)except ValueError as e: print('ValueError:',e)except ZeroDivisionError as e: print('except:',e)else: print('no error!') finally: print('finally...')print('END')#运行结果如下：try...ValueError: invalid literal for int() with base 10: 'a'finally...END 如果没有错误发生，except语句块不会被执行，但如果有finally语句块，finally语句块一定会被执行。在使用except时要注意先写子类的异常，基类的异常在后。 使用try...except捕获错误可以跨越多层调用。不需要在每个可能出错的地方去捕获错误。 调用栈 若错误没有被捕获，就会一直往上抛，直至最后被python解释器捕获，打印一个错误信息，程序就退出了。出错的时候一定要分析错误的调用栈信息，才能定位错误的位置。 记录错误 如果能捕获错误，就可以把错误堆栈打印出来，分析错误原因的同时，让程序继续执行下去。 logging模块可以记录错误信息。导包后的调用形式：logging.exception(e)。 抛出错误 因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此自己编写的函数也可以抛出错误。若需要抛出错误，可以先定义一个错误的class，然后用raise语句抛出一个错误。但只有在必要的时候才定义自己的错误类型，若可以选择内置的错误类型，尽量使用内置的错误类型。 抛出错误例子： 12345678910111213141516class FooError(ValueError): passdef foo(s): n=int(s) if n==0: raise FooError('invalid value: %s' % s) return 10/nfoo('0')#运行结果如下：Traceback (most recent call last): File \"main.py\", line 8, in &lt;module&gt; foo('0') File \"main.py\", line 6, in foo raise FooError('invalid value: %s' % s)__main__.FooError: invalid value: 0 另一种错误处理方式为，捕获错误后，又把错误通过raise语句往上抛，让顶层的调用者去处理。 raise语句如果不带参数，就会把当前错误原样抛出。若在except中raise一个Error，可以将一种类型的错误转化为另一种类型，但不能将一个IOError转换成毫不相干的ValueError。 练习题 运行下面的代码，根据异常信息进行分析，定位出错误源头，并修复： 1234567891011121314151617from functools import reducedef str2num(s): return int(s)def calc(exp): ss = exp.split('+') ns = map(str2num, ss) return reduce(lambda acc, x: acc + x, ns)def main(): r = calc('100 + 200 + 345') print('100 + 200 + 345 =', r) r = calc('99 + 88 + 7.6') print('99 + 88 + 7.6 =', r)main() 修复后的代码如下： 123456789101112131415161718192021from functools import reducedef str2num(s): return float(s)def calc(exp): ss = exp.split('+') ns = map(str2num, ss) return reduce(lambda acc, x: acc + x, ns)def main(): r = calc('100 + 200 + 345') print('100 + 200 + 345 =', r) r = calc('99 + 88 + 7.6') print('99 + 88 + 7.6 =', r)main()#运行结果如下：100 + 200 + 345 = 645.099 + 88 + 7.6 = 194.6 调试 方法一：print() 用print()把可能有问题的变量打印出来看 方法二：断言(assert) 凡是用print()来看的地方，都可以用断言(assert)来替代。如： 123456789101112def foo(s): n=int(s) assert n!=0,'n is zero!'#若n=0,则会抛出AssertionError错误 return 10/nfoo('0')#运行结果如下：Traceback (most recent call last): File \"main.py\", line 5, in &lt;module&gt; foo('0') File \"main.py\", line 3, in foo assert n!=0,'n is zero!'AssertionError: n is zero! python解释器中可以用python -O 文件名来关闭assert。关闭后，所有的assert语句都相当于一个pass。 方法三：logging 把print()替换为logging后，与assert比，logging不会抛出错误，且可以输出到文件。通过配置logging，可以将一条语句同时输出到不同的地方，如文件和控制台。 12345678910111213import logging logging.basicConfig(level=logging.INFO)#指定记录信息的级别s='0'n=int(s)logging.info('n=%d' % n)#输出一段文本print(10/n)#运行结果如下：INFO:root:n=0Traceback (most recent call last): File \"main.py\", line 7, in &lt;module&gt; print(10/n)ZeroDivisionError: division by zero logging有debug、info、warning、error等几个级别，当指定level=INFO时，logging.debug就不起作用了。当指定level=WARNING时，logging.debug和logging.INFO就不起作用了。 方法四：pdb 启动python的调制器pdb，可以让程序以单步方式运行，类似于c++的单点调试，可以随时查看代码的运行状态。pdb需要在控制台里输入语句，其形式为python -m pdb 文件名。 示例如下： pdb内的命令用法如下： 单步执行代码：输入 n 查看变量：p 变量名 退出程序：输入 q 方法五：pdb.set_trace() 该方法也是用pdb，需要在控制台里输入语句，但不需要单步执行。类似于c++的断点调试，只需要import pdb，然后在可能出错的地方一个pdb.set_trace()，就可以设置一个断点。 示例如下： 进入pdb调试环境后，可用p 变量名查看变量，输入c继续运行。 方法六：IDE 高效率的设置断点、单步执行，需要一个支持调试功能的IDE。目前常用的Python IDE有： Visual Studio Code、PyCharm、加上pydev插件的Eclipse。 单元测试 单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。将针对某函数写的测试用例放到一个测试模块里，便是一个完整的单元测试。 若单元测试通过，则说明所测试的函数能够正常工作；若单元测试不通过，要么函数有bug，要么测试条件输入不正确。 单元测试需要引用unittest模块。常调用模块内置的条件判断来断言输出是否是期望值，最常用的断言语句是：self.assertEqual(函数名(参数),期待值)。 另一种重要的断言是期待抛出指定类型的Error，用法是： 12with self.assertRaises(指定类型的Error): value=函数.属性或者是函数(参数) 运行单元测试 方法一：在代码最后加上两行代码，直接运行程序 12if __name__=='__main__': unittest.main() 方法二：在命令行通过参数python -m unittest 文件名运行单元测试。 setUp与tearDown 每调用一个测试方法前被执行：setUp() 在测试方法执行完后被执行：tearDown() 练习题 对Student类编写单元测试，结果发现测试不通过，请修改Student类，让测试通过： 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: utf-8 -*-import unittestclass Student(object): def __init__(self, name, score): self.name = name self.score = score def get_grade(self): if self.score &gt;= 60: return 'B' if self.score &gt;= 80: return 'A' return 'C'class TestStudent(unittest.TestCase): def test_80_to_100(self): s1 = Student('Bart', 80) s2 = Student('Lisa', 100) self.assertEqual(s1.get_grade(), 'A') self.assertEqual(s2.get_grade(), 'A') def test_60_to_80(self): s1 = Student('Bart', 60) s2 = Student('Lisa', 79) self.assertEqual(s1.get_grade(), 'B') self.assertEqual(s2.get_grade(), 'B') def test_0_to_60(self): s1 = Student('Bart', 0) s2 = Student('Lisa', 59) self.assertEqual(s1.get_grade(), 'C') self.assertEqual(s2.get_grade(), 'C') def test_invalid(self): s1 = Student('Bart', -1) s2 = Student('Lisa', 101) with self.assertRaises(ValueError): s1.get_grade() with self.assertRaises(ValueError): s2.get_grade()if __name__ == '__main__': unittest.main() 修改后的代码为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import unittestclass Student(object): def __init__(self, name, score): self.name = name self.score = score def get_grade(self): if self.score &gt;= 60 and self.score &lt; 80: return 'B' elif self.score &gt;= 80 and self.score &lt;= 100: return 'A' elif self.score &gt;= 0 and self.score &lt; 60: return 'C' else: raise ValueError()class TestStudent(unittest.TestCase): def test_80_to_100(self): s1 = Student('Bart', 80) s2 = Student('Lisa', 100) self.assertEqual(s1.get_grade(), 'A') self.assertEqual(s2.get_grade(), 'A') def test_60_to_80(self): s1 = Student('Bart', 60) s2 = Student('Lisa', 79) self.assertEqual(s1.get_grade(), 'B') self.assertEqual(s2.get_grade(), 'B') def test_0_to_60(self): s1 = Student('Bart', 0) s2 = Student('Lisa', 59) self.assertEqual(s1.get_grade(), 'C') self.assertEqual(s2.get_grade(), 'C') def test_invalid(self): s1 = Student('Bart', -1) s2 = Student('Lisa', 101) with self.assertRaises(ValueError): s1.get_grade() with self.assertRaises(ValueError): s2.get_grade()if __name__ == '__main__': unittest.main() #运行结果如下：....----------------------------------------------------------------------Ran 4 tests in 0.001sOK 文档测试 文档测试（doctest）模块可以自动提取写在注释中的代码并执行测试。 dectest严格按照命令行的输入和输出来判断测试结果是否正确。若运行文档测试后没有输出，则说明程序是正确的，在测试异常时，可以用...表示中间的出错的信息。 运行文档测试，需要先在代码的最后加上一下三行代码，然后在命令行中通过python 文件名来执行文档测试： 123if __name__=='__main__': import doctest doctest.testmod() 在模块正常导入时不会执行文档测试，只有在命令行直接运行时才执行文档测试。 练习题 对函数fact(n)编写doctest并执行： 1234567891011121314151617181920def fact(n): ''' Calculate 1*2*...*n &gt;&gt;&gt; fact(1) 1 &gt;&gt;&gt; fact(10) ? &gt;&gt;&gt; fact(-1) ? ''' if n &lt; 1: raise ValueError() if n == 1: return 1 return n * fact(n - 1)if __name__ == '__main__': import doctest doctest.testmod() 代码如下： 1234567891011121314151617181920212223def fact(n): ''' Calculate 1*2*...*n &gt;&gt;&gt; fact(1) 1 &gt;&gt;&gt; fact(10) 3628800 &gt;&gt;&gt; fact(-1) Traceback (most recent call last): ... ValueError ''' if n &lt; 1: raise ValueError() if n == 1: return 1 return n * fact(n - 1)if __name__ == '__main__': import doctest doctest.testmod()#运行结果为空","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://tangmenjue.top/tags/python/"}]},{"title":"python学习笔记（七）","slug":"python学习笔记（七）","date":"2022-10-11T08:40:35.000Z","updated":"2022-12-06T12:27:11.479Z","comments":true,"path":"2022/10/11/python学习笔记（七）/","link":"","permalink":"http://tangmenjue.top/2022/10/11/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/","excerpt":"","text":"面向对象编程 获取对象信息 使用type() 判断对象类型：type(对象) 用type()来判断对象是否是函数 123456789101112import typesdef fn(): passprint(type(fn)==types.FunctionType)print(type(abs)==types.BuiltinFunctionType)print(type(lambda z:z)==types.LambdaType)print(type((x for x in range(10)))==types.GeneratorType)#运行结果如下：TrueTrueTrueTrue 使用isinstance() 判断class的类型：isinstance(变量名,对象名) 123456789101112131415161718class Person(object): def __init__(self,num=0,sex='m'): self.num=num self.sex=sex def getnum(self): return self.numclass Student(Person): def setnum(self,num): self.num=numa=Person()b=Student()print(isinstance(a,Person))print(isinstance(b,Person))#b继承了a，所以b也是Person类型print(isinstance(a,Student))#a不是Student类型#运行结果如下：TrueTrueFalse isinstance也可以用来判断基本类型，形式为：isinstance(判断的对象,类型名) isinstance还可以判断一个变量是否是某些类型的一种，例如判断是否是list或tuple： 123456789print(isinstance([1,2,3],tuple))print(isinstance((1,2,3),tuple))print(isinstance([1,2,3],(list,tuple)))print(isinstance((1,2,3),(list,tuple)))#运行结果如下：FalseTrueTrueTrue 因此优先使用isinstance()判断类型，可以将指定类型及其子类”一网打尽“。 使用dir() 只有在不知道对象信息时，才会用以下函数去获取对象信息。 获得一个对象的所有属性和方法：dir()，其返回一个包含字符串的list。例如： 123print(dir(123))#运行结果如下：['__abs__', '__add__', '__and__',..., 'real', 'to_bytes'] __xxx__为有特殊用途的属性和方法，其他的为普通属性和方法。 判断对象是否有某属性或方法：hasattr(指向对象的变量名,属性或方法) 设置对象的属性值：setattr(指向对象的变量名,属性,属性值) 获取对象的属性或方法：getattr(指向对象的变量名,属性或方法) 实例属性和类属性 通过实例变量或self变量给实例绑定的属性是实例属性，归当前实例所有。 直接在class中定义的属性是类属性，归类所有，但类的所有属性都可以访问，用类名.属性名调用。 两者的形式区别如下所示： 1234class Person(object): num='123'#类属性 def __init__(self,sex): self.sex=sex#实例属性 练习题 为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加： 代码如下： 1234567891011121314151617181920212223class Student(object): count = 0 def __init__(self, name): self.name = name Student.count=Student.count+1 # 测试:if Student.count != 0: print('测试失败!')else: bart = Student('Bart') if Student.count != 1: print('测试失败!') else: lisa = Student('Bart') if Student.count != 2: print('测试失败!') else: print('Students:', Student.count) print('测试通过!')#运行结果如下：Students: 2测试通过! 面向对象高级编程 使用__slots__ 定义一个特殊的变量来限制对实例添加属性：__slots__。 例如，只允许对Student实例添加name和age属性： 12class Student(object): __slots__=('name','age') __slots__定义的属性仅对当前类实例起作用，对继承的子类不起作用。 使用@property 把一个方法变成属性调用：@property 如把一个getter方法变成属性，只需要加上@property就可以了。与此同时，@property本身又创建了另一个@实例名.setter，负责把一个setter方法变成属性赋值： 12345678910111213141516171819202122class Student(object): @property def score(self): return self.score @score.setter def score(self,value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value&gt;100 or value&lt;0: raise ValueError('score must between 0~100!') self.score=value s=Student()s.score=299print(s.score)#运行结果如下：Traceback (most recent call last): File \"main.py\", line 14, in &lt;module&gt; s.score=299 File \"main.py\", line 11, in score raise ValueError('score must between 0~100!') ValueError: score must between 0~100! @property还可以定义只读属性。只定义getter方法，不定义setter方法便是一个只读属性，如下面的score属性便是只读属性： 1234class Student(object): @property def score(self): return self.name 注意:属性的方法名不要与实例变量重名。在调用方法时会首先转换为方法调用，而在return语句时，又看作访问类的属性，于是又转换为方法调用，从而导致栈溢出报错。 练习题 请利用@property给一个Screen对象加上width和height属性，以及一个只读属性resolution： 123456789101112131415161718192021222324252627282930class Screen(object): @property def width(self): return self._width @width.setter def width(self,value): self._width=value @property def height(self): return self._height @height.setter def height(self,value): self._height=value @property def resolution(self): return self._height*self._width # 测试:s = Screen()s.width = 1024s.height = 768print('resolution =', s.resolution)if s.resolution == 786432: print('测试通过!')else: print('测试失败!')#运行结果如下：resolution = 786432测试通过! 多重继承 多重继承形式：class 类名(基类1,基类2): 在设计类的继承关系时，子类除了继承基类1外，再同时继承基类2，这种设计称之为Mixln。Mixln可以给一个类增加多个功能。只允许单一继承的语言（如java），不能使用Mixln的设计。 定制类 pytho的class中有很多类似于__slots__和__len__的函数，可以帮助定制我们类。下面是最常用的几个定制方法： 返回一个给用户看的字符串：__str__(self) 返回一个程序开发者看的字符串：__repr__(self)，其是为调试服务的。 返回一个迭代对象：__iter__(self)，可以作用于for循环 返回一个迭代对象：__getitem__(self,n),可以作用于list。其传入的参数可能是一个int，也可能是一个切片对象slice。 动态返回一个属性：__getattr__(self,属性名)，只有在没有找到属性的情况下才调用。 直接调用实例：__call__(self) 判断一个对象是否是可调用对象：callable(对象) 使用枚举类 定义一个class类型，其每一个常量都是class的一个唯一实例，枚举类（Enum类）便可以实现这个功能。Enum可以把一组相关常量定义在一个class中，且class不可变，其成员可以直接比较。 如下代码所示，可以直接使用Month.Jan.value来引用一个常量，或者枚举它是所有成员。 12345678910111213141516171819from enum import EnumMonth = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))print(Month.Jan.value)#for name,member in Month.__members__.items(): print(name,'=&gt;',member,',',member.value)#运行结果如下：1Jan =&gt; Month.Jan , 1Feb =&gt; Month.Feb , 2Mar =&gt; Month.Mar , 3Apr =&gt; Month.Apr , 4May =&gt; Month.May , 5Jun =&gt; Month.Jun , 6Jul =&gt; Month.Jul , 7Aug =&gt; Month.Aug , 8Sep =&gt; Month.Sep , 9Oct =&gt; Month.Oct , 10Nov =&gt; Month.Nov , 11Dec =&gt; Month.Dec , 12 value属性是自动赋给成员的int常量，默认从1开始计数。 练习题 把Student的gender属性改造为枚举类型，可以避免使用字符串： 1234567891011121314151617from enum import Enum, uniqueclass Gender(Enum): Male=Enum('Male',('Male','Female'))class Student(object): def __init__(self, name, gender): self.name = name self.gender = gender # 测试:bart = Student('Bart', Gender.Male)if bart.gender == Gender.Male: print('测试通过!')else: print('测试失败!')#运行结果如下：测试通过! 使用元类 type() 查看一个类型或变量的类型:type(类名,(基类1,基类2,...)，通过type()函数创建出的类，可将函数绑定到方法上。 例如通过type()函数创建出Hello类：Hello=type('Hello',(object,),dict(hello=fn))，把fn函数绑定到方法名hello上。 metaclass 正常创建实例的步骤是先定义类，然后根据这个类创建实例。若想先创建出类，可以通过元类(metaclass)创建，即先定义metaclass，然后创建类，最后创建实例。在编写ORM框架时，所有的类只能动态定义，此时才会用metaclass来修改类","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://tangmenjue.top/tags/python/"}]},{"title":"python学习笔记（六）","slug":"python学习笔记（六）","date":"2022-10-11T03:44:00.000Z","updated":"2022-10-22T15:27:32.314Z","comments":true,"path":"2022/10/11/python学习笔记（六）/","link":"","permalink":"http://tangmenjue.top/2022/10/11/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/","excerpt":"","text":"函数式编程 装饰器 若要增强某个函数的功能，使其在调用前后自动打印日志，但又不希望修改该函数的定义，这种在代码运行期间动态增加功能的方式，称为装饰器(Decorator)。在面向对象的设计模式中，decorator被称为装饰模式。 本质上，decorator就是一个返回函数的高级函数，因此定义一个能打印日志的decorator可以定义成： 12345def log(func): def wrapper(*args,**kw): print('call %s():'% func.__name__)#函数对象的__name__属性可以拿到函数的名字 return func(*args,**kw) return wrapper 由于上面的log是一个decorator，因此接收一个函数作为参数，并返回一个函数，故要借助Python的@语法。将decorator置于函数的定义处： 1234567@logdef now(): print('2022-10-11')now() #运行结果如下：call now():2022-10-11 调用now()函数时，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志。其中的@log语句在now()函数的定义出就相当于执行now=log(now)语句。由于log()是一个decorator，返回一个函数。因此调用now()将执行新函数，即在函数中返回wrapper()函数。在wrapper()函数内，首先打印日志，再调用原始函数。 若decorator本身需要传入参数，便需要编写一个返回decorator的高阶函数。 例如自定义log的文本： 123456789101112131415def log(text): def decorator(func): def wrapper(*args,**kw): print('%s %s():'% (text,func.__name__)) return func(*args,**kw) return wrapper return decorator #decorator用法如下:@log('execute')#即now=log('execute')(now)def now(): print('2022-10-11')now() #运行结果如下：execute now():2022-10-11 上述代码中执行log('execute')，返回的是decorator函数，再调用返回函数，参数是now函数，返回值最终是wrapper函数。此时now.__name__属性已经从原来的now变成了wrapper。因此需要把原始函数的__name__属性复制到wrapper函数中，即在定义wrapper()的前面加上@functools.wraps(func)，写法如下： 123456789101112131415161718import functoolsdef log(text): def decorator(func): @functools.wraps(func) def wrapper(*args,**kw): print('%s %s():'% (text,func.__name__)) return func(*args,**kw) return wrapper return decorator #decorator用法如下:@log('execute')#即now=log('execute')(now)def now(): print('2022-10-11')print(now.__name__) #运行结果如下：now 练习题 请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间： 代码如下： 12345678910111213141516171819202122232425262728import time, functoolsdef metric(fn): @functools.wraps(fn) def wrapper(*args,**kw): print('%s executed in %s ms' % (fn.__name__, 10.24)) return fn(*args,**kw) return wrapper# 测试@metricdef fast(x, y): time.sleep(0.0012) return x + y;@metricdef slow(x, y, z): time.sleep(0.1234) return x * y * z;f = fast(11, 22)s = slow(11, 22, 33)if f != 33: print('测试失败!')elif s != 7986: print('测试失败!')#运行结果如下：fast executed in 10.24 msslow executed in 10.24 ms 偏函数 偏函数可以通过设定参数的默认值，降低函数调用的难度。例如int()函数默认按十进制转换，也可以传入base参数做N进制的转换，如：int('123',base=8)。 创建一个偏函数可以用functools.partial，比如创建一个转换二进制的函数如下： 12345import functoolsint2=functools.partial(int,base=2)print(int2('1000000'))#运行结果如下：64 创建偏函数时，也可以接收函数对象、*args,**kw这三个参数。 模块 自己创建模块时要注意命名，不要使用中文、特殊字符，不能和python自带的模块名称冲突。检查系统是都已存在该模块的方法是先执行import abc，若成功则说明系统存在该模块。 导入模块：import 模块名称 使用模块 模块的使用涉及到作用域的概念。 作用域 类似于__xxx__这样的变量是特殊变量，可以被直接引用，但有特殊用途。类似于_xxx和__xxx的变量是私有的，不应被直接引用。 安装第三方模块 安装第三方模块需要添加模块搜索路径。 方法一：直接修改sys.path 12import syssys.path.append(&#39;&#x2F;路径名&#39;) 方法二：设置环境变量pythonpath 面向对象编程 类和实例 通过class关键字定义类，格式如下： 12class 类名(Object): #Object表示该类的基类是谁，默认使用Object类 pass 创建实例：变量=类名() 引用实例属性：指向实例的变量.属性名 通过__init__方法初始化实例，例子如下： 12345678class Student(object): def __init__(self,name,score): self.name=name self.score=scorebart=Student('zhangsan',56)print(bart.name,bart.score)#运行结果如下：zhangsan 56 __init__方法第一个参数永远是self，代表实例本身。有了__init__方法，在创建实例时不能传入空参数，必须传入与__init__方法匹配的参数，但self不需要传。 调用实例方法：指向实例的变量.方法名 访问限制 将public变量变成private变量：在属性名称前加两个下划线__。 只有一个下划线开头的实例变量名是protected变量。 外部函数访问私有变量方法：增加get_name和get_score方法。例如： 123456class Student(object): ... def get_name(self): return self.__name def get_score(self): return self.__score 外部函数修改私有变量方法:增加set_score方法。例如： 1234class Student(object): ... def set_score(self,score): self.__score=score 间接访问private属性的方法：指向实例的变量._类名_属性名，但由于不同版本的python解释器对变量的解析不同，这种操作尽量不要用。 类外代码定义的private变量与类内同名的变量不是同一个变量，类内的变量会被自动改成指向实例的变量._类名_属性名的形式，而外部代码只能新增一个__属性名变量。 练习题 请把下面的Student对象的gender字段对外隐藏起来，用get_gender()和set_gender()代替，并检查参数有效性： 1234567891011121314151617181920class Student(object): def __init__(self, name, gender): self.__name = name self.__gender = gender def get_gender(self): return self.__gender def set_gender(self,gender): self.__gender=gender# 测试:bart = Student('Bart', 'male')if bart.get_gender() != 'male': print('测试失败!')else: bart.set_gender('female') if bart.get_gender() != 'female': print('测试失败!') else: print('测试成功!')#运行结果如下：测试成功! 继承和多态 定义一个类时可以从某个现有的class继承，新的class称为子类，被继承的class称为基类、父类或超类。继承可以将基类的所有功能都直接拿过来，子类只需要新增特有的方法或重写父类的方法即可。 类继承的格式：class 子类名(基类名) 子类和基类存在相同方法时，子类的方法会覆盖基类的，代码运行时默认调用子类的方法，这一特性称之为多态。 开闭原则 对扩展开放：允许新增子类 对修改封闭：不需要修改依赖子类类型的函数。 静态语言 vs 动态语言 对于静态语言（如java），如果需要传入Animal的类型，则传入的对象必须是Animal类型或者是它的子类，否则将无法调用对应的run()方法。 对于动态语言（如python），则不一定需要传入Animal类型，只需要保证传入的对象有一个run()方法就可以了。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://tangmenjue.top/tags/python/"}]},{"title":"python学习笔记（五）","slug":"python学习笔记（五）","date":"2022-10-10T09:34:10.000Z","updated":"2022-12-06T12:23:46.571Z","comments":true,"path":"2022/10/10/python学习笔记（五）/","link":"","permalink":"http://tangmenjue.top/2022/10/10/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"","text":"高阶函数 变量可以指向函数，函数的参数也能接受变量。当一个函数可以接收另一个函数作为参数时，这个函数被称作高阶函数。 最简单的高阶函数如下： 12345def add(x,y,f): return f(x)+f(y)print(add(-5,6,abs)) #运行结果如下：11 map/reduce函数 map()函数 map()函数接收两个参数，一个是函数，另一个是Iterable，map将传入的函数依次作用到序列的每个元素，并将结果作为新的Iterable返回。 例如要将函数f(x)=x^2作用到一个list[1,2,3,4,5,6,7,8,9]上： 123456def f(x): return x*xr=map(f,[1,2,3,4,5,6,7,8,9])print(list(r))#运行结果如下：[1, 4, 9, 16, 25, 36, 49, 64, 81] reduce()函数 reduce()把函数作用到一个序列[x1,x2,x3,...]上，reduce接收两个函数后，把结果继续和序列的下一个元素做累计计算。 例如要对一个序列求和： 123456from functools import reducedef add(x,y): return x+yprint(reduce(add,[1,3,5,7,9]))#运行结果如下：25 将map()与reduce()函数结合，可以写出把str转换为int的函数： 123456789from functools import reducedef fn(x,y): return x*10+ydef char2num(s): d=&#123;'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9&#125; return d[s] print(reduce(fn,map(char2num,'14512')))#运行结果如下：14512 练习题 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']： 代码如下： 123456789def normalize(name): for i in name: return str.title(name)# 测试:L1 = ['adam', 'LISA', 'barT']L2 = list(map(normalize, L1))print(L2)#运行结果如下：['Adam', 'Lisa', 'Bart'] Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积： 12345678910111213from functools import reducedef prod(L): return reduce(fn,L)def fn(x,y): return x*yprint('3 * 5 * 7 * 9 =', prod([3, 5, 7, 9]))if prod([3, 5, 7, 9]) == 945: print('测试成功!')else: print('测试失败!')#运行结果如下：3 * 5 * 7 * 9 = 945测试成功! 利用map和reduce编写一个str2float函数，把字符串'123.456'转换成浮点数123.456： 12345678910111213141516171819202122232425262728293031323334353637383940#方法一：from functools import reducedef str2float(s): def fn(x,y): return x*10+y def gn(x,y): return x*0.1+y def char2num(t): d=&#123;str(x):x for x in range(10)&#125; return d[t] a=s.index('.') t1=s[:a] t2=s[a+1:] t2=t2[::-1] p=reduce(fn,map(char2num,t1)) q=reduce(gn,map(char2num,t2))*0.1 return p+q print('str2float(\\'123.456\\') =', str2float('123.456'))if abs(str2float('123.456') - 123.456) &lt; 0.00001: print('测试成功!')else: print('测试失败!') #方法二：from functools import reducedef str2float(s): d=&#123;str(x):x for x in range(10)&#125; p=reduce(lambda x,y:x*10+y,map(lambda s:d[s],s[:s.find('.')])) q=reduce(lambda x,y:x*10+y,map(lambda s:d[s],s[s.find('.')+1:]))*0.001 return p+qprint('str2float(\\'123.456\\') =', str2float('123.456'))if abs(str2float('123.456') - 123.456) &lt; 0.00001: print('测试成功!')else: print('测试失败!')#运行结果如下：str2float('123.456') = 123.456测试成功! filter函数 filter()函数用于过滤序列，该函数接收一个函数和一个序列。与map()不同的是，filter()把传入的函数依次作用于每个元素后，根据返回值是True还是False来决定是保留还是丢弃该元素。 例如在一个list中删掉偶数，只保留奇数： 12345def odd(n): return n%2==1print(list(filter(odd,[1,2,4,5,6,9,10,15])))#运行结果如下：[1, 5, 9, 15] filter()函数返回 的是一个Iterator，因此要强迫filter()完成计算结果就需要用list()函数来获得所以结果并返回list。 用filter求1000以内素数例子： 1234567891011121314151617181920def _odd_iter(): #先构造从3开始的奇数列 n = 1 while True: n = n + 2 yield ndef _not_divisible(n): #筛选函数 return lambda x: x % n &gt; 0 def primes(): yield 2 it = _odd_iter() # 初始序列 while True: n = next(it) # 返回序列的第一个数 yield n it = filter(_not_divisible(n), it) # 构造新序列 # 打印1000以内的素数:for n in primes(): if n &lt; 1000: print(n) else: break 练习题 回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数： 代码如下： 123456789101112def is_palindrome(n): return str(n)==str(n)[::-1]# 测试:output = filter(is_palindrome, range(1, 1000))print('1~1000:', list(output))if list(filter(is_palindrome, range(1, 200))) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]: print('测试成功!')else: print('测试失败!')#运行结果如下： 1~1000: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999]测试成功! sorted函数 sorted()可以对list进行排序，还可以接收一个key函数来实现自定义排序。 比如按绝对值大小排序： 123print(sorted([36,5,-12,9,-21],key=abs))#运行结果如下：[5, 9, -12, -21, 36] 默认情况下，用sorted()对字符串排序是按照ASCII的大小比较的，若要忽略大小写按照字母表排序，则可以写成： 1234567#正序排序print(sorted(['Bob','ant','Zoo','panda'],key=str.lower))#反序排序print(sorted(['Bob','ant','Zoo','panda'],key=str.lower,reverse=True))#运行结果如下：['ant', 'Bob', 'panda', 'Zoo']['Zoo', 'panda', 'Bob', 'ant'] 练习题 假设我们用一组tuple表示学生名字和成绩： 1L &#x3D; [(&#39;Bob&#39;, 75), (&#39;Adam&#39;, 92), (&#39;Bart&#39;, 66), (&#39;Lisa&#39;, 88)] 请用sorted()对上述列表分别按名字排序： 代码如下： 1234567L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]def by_name(t): return t[0].lower()L2 = sorted(L, key=by_name)print(L2)#运行结果如下：[('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)] 再按成绩从高到低排序： 12345678L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]def by_score(t): reverse=True return -t[1] L2 = sorted(L, key=by_score)print(L2)#运行结果如下：[('Adam', 92), ('Lisa', 88), ('Bob', 75), ('Bart', 66)] 返回函数 高阶函数除了可以接收函数作为参数外，还可以把函数作为结果值返回。 例如，实现一个可变参数的求和，根据需要计算结果： 12345678910111213def lazy_sum(*args): def sum(): a=0 for n in args: a=a+n return a return sumf=lazy_sum(1,2,3,4,5)print(f)print(f())#运行结果如下：&lt;function lazy_sum.&lt;locals&gt;.sum at 0x7f3aaacb9ca0&gt;15 在调用lazy_sum()函数时，返回的是求和函数而不是求和结果。调用函数f时才真正计算求和的结果。当调用lazy_sum()函数时，每次调用都会返回一个新的函数，即使传入相同参数，返回的函数也不会相同。 闭包 上面的例子中，内部函数sum可以引用外部函数lazy_sum()的参数和局部变量。当lazy_sum()返回函数sum时，相关参数和变量仍保存在返回的函数中。这种程序结构便称为闭包。 例如，在下面例子中f1(),f2()和f3()调用的结果应该是1,4,9，但实际结果是9 9 9。这便是由于返回函数引用了变量i，但它并非立刻执行，等到3个函数都返回时，所引用的变量已经变成了3，故最终结果为9。 1234567891011def count(): fn=[] for i in range(1,4): def f(): return i*i fn.append(f) return fnf1,f2,f3=count()print(f1(),f2(),f3())#运行结果如下：9 9 9 注意：返回函数不要引用任何循坏变量或后续会发生变化的变量。若一定要引用循环变量，便再创建一个函数，用该函数的参数绑定循环变量当前的值，具体操作如下： 12345678910111213def count(): def g(i): def f(): return i*i return f fn=[] for i in range(1,4): fn.append(g(i)) return fnf1,f2,f3=count()print(f1(),f2(),f3())#运行结果如下：1 4 9 nonlocal 使用闭包，就是内层函数引用了外层函数的局部变量。如果只读外层变量的值，返回的闭包函数调用一切正常，但对外层函数的局部变量进行运算就会报错。 若内层函数想要计算外层函数的局部变量，需要在内部函数内部加一个nonlocal 局部变量名的声明。因此在使用闭包时，对外层变量赋值前，需要使用nonlocal声明改变了不是当前函数的局部变量。 练习题 利用闭包返回一个计数器函数，每次调用它返回递增整数： 代码如下： 123456789101112131415161718def createCounter(): x=0 def counter(): nonlocal x x=x+1 return x return counter# 测试:counterA = createCounter()print(counterA(), counterA(), counterA(), counterA(), counterA()) # 1 2 3 4 5counterB = createCounter()if [counterB(), counterB(), counterB(), counterB()] == [1, 2, 3, 4]: print('测试通过!')else: print('测试失败!')#运行结果如下：1 2 3 4 5测试通过! 匿名函数 传入函数时，有时不需要显示定义函数，直接传入匿名函数更方便。如匿名函数lambda x:x*x实际上就是： 12def f(x): return x*x 匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。由于匿名函数没有名字，不必担心函数名冲突。匿名函数是一个函数对象，可以把匿名函数赋值给一个变量，再利用变量来调用该函数，也可以把匿名函数作为返回值返回。 练习题 请用匿名函数改造下面的代码： 12345def is_odd(n): return n % 2 == 1L = list(filter(is_odd, range(1, 20)))print(L) 代码如下： 123print(list(filter(lambda n:n % 2 == 1, range(1, 20))))#运行结果如下：[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://tangmenjue.top/tags/python/"}]},{"title":"python学习笔记（四）","slug":"python学习笔记（四）","date":"2022-10-10T04:47:51.000Z","updated":"2022-12-06T12:22:14.825Z","comments":true,"path":"2022/10/10/python学习笔记（四）/","link":"","permalink":"http://tangmenjue.top/2022/10/10/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"切片（Slice） 具体形式：L[0:3],其中L为list名称，0:3代表list的取值范围，与matlab中的数组取值类似。list、tuple、字符串可以用切片操作。 list切片 下面以一个list为例来说明切片的用法： 12345678910111213141516L=['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']print(L[0:3])#取前3个元素print(L[:3])#第一个索引是0可省略print(L[-2:])#取后2个元素print(L[-2:-1])#取倒数第2的元素print(L[0:4:2])#前4个数，每两个取一个print(L[::2])#所有数，每两个取一个print(L[:])#复制一个list#运行结果如下：['Michael', 'Sarah', 'Tracy']['Michael', 'Sarah', 'Tracy']['Bob', 'Jack']['Bob']['Michael', 'Tracy']['Michael', 'Tracy', 'Jack']['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack'] tuple切片 由于tuple也是一种list，因此tuple也可以用切片操作，其操作结果仍是tuple： 1234L=(0,1,2,3,4)print(L[:3])#运行结果如下：(0, 1, 2) 字符串切片 字符串也可以看成是一种list，因此，字符串也可以进行切片操作。 1234L='ZHANGSAN'print(L[:3])#运行结果如下：ZHA 练习题 利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法。 代码如下： 1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-def trim(s): n=0 m=len(s) for i in range(len(s)): if s[i]==' ': n=n+1 else: break for j in range(len(s)): if s[m-1]==' ': m=m-1 else: break return s[n:m]# 测试:if trim('hello ') != 'hello': print('测试失败!')elif trim(' hello') != 'hello': print('测试失败!')elif trim(' hello ') != 'hello': print('测试失败!')elif trim(' hello world ') != 'hello world': print('测试失败!')elif trim('') != '': print('测试失败!')elif trim(' ') != '': print('测试失败!')else: print('测试成功!')#运行结果如下：测试成功! 迭代 通过for循环来遍历list或tuple称为迭代。只要是可迭代对象，无论有无下标，都可以迭代。 迭代dict 默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()语句，如果要同时迭代key和value，可以用for k,v in d.items()语句。由于dict的存储不是按照list的方式顺序排列，因此迭代出的结果顺序很可能不一样。 1234567d=&#123;'a':1,'b':2,'c':3&#125;for key in d: print(key)#运行结果如下：abc 迭代字符串 字符串也是可迭代对象，也可以作用于for循环。 1234567d='abc'for key in d: print(key)#运行结果如下：abc 对list实现下标循环 通过enumerate函数把list变成索引-元素对，便可以在for循环中同时迭代索引和元素本身： 123456for i,value in enumerate(['A','B','C']): print(i,value)#运行结果如下：0 A1 B2 C 练习题 请使用迭代查找一个list中最小和最大值，并返回一个tuple。 代码如下： 12345678910111213141516171819202122232425# -*- coding: utf-8 -*-def findMinAndMax(L): minl=999 maxl=0 if L==[]: return (None, None) for i in L: if(minl&gt;int(i)): minl=i if(maxl&lt;int(i)): maxl=i return (minl, maxl)# 测试if findMinAndMax([]) != (None, None): print('测试失败!1')elif findMinAndMax([7]) != (7, 7): print('测试失败!')elif findMinAndMax([7, 1]) != (1, 7): print('测试失败!')elif findMinAndMax([7, 1, 3, 9, 5]) != (1, 9): print('测试失败!')else: print('测试成功!') #运行结果如下：测试成功! 列表生成式 使用列表生成式，可以通过一个list快速生成另一个list。 如要生成list[1,2,3,4,5,6,7,8,9]可用list(range(1,10))生成。 若要生成[1x2,2x2,3x3,...,10x10]可用[x*x for x in range(1,11)]生成。 写列表生成式时，要把生成的元素放到前面，后面再跟for循环，for循环后可以加上if判断，也可以使用两层循环： 1234567L=[x*x for x in range(1,11) if x%2==0]print(L)T=[m+n for m in 'ABC' for n in 'XYZ']print(T)#运行结果如下：[4, 16, 36, 64, 100]['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] for循环可以同时使用两个或多个变量，如dict的items可以同时迭代key和value： 1234567d=&#123;'x':1,'y':2,'z':3&#125;for k,v in d.items(): print(k,'=',v)#运行结果如下：x = 1y = 2z = 3 因此列表生成式也可以使用两个变量来生产list： 12345d=&#123;'x':'1','y':'2','z':'3'&#125;L=[k+'='+v for k,v in d.items()]print(L)#运行结果如下：['x=1', 'y=2', 'z=3'] 注意：这里的value只能为str类型，由于非字符串类型没有lower()方法，所以列表生成式会报错。可以使用isinstance函数来判断一个变量a是不是字符串，具体形式为isinstance(a,str)。 if...else 在使用列表生成式时，不能在最后的if加上else。这是因为跟在for后面的if是一个筛选条件，不能带else。而把if写在for前面必须加else，否则会报错。这是因为for前面的部分是一个表达式，其必须要计算出一个结果。 练习题 请修改列表生成式，通过添加if语句保证列表生成式能正确地执行。 代码如下： 123456789101112# -*- coding: utf-8 -*-L1 = ['Hello', 'World', 18, 'Apple', None]L2 = [k.lower() for k in L1 if isinstance(k,str)==True]# 测试:print(L2)if L2 == ['hello', 'world', 'apple']: print('测试通过!')else: print('测试失败!')#运行结果如下：['hello', 'world', 'apple']测试通过! 生成器 在循环过程中不断推算出后续元素，故不必创建完整list，从而节省大量空间的机制，称为生成器（generator）。 创建生成器:将列表生成式的[]改成() 1234567L=[x*x for x in range(10)]print(L)g=(x*x for x in range(10))print(g)#运行结果如下：[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&lt;generator object &lt;genexpr&gt; at 0x7ff38be35ac0&gt; 打印生成器的元素 方法一： 通过next()函数单个打印生成器中的元素，具体形式如下：next(g) 方法二： 使用for循环打印，具体形式如下： 1234567891011121314g = (x * x for x in range (10))for i in g: print(i) #运行结果如下：0149162536496481 如果生成器推算的算法比较复杂，用类型列表生成式的for循环无法实现时，还可以用函数来实现。比如打印斐波拉契数列： 12345678910def fib(max): n,a,b=0,0,1 while n&lt;max: yield b a,b=b,a+b#相当于t=(b,a+b),t是一个tuple,a=t[0],b=t[1] n=n+1 return 'done' print(fib(6)) #运行结果如下：&lt;generator object fib at 0x7f99e1f3dac0&gt; 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator函数，调用一个generator函数将返回一个generator。变成generator的函数在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 例如，定义一个generator函数，依次返回数字1,3,5： 123456789101112131415def odd(): print('step 1') yield 1 print('step 2') yield(3) print('step 3') yield(5)o=odd()next(o)next(o)next(o)#运行结果如下：step 1step 2step 3 而每次调用next(odd())时，每次都会返回1.这是由于odd()会创建一个新的generator对象，每次调用next(odd())就创建一个完全独立的generator。 在斐波那契数列的例子中，在循环里不断调用yield，就会不断中断程序，此时需要给循环设置一个条件来退出循环，不然就会产生一个无限的数列， 把函数改成generator函数后，基本上不会用next()来获取下一个返回值，而是直接用for循环来迭代： 12345678910111213141516def fib(max): n,a,b=0,0,1 while n&lt;max: yield b a,b=b,a+b#相当于t=(b,a+b),t是一个tuple,a=t[0],b=t[1] n=n+1 return 'done' for n in fib(6): print(n) #运行结果如下：112358 用for循环调用generator时，是拿不到generator的return语句的返回值，若想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中： 1234567891011121314151617181920212223def fib(max): n,a,b=0,0,1 while n&lt;max: yield b a,b=b,a+b#相当于t=(b,a+b),t是一个tuple,a=t[0],b=t[1] n=n+1 return 'done' g=fib(6)while True: try: x=next(g) print('g:',x) except StopIteration as e: print('Generator return value:',e.value) break#运行结果如下：g: 1g: 1g: 2g: 3g: 5g: 8Generator return value: done 练习题 杨辉三角定义如下： 1234567891011 1 &#x2F; \\ 1 1 &#x2F; \\ &#x2F; \\ 1 2 1 &#x2F; \\ &#x2F; \\ &#x2F; \\ 1 3 3 1 &#x2F; \\ &#x2F; \\ &#x2F; \\ &#x2F; \\ 1 4 6 4 1 &#x2F; \\ &#x2F; \\ &#x2F; \\ &#x2F; \\ &#x2F; \\1 5 10 10 5 1 把每一行看做一个list，试写一个generator，不断输出下一行的list。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# -*- coding: utf-8 -*-def triangles(): L=[1] while True: yield L L=[1]+[L[n]+L[n-1] for n in range(1,len(L))]+[1]# 期待输出:# [1]# [1, 1]# [1, 2, 1]# [1, 3, 3, 1]# [1, 4, 6, 4, 1]# [1, 5, 10, 10, 5, 1]# [1, 6, 15, 20, 15, 6, 1]# [1, 7, 21, 35, 35, 21, 7, 1]# [1, 8, 28, 56, 70, 56, 28, 8, 1]# [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]n = 0results = []for t in triangles(): results.append(t) n = n + 1 if n == 10: breakfor t in results: print(t)if results == [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]]: print('测试通过!')else: print('测试失败!')#运行结果如下：[1][1, 1][1, 2, 1][1, 3, 3, 1][1, 4, 6, 4, 1][1, 5, 10, 10, 5, 1][1, 6, 15, 20, 15, 6, 1][1, 7, 21, 35, 35, 21, 7, 1][1, 8, 28, 56, 70, 56, 28, 8, 1][1, 9, 36, 84, 126, 126, 84, 36, 9, 1]测试通过! 迭代器 可以直接作用于for循环的对象统称为可迭代对象Iterable。 判断一个对象是可迭代对象 可通过collections.abc模块的Iterable类型判断。 12345678910from collections.abc import Iterableprint(isinstance('abc',Iterable))#字符串是否可迭代print(isinstance([1,2.3],Iterable))#list是否可迭代print(isinstance(([1,2,3]),Iterable))#set是否可迭代print(isinstance(123,Iterable))#整数是否可迭代#运行结果如下：TrueTrueTrueFalse 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。这是因为Iterator的对象表示的是一个 数据流，可以把这个数据流看作是一个未知长度的有序序列，Iterator甚至可以表示一个无限大的数据流，例如全体自然数。 把list、dict、str从Iterable变成Iterator 可以使用iter()函数把list、dict、str从Iterable变成Iterator，其表现形式为：isinstance(iter([]),Iterator)，其中，[]可替换为dict、str的形式。 小结 可作用于for循环的对象都是Iterable类型。 可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列。 list、dict、str虽然是Iterable，却不是Iterator。但可以使用iter()函数把list、dict、str从Iterable变成Iterator","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://tangmenjue.top/tags/python/"}]},{"title":"python学习笔记（三）","slug":"python学习笔记（三）","date":"2022-10-09T08:01:44.000Z","updated":"2022-10-31T13:29:48.645Z","comments":true,"path":"2022/10/09/python学习笔记（三）/","link":"","permalink":"http://tangmenjue.top/2022/10/09/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"函数 python内置函数 绝对值：abs() 平方根：sqrt() 平方：power() 将整数转换为‘0x’前缀的十六进制字符串：hex() 将整数转换为‘0o’前缀的八进制字符串：oct() 数据类型转换函数：int()、float()、str()、bool() 导包：import 包名 练习题 请利用Python内置的hex()函数把一个整数转换成十六进制表示的字符串： 12345# -*- coding: utf-8 -*-n1 = 255n2 = 1000print(str(hex(n1)))print(str(hex(n2))) 定义函数 用def语句定义函数 如自定义一个abs函数并检验函数功能，其代码如下： 1234567def my_abs(x): if x&gt;=0: return x else: return -xx=int(input())print(my_abs(x)) 在python交互环境中定义函数时，python会出现...的提示，函数定义结束后需要按两次回车使其重新回到&gt;&gt;&gt;提示符下，如下图所示： 空函数 定义一个空函数，用pass语句来作为占位符。 12def my_max(): pass 参数检查 如果要函数参数传入类型不对时需要抛出参数错误的信息，可用内置函数isinstance()检查参数，如if not isinstance(x,(int,float))语句，若传入了整数与浮点数之外的参数类型，函数就会抛出一个错误来提醒传参不对。 函数返回 函数体内部用return返回函数结果 函数执行完毕也没有return语句时，自动return None。 函数的return可以返回多个值，值之间用半角逗号隔开，如return a,b 注意python返回值实际上是返回一个tuple，并非是返回两个值，比如以下代码： 12345678910def move(x,y): return x+50,y+20x=int(input())y=int(input())t=move(x,y)print(t)、#运行结果如下50100(100, 120) 练习题 请定义一个函数quadratic(a, b, c)，接收3个参数，返回一元二次方程 \\[ ax^2+bx+c=0 \\] 的两个解。 提示： 计算平方根可以调用math.sqrt()函数： 代码如下： 1234567891011121314151617181920212223# -*- coding: utf-8 -*-import mathdef quadratic(a,b,c): t=math.sqrt(float(b*b-4*a*c)) p=(-b+t)/(2*a) q=(-b-t)/(2*a) return p,qprint('quadratic(2, 3, 1) =', quadratic(2, 3, 1))print('quadratic(1, 3, -4) =', quadratic(1, 3, -4))if quadratic(2, 3, 1) != (-0.5, -1.0): print('测试失败')elif quadratic(1, 3, -4) != (1.0, -4.0): print('测试失败')else: print('测试成功')#运行结果如下 quadratic(2, 3, 1) = (-0.5, -1.0)quadratic(1, 3, -4) = (1.0, -4.0)测试成功 默认参数 自定义函数可以设置默认参数。如次方函数可以设为默认平方，需要计算其他次方的时候再传次方的参数。代码如下所示： 123456789101112131415def my_power(x,n=2): t=1 while(n&gt;0): n=n-1 t=x*t return tx=int(input())n=int(input())print(my_power(x))print(my_power(x,n))#运行结果如下34981 注意： 设置默认参数时。必选参数在前，默认参数在后 当函数有多个参数时，变化大的参数放前面，变化小的参数可以作为默认参数 默认参数必须指向不变对象 可变参数 传入的参数个数是可变的称为可变参数，形式为*参数名。 可变参数允许传入0个或任意个参数，这些参数在函数调用时自动组装为一个tuple。 在参数个数不确定时，定义可变参数和定义一个list和tuple参数相比，区别在于仅在参数前加了个*号，而在函数内部，参数接收到的是一个tuple，函数代码是完全不用变的。此时调用函数时可传入任意个参数calc(1,2)也可以传入0个参数clac()。 将list或tuple元素变成可变参数传进函数中，可写成： 12nums=[1,2,3]calc(*nums) 关键字参数 关键字参数允许传入0个或任意个含参数名的参数，这些参数在函数内部自动组装为一个dict,形式为**参数名。 关键字参数可以拓展函数的功能，如下所示： 123456789def person(name,age,**kw): print('name:',name,'age:',age,'other:',kw)person('Lisi',34)person('Zhangsan',44,city='Shanghai')person('Wangwu',23,gender='M',job='teacher')#运行结果如下name: Lisi age: 34 other: &#123;&#125;name: Zhangsan age: 44 other: &#123;'city': 'Shanghai'&#125;name: Wangwu age: 23 other: &#123;'gender': 'M', 'job': 'teacher'&#125; 将dict元素变成可变参数传进函数中，可写成： 123456def person(name,age,**kw): print('name:',name,'age:',age,'other:',kw)extra=&#123;'city':'Shanghai','job':'teacher'&#125;person('Wangwu',23,**extra)#运行结果如下name: Wangwu age: 23 other: &#123;'city': 'Shanghai', 'job': 'teacher'&#125; 命名关键字参数 若要限制关键字参数名字，只接收特定的参数可以用命名关键字参数，形式为*,限制参数名。命名关键字参数可以设置默认值，调用函数时必须传入参数名。 函数定义如下，则表示只接收city和job作为关键字参数： 12def person(name,age,*,city,job): print(name,age,city,job) 若函数定义中已经有一个可变参数，后面跟着的命名关键字参数就不需要特殊分隔符*了 12def person(name,age,*args,city,job): print(name,age,args,city,job) 参数组合 定义函数可以使用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，5种参数之间可以组合使用，但参数定义的顺序必须为：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 1234def f1(a, b, c=0, *args, **kw): print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)def f2(a, b, c=0, *, d, **kw): print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw) 练习题 以下函数允许计算两个数的乘积，请稍加改造，变成可接收一个或多个数并计算乘积： 12345678910111213141516171819202122232425262728293031# -*- coding: utf-8 -*-def mul(x, *y): for i in y: x=i*x return x # 测试print('mul(5) =', mul(5))print('mul(5, 6) =', mul(5, 6))print('mul(5, 6, 7) =', mul(5, 6, 7))print('mul(5, 6, 7, 9) =', mul(5, 6, 7, 9))if mul(5) != 5: print('测试失败!')elif mul(5, 6) != 30: print('测试失败!')elif mul(5, 6, 7) != 210: print('测试失败!')elif mul(5, 6, 7, 9) != 1890: print('测试失败!')else: try: mul() print('测试失败!') except TypeError: print('测试成功!')#运行结果如下mul(5) = 5mul(5, 6) = 30mul(5, 6, 7) = 210mul(5, 6, 7, 9) = 1890测试成功! 递归函数 递归函数优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出 练习题 汉诺塔的移动可以用递归函数非常简单地实现。 请编写move(n, a, b, c)函数，它接收参数n，表示3个柱子A、B、C中第1个柱子A的盘子数量，然后打印出把所有盘子从A借助B移动到C的方法。 代码如下： 1234567891011121314151617181920212223242526# 期待输出:# A --&gt; C# A --&gt; B# C --&gt; B# A --&gt; C# B --&gt; A# B --&gt; C# A --&gt; C# -*- coding: utf-8 -*-import mathdef move(n, a, b, c): if n == 1: print(a, '--&gt;', c) else: move(n-1,a,c,b) print(a,'--&gt;',c) move(n-1,b,a,c)move(3, 'A', 'B', 'C')#运行结果如下：A --&gt; CA --&gt; BC --&gt; BA --&gt; CB --&gt; AB --&gt; CA --&gt; C","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://tangmenjue.top/tags/python/"}]},{"title":"python学习笔记（二）","slug":"python学习笔记（二）","date":"2022-10-09T04:24:12.000Z","updated":"2022-10-22T15:15:47.737Z","comments":true,"path":"2022/10/09/python学习笔记（二）/","link":"","permalink":"http://tangmenjue.top/2022/10/09/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"条件判断 方法一：if...else语句 1234if &lt;条件1&gt;: &lt;执行1&gt;else &lt;执行2&gt; 方法二：if ...elif...else语句 123456if &lt;条件1&gt;: &lt;执行1&gt;elif &lt;条件2&gt;: &lt;执行2&gt;else: &lt;执行3&gt; input条件输出 input()返回值的数据类型是str，str不能直接与整数比较，若要与整数比较，要先把str转换为整数类型，如下代码所示： 123456s = input('birth: ')birth = int(s)if birth &lt; 2000: print('00前')else: print('00后') 若输入值不为数字时，如输入abc，则条件语句可写成： 12345s=input('birth:')if s!='zero': print('00前')else: print('00后') 练习题 小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数： 低于18.5：过轻 18.5-25：正常 25-28：过重 28-32：肥胖 高于32：严重肥胖 用if-elif判断并打印结果： 代码如下： 12345678910111213# -*- coding: utf-8 -*-height = 1.75weight = 80.5bmi = weight/(height*height)if bmi&lt;18.5: print('过轻')elif 18.5&lt;=bmi&lt;25: print('正常')elif 25&lt;=bmi&lt;28: print('肥胖')else: print('严重肥胖') 循环 方法一：for...in循环 例如计算1-100的整数之和： 1234t=0for i in range(101)： t=t+iprint(t) 方法二：while 循环 例如计算100以内所有奇数之和： 123456t=0n=99while n&gt;0: t=t+n n=n-2print(t) 练习题 请利用循环依次对list中的每个名字打印出Hello, xxx!： 1234# -*- coding: utf-8 -*-L = ['Bart', 'Lisa', 'Adam']for i in L: print('Hello,'+i+'!') break与continue break语句可提前退出循环，continue语句可跳过当前这次循环，直接开始下一次循环。 字典dict 字典使用键-值存储，具有极快的查找速度。dict内部存放的顺序与key的放入顺序无关。为保证哈希的正确性，dict的key必须是不可变对象，如list是可变的，不能作为key，dict的key不能重复。 与list相比，dict的特点为： 查找和插入的速度极快，不会随key的增加而变慢 需要占用大量内存 形式如下： 12d=&#123;'Zhangsan':92,'Lisi':80,'Wangwu':56&#125;print(d['Lisi']) 通过key将数据放入dict 如把key为Lisi、value为68的数据放入dict：d['Lisi']=68 注意：多次对一个key放入value，后面的值会把前面的值冲掉,如此时Lisi的value值由80变成了68。 删除一个key 如要删除Lisi，其对应的value也会从dict中删除：d.pop('Lisi') 避免key不存在的错误 方法一： 通过in判断key是否存在：'Jack' in d 方法二： 通过get()方法判断key是否存在，若key不存在，默认返回Nome：d.get('Jack') 通过get()方法判断key是否存在，若key不存在，返回指定的value：d.get('Jack',-1) 集合set set与dict类似，也是一组key的集合，但不存储value。与dict相同，key不能重复，故在set中没有重复的key，也同样不能放入可变对象。此外，set也可看成数学意义上无序和无重复元素的集合。 创建一个set，需要提供一个list作为输入集合，其形式如下： 1234s=set([1,2,3])print(s)&gt;&gt;&gt;s&#123;1,2,3&#125; 注意：传入的参数是一个list，而显示的{1,2,3}只是说明set内部有1，2，3这3个元素，显示的顺序也不代表set就是有序的。 重复元素在set中自动被过滤 如下面所示： 12345s=set([1,1,2,2,3,3])print(s)#运行结果如下s&#123;1, 2, 3&#125; 通过add(key)方法将元素添加到set中 如在set中先后两次添加元素4： 12345678s=set([1,2,3])s.add(4)print(s)s.add(4)print(s)#运行结果如下&#123;1, 2, 3, 4&#125;&#123;1, 2, 3, 4&#125; 可以看到，元素可以重复添加，但会被set自动过滤掉重复的元素。 通过remove(key)方法删除元素 如删除元素4： 1234s=set([1,2,3,4])s.remove(4)print(s)&gt;&gt;&gt;&#123;1, 2, 3&#125; 两个set可以做交集、并集等操作 1234567s=set([1,2,3,4])d=set([3,4,5,6])print(s&amp;d)print(s|d)#运行结果如下&#123;3, 4&#125;&#123;1, 2, 3, 4, 5, 6&#125; 小结 list、tuple是有序可重复的 dict、set是无序不可重复的 四者形式上的区别： 1234list=[value,value]tuple=(value,value)dict=&#123;key:value,key:value&#125;set=([key,key])","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://tangmenjue.top/tags/python/"}]},{"title":"python学习笔记（一）","slug":"python学习笔记（一）","date":"2022-10-08T08:55:26.000Z","updated":"2022-12-06T12:21:05.328Z","comments":true,"path":"2022/10/08/python学习笔记（一）/","link":"","permalink":"http://tangmenjue.top/2022/10/08/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"基本语句 输入：input() 输出：print() 注释：# 字符串类型：str 空值用None表示多行输入：'''...''' 内部字符默认不转义：r'''...''' 获取字符的整数表示：ord() 将字符编码转化为字符：chr() bytes类型用带b前缀的单引号或双引号表示：b'字符' 将str类型数据转为指定的bytesr类型数据：'字符'.encode('原编码类型') 示例语句如下： print('a'.encode('ascii')) 注意：python是4个空格缩进的，区分大小写。 含有中文的str类型无法用ASCII编码，在bytes中无法显示ASCII字符的字节，会以##代替显示 将bytesr类型数据转为str类型数据：b'字符'.decode('str的编码类型') 示例语句如下： print(b'a'.decode('ascii')) 注意：若bytes中只有一小部分无效的字节，可用errors='ignore'语句忽略错误的字节。 计算str的字符数：len() 将源代码按UTF-8编码保存： 123#!/usr/bin/env python3# -*- coding: utf-8 -*- 申明UTF-8编码外，必须还要确保文本编辑器正在使用UTF-8 without BOM编码 格式化字符串的三种方法 占位符格式化字符串： 输出整形数据的语句：print('%d' % 123) 输出小数点后2位数的语句：print('%.2f' % 3.1415926) format()格式化字符串 例子如下： 12print('''&#123;0&#125;在考试中提升了&#123;1:.2f&#125;%,&#123;2&#125;在考试中提升了&#123;3:.2f&#125;%'''.format('张三',2.354,'李四',0.458)) 用f-string格式化字符串 例子如下： 123456a='张三'b=2.354c='李四'd=0.458print(f'''&#123;a&#125;在考试中提升了&#123;b:.2f&#125;%,&#123;c&#125;在考试中提升了&#123;d:.2f&#125;%''') 练习题 小明的成绩从去年的72分提升到了今年的85分，请计算小明成绩提升的百分点，并用字符串格式化显示出xx.x%，只保留小数点后1位： 代码如下： 1234567# -*- coding utf-8 -*-s1=72s2=85r=(s2-s1)/s1*100print('%.1f%%'%r)print('&#123;0:0.1f&#125;%'.format(r))print(f'&#123;r:0.1f&#125;%') 列表list和元组tuple 列表list list是一种有序的集合，可随时增减其中的元素。 形式如同 name=['Zhangsan','Lisi','Wangwu']，指的是定义一个name列表，name为该列表的名称，与C语言中的数组相似，其区别在于list中的元素数据类型可以不同，元素可以是另一个list。 定义一个空列表，其列表名称为name：name() 获取列表中元素的个数 如获取name列表元素的个数：len(name) 使用索引获取列表中的最后一个元素 如获取name列表中的最后一个元素：name[-1] 在列表末尾增加元素 如在name列表末尾追加元素Bob：name.append('Bob') 将元素插入到列表中的指定位置 如将元素Jack插入到name列表指定的位置，如索引号为1的位置：name.insert(1,Jack) 删除列表末尾的元素 如删除name列表末尾的元素：name.pop() 删除列表指定位置的元素 如删除name列表中索引号为1的元素：name.pop(1) 替换列表中指定位置的元素 如将name列表中索引号为1的元素换成Xiaoming：name[1]='Xiaoming' 列表中的元素包含另一个list时，若想要取内嵌list元素的值，可将list看做二维数组来进行取值，如下面取s列表中php的值，可写成： 12s=['python','java',['asp', 'php'],'scheme']print(s[2][1]) 元组tuple tuple是一种有序的列表，元组一旦初始化就不能修改，tuple一旦被定义，其元素就必须要确定下来。 形式如同name=（'Zhangsan','Lisi','Wangwu')，指的是定义一个name元组，name为该元组的名称，与list类似，但tuple没有append()、insert()这类的方法，获取元素的方法与list相同，但不能给元素赋值。 定义空的tuple 如定义空元组name：name=() 定义只有1个元素的tuple 如定义只有1个元素的元组name：name=(1,) 注意：将只有1个元素的tuple若误写成name=(1)，该语句定义的不是元组tuple类型，其实际是指1经过数学小括号运算后，将结果赋给name。 当元组的元素中含有列表时，可以改变元组中的列表元素，此时元组是“可变的”，但其本质上元组没变，改变的是列表。如下列代码改变的是列表中元素的值： 1234name=('Zhangsan','Lisi',['A','B'])name[2][0]='X'name[2][1]='Y'print(name) 此时元组name中的元素变成了('Zhangsan', 'Lisi', ['X', 'Y'])，改变的仅是列表中的元素。 练习题 请用索引取出下面list的指定元素： 1234567# -*- coding: utf-8 -*-L = [ ['Apple', 'Google', 'Microsoft'], ['Java', 'Python', 'Ruby', 'PHP'], ['Adam', 'Bart', 'Lisa']] 代码如下： 123456# 打印Apple:print(L[0][0])# 打印Python:print(L[1][1])# 打印Lisa:print(L[2][2])","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://tangmenjue.top/tags/python/"}]},{"title":"结构性思维笔记","slug":"结构性思维笔记","date":"2022-08-07T12:23:28.000Z","updated":"2022-10-27T13:27:50.143Z","comments":true,"path":"2022/08/07/结构性思维笔记/","link":"","permalink":"http://tangmenjue.top/2022/08/07/%E7%BB%93%E6%9E%84%E6%80%A7%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0/","excerpt":"","text":"结构性思维笔记 以思维导图的格式记录结构性思维课程的笔记，顺便练习一下Markdown的无序列表语法。 思维导图 笔记内容 课程导入 结构与思维的力量 结构的定义:组成整体的各部分的搭配和安排 结构性思维的训练目的:想清楚、说明白 两个核心训练原则 利他性原则 从TA的角度思考表达（即随时发问\"我讲明白了吗？\"） TA决定我是否清楚结构 讲理性原则 从感性到理性 从隐性到显性 构建结构性思维 结构性思维的四个基本特点 结论先行 时间紧 他需要 信息多 上下对应 分类清晰 排列逻辑 结构性思维接收信息 不带任何主观色彩的去接收别人信息的传递 第一步:识别 识别信息中的事实与个人观念或判断 第二步:对应 找到事实与观点之间的对应关系 第三步:结构 画出结构性关系图 第四步:表达 用语言表达信息的主要含义 纵向的问答/概括式结构 自上而下的疑问回答式 第一步:设定场景 第二步:确定主题 第三步:设想问题 第四步:回答问题 要问到多深？ 最后回答中都是公理、定理为止 要问到多宽？ 直到主题句中所有关键词都被问到 自下而上的概括总结式 找到论点中的共性，所概括出来的主题需要囊括所有论点的观点 横向的演绎与归纳逻辑结构 演绎论证结构（从一般到特殊） 演绎论证的定义 从普遍性的理论知识出发，去认识个别的、特殊的现象的一种论证推理方法 演绎的两种形式 标准式 三段论 大前提→小前提→结论 常见式 现象→原因→解决方案 归纳论证结构（从特殊到一般） 归纳论证的定义 从许多个别的事物中概括出一般性概念、原则或结论的推理方法 排序的三种形式 时间顺序 时间的先后顺序，事件彼此可能存在因果，可能不 存在因果 结构性顺序 将整体分为部分，例如顺时针、从上到下等 重要性顺序 将事物按重要性或非重要性分组 分类的MECE原则 MECE原则 相互独立 完全穷尽 互不交叉 应有尽有 不重不漏 分清分净 MECE原则使用前提 界定范围 明确标准 常见分类 二分法 如内外;左右;男女;收支;专业和业余 过程法 如日程表，解决问题的6个步骤，达成目标的3个阶段 要素法 优秀员工的7种品质，公司的组织架构图 公式法 销售额＝单价*数量 矩阵法 重要紧急象限图;swot分析 市场战略3C模型 公司、顾客、竞争对手 市场营销决策4P模型 产品、价格、渠道、促销 目标制定的SMART原则 S:具体的 M:可衡量的 A:可达成的 R:相关的 T:可实现的 序言的讲故事结构 序言结构的基本要素 S:背景 C:冲突 Q:疑问 A:回答 常见的序言模式 标准式 S→C→Q→A 开门见山式 A→S→C 突出忧虑式 C→S→Q→A 突出信心式 Q→S→C→A","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"结构性思维","slug":"结构性思维","permalink":"http://tangmenjue.top/tags/%E7%BB%93%E6%9E%84%E6%80%A7%E6%80%9D%E7%BB%B4/"}]},{"title":"设计模式的学习（一）","slug":"设计模式的学习（一）","date":"2022-07-27T14:40:34.000Z","updated":"2022-10-14T15:53:49.073Z","comments":true,"path":"2022/07/27/设计模式的学习（一）/","link":"","permalink":"http://tangmenjue.top/2022/07/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"设计模式 设计模式为软件开发人员在开发过程中面临一般问题时的解决方案，共有33种，可将其分为四大类：创建型模式、结构型模式、行为型模式和J2EE模式。 创建型模式 创建型模式致力于将对象的创建与使用分离，着重于如何创建对象。 该分类下的设计模式有5种：工厂模式、抽象工厂模式、单例模式、建造者模式和原型模式。 结构型模式 结构型模式关注于类的继承和组合，着重于简化结构并识别类与对象之间的关系。 该分类下的设计模式有8种：适配器模式、桥接模式、过滤器模式、组合模式、装饰器模式、外观模式、享元模式和代理模式。 行为型模式 行为型模式关注于对象之间的交互以及彼此之间的响应性，着重于算法与对象间的职责分配。 该分类下的设计模式有12种：责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、空对象模式、策略模式、模板模式和访问者模式。 J2EE模式 J2EE模式是为了开发基于Web的企业引用程序而构建的，特别关注表示层。 该分类下的设计模式有8种：MVC模式、业务代表模式、组合实体模式、数据访问对象模式、前端控制器模式、拦截过滤器模式、服务定位器模式和传输对象模式。 设计模式的六大原则（SOLID） 单一职责原则（Single Responsibility Principle） 不要存在多于一个导致类变更的原因。即每个类都应只实现单一的职责。 开放封闭原则（Open Closed Principle） 对扩展开放，对修改关闭。即在程序需要进行扩展时，不能去修改原有的代码，而是去扩展原有的代码。该原则的关键步骤是将代码抽象化。 里氏代换原则（Liskov Substitution Principle） 任何基类可以出现的地方，子类一定可以出现。该原则是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。 该原则作为面向对象设计的基本原则之一，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。 迪米特原则，又称最少知道原则(Law of Demeter) 一个类对自己依赖的类知道的越少越好。即无论被依赖的类复杂度有多高，都应将其逻辑封装在方法的内部后，在通过public方法提供给外部。使得当被依赖的类变化时，该类受到的影响最小。 接口隔离原则（Interface Segregation Principle） 每个接口不应存在子类用不到却必须实现的方法，若存在这种情况，应将接口拆分。为降低类之间的耦合度，使用多个隔离的接口比只使用单个接口要好。 依赖倒置原则（Dependence Inversion Principle） 针对接口编程，依赖于抽象而不依赖于具体。即用到具体类时，不与具体类交互，而与该具体类的上层接口交互。 该原则是开闭原则的基础。 本文中主要讲解最常用的设计模式之一：策略模式。 策略模式 策略模式定义了一系列的算法，并将每个算法都封装了起来，使得算法之间可以相互替换，且算法的改变不会影响使用算法的用户。策略模式属于对象行为型模式，其通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。 策略模式的优点 1、可避免使用多重条件语句，如多个if...else条件分支、switch...case语句。 2、提供了一系列可供重用的算法组，适当使用继承可以将算法族的公共代码转移到父类里，从而避免重复的代码。 3、可提供相同行为的不同实现，用户可根据不同时间或空间选择不同的实现方式。 4、可在不修改源代码的前提下，灵活增加新算法。 5、将算法的使用放到环境类中，算法的实现移到具体策略类中，实现了二者的分离。 策略模式的缺点 1、客户端必须理解所有策略算法的区别，以便于选择恰当的算法类。 2、策略类较多时，维护难度较大。 策略模式的使用举例 例如这是伪代码优化前的大致逻辑，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041class Person&#123; int worknum;//工号 int age;//年龄 int reqNum;//查询数量&#125;//如果是学生类型boolean isStudent(Person pto)&#123; if(pto.type == 'student')&#123; //开关关闭不请求 if(isstudentSwitchClose)&#123; return false; &#125; //请求只有一条记录 if(pto.reqNum==1)&#123; return singleRemoteEOIinvoke(pto);//调用学生数据的点查接口 //请求超过一条 &#125;else if(pto.reqNum&gt;1)&#123; return batchRemoteEOIinvoke(pto);//调用学生数据的批量接口 &#125; //如果是教师类型 &#125;else if(pto.type=='teacher')&#123; //开关关闭不请求 if(isteacherSwitchClose)&#123; return false; &#125; //请求只有一条记录 if(pto.reqNum==1)&#123; return singleRemoteMarketinvoke(pto);//调用教师数据的点查接口 //请求超过一条 &#125;else if(pto.reqNum&gt;1)&#123; return batchRemoteMarketinvoke(pto);//调用教师数据的批量接口 &#125; &#125;&#125; 例子中的代码存在较多的if分支，若使用策略模式来优化，代码将变成下面这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061interface GroupLabel &#123; boolean processBiz(Person pto);//该方法对应策略实现类的具体实现 String getType();//该方法是策略类的类型，对应着```if...else```条件判断的类型&#125; //学生类型的策略实现类studentGroupLablel implements GroupLabel&#123; //对应学生类型的条件分支里的实现 boolean processBiz(Person pto)&#123; //开关关闭不请求 if(isstudentSwitchClose)&#123; return false; &#125; //请求只有一条记录 if(pto.reqNum==1)&#123; return singleRemoteEOIinvoke(pto);//调用学生数据点查接口 //请求超过一条 &#125;else if(pto.reqNum&gt;1)&#123; return batchRemoteEOIinvoke(pto);//调用远程大数据批量接口 &#125; &#125; //对应学生类型 String getType()&#123; return \"student\"; &#125;&#125;//教师类型的策略实现类teacherGroupLablel implements GroupLabel&#123; //对应教师类型的条件分支里的实现 boolean processBiz(Person pto)&#123; //开关关闭不请求 if(isteacherSwitchClose)&#123; return false; &#125; //请求只有一条记录 if(pto.reqNum==1)&#123; return singleRemoteMarketinvoke(pto);//调用教师数据的点查接口 //请求超过一条 &#125;else if(pto.reqNum&gt;1)&#123; return batchRemoteMarketinvoke(pto);//调用教师数据的批量接口 &#125; &#125; //对应教师类型 String getType()&#123; return \"teacher\"; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://tangmenjue.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Win10系统edge浏览器出现闪退的解决方法","slug":"Win10系统edge浏览器出现闪退的解决方法","date":"2020-03-30T01:18:23.000Z","updated":"2022-10-27T13:29:09.708Z","comments":true,"path":"2020/03/30/Win10系统edge浏览器出现闪退的解决方法/","link":"","permalink":"http://tangmenjue.top/2020/03/30/Win10%E7%B3%BB%E7%BB%9Fedge%E6%B5%8F%E8%A7%88%E5%99%A8%E5%87%BA%E7%8E%B0%E9%97%AA%E9%80%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"Win10系统edge浏览器出现闪退的解决方法 记一个Win10系统edge浏览器出现闪退的解决方法： 第一步： Win+R 呼出运行窗口，并在里面输入 %USERPROFILE%\\AppData\\Local\\Packages,点击确定按钮 这时可以看到打开了一个文件夹，找到 Microsoft.MicrosoftEdge_8wekyb3d8bbwe文件夹， 右键 删除 第二步： 返回桌面，在 搜索框 输入 PowerShell搜索，并在搜索结果中选择 以管理员身份运行 ,划重点 一定要以 管理员身份 运行，如果直接打开出现的后果会在文章最后说明。 第三步： 在打开的Windows PowerShell窗口中输入命令 Get-AppXPackage -ALLUsers -Name Microsoft.MicrosoftEdge | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register\"$($_.InstallLocation)\\AppXManifest.*\" -verbose} 看到下图即成功。 当然，如果没出现黄字的提示，看到下面那行的命令行出来时，关闭Windows PowerShell 窗口后，打开浏览器，出现下图的画面，即表明浏览器闪退问题已解决。 出现报错的情况有： 一、 Get-AppXPackage 拒绝访问 2.Win10 防火墙 没有打开 此时应该检查标题栏中的标题是选择 Windows PowerShell 还是选择管理员：Windows PowerShell。如下图： 若没有管理员的字样，就是原因1，若已经是以管理员身份运行了，则去 控制面板 检查防火墙是否已经打开 检查 防火墙是否已经打开 步骤： 此电脑-右键选择属性-在路径栏点击控制面板 在查找方式处，选择大图标 单击Windows Defender 防火墙，若看到下图的情形，则是没有打开防火墙， 此时点击使用推荐配置即可 二、按照所有步骤都执行了，但是浏览器还是闪退 莫慌，来看看你的命令输入是不是和下图的很像？ 报错语句截图： 看看你输入的双引号是中文的“”，还是英文的””？看看你的命令语句中的黄字部分与解决方法步骤中的黄字部分是否一致？是不是多打了一个空格？ 解决方法：直接解决步骤的第三步复制粘贴命令即可","categories":[{"name":"edge","slug":"edge","permalink":"http://tangmenjue.top/categories/edge/"}],"tags":[{"name":"闪退","slug":"闪退","permalink":"http://tangmenjue.top/tags/%E9%97%AA%E9%80%80/"}]},{"title":"记一次XAMPP的报错实例","slug":"记一次XAMPP的报错实例","date":"2020-02-11T12:36:34.000Z","updated":"2022-11-10T09:27:28.000Z","comments":true,"path":"2020/02/11/记一次XAMPP的报错实例/","link":"","permalink":"http://tangmenjue.top/2020/02/11/%E8%AE%B0%E4%B8%80%E6%AC%A1XAMPP%E7%9A%84%E6%8A%A5%E9%94%99%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"记一次 XAMPP 的报错实例 昨天在用服务器构建网页时，使用到了XAMPP，但在访问服务器本身的IP时，却出现了如下的报错： Uncaught error with message ‘[db.WindConnection.init] SQLSTATE[HY000] [1045] Access denied for user ‘root’@’localhost’ (using password: YES)’ The server encountered an internal error and failed to process your request. Please try again later. If this error is temporary, reloading the page might resolve the problem. If you are able to contact the administrator report this error message(http://www.windframework.com/) 内容大体上是说，权限不够或密码错误，于是我重新看了一下 phpasmin 里的账号密码 图中可以看到 root 的三个账户的密码都是无且授权为是 So后面我根据百度的方法一顿操作 完了发现又多了其他问题，最严重的一个是– Mysql服务无法启动 可以看到下图中XAPMM的Mysql以及无法启动且报一大堆的错 OK,现在开始第一次尝试： 在Mysql目录bin里下找到my.ini文件用记事本打开，查找[mysqld]并在下面增加一行代码innodb_force_recovery =4 结果XAMPP报错： 第二次尝试： 看日志最后几行发现是3306端口被占用，既然3306不能用 那我就换一个端口呗 修改Mysql目录里bin中的my.ini文件的端口如下： 顺便修改了 默认ip地址 ： 结果还是不行： 10+小时过去了，试了各种办法都没法启动Mysql服务，于是，我直接 重装XAMPP 文章后面为XAMPP对Apache的初始化 在XAMPP中选择配置 更改Apache的端口 确保画 蓝圈 的地方是选择Apache的，更改画 黄线 里的端口值（在数字后面加个零即可）。记住原来的两个值，这里我原来的值分别是80和443 然后在XAMPP中找到Apache里conf目录的httpd.conf文件，用记事本打开并查找未更改端口前的第一个数值，将其改成更改后的端口值。如我这里是将80改为800，Ctrl+S保存 再在conf目录里的extra中找到httpd- ssl.conf文件，用记事本打开并查找未更改端口前的第二个数值，将其改成更改后的端口值。如我这里是将443改为4430 ， Ctrl+S 保存 现在回到XAMPP，点击 Apache 中的 Start ,看到Apache和Mysql底色是绿色即完成;","categories":[{"name":"XAMPP","slug":"XAMPP","permalink":"http://tangmenjue.top/categories/XAMPP/"}],"tags":[{"name":"XAMPP","slug":"XAMPP","permalink":"http://tangmenjue.top/tags/XAMPP/"},{"name":"报错","slug":"报错","permalink":"http://tangmenjue.top/tags/%E6%8A%A5%E9%94%99/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-09T14:02:46.000Z","updated":"2022-10-14T15:53:48.974Z","comments":true,"path":"2020/01/09/hello-world/","link":"","permalink":"http://tangmenjue.top/2020/01/09/hello-world/","excerpt":"","text":"Hello World Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new \"My New Post\" More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tangmenjue.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"YAML","slug":"YAML","permalink":"http://tangmenjue.top/categories/YAML/"},{"name":"Redis","slug":"Redis","permalink":"http://tangmenjue.top/categories/Redis/"},{"name":"Docker","slug":"Docker","permalink":"http://tangmenjue.top/categories/Docker/"},{"name":"企业微信","slug":"企业微信","permalink":"http://tangmenjue.top/categories/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1/"},{"name":"应用开发","slug":"应用开发","permalink":"http://tangmenjue.top/categories/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"Linux","permalink":"http://tangmenjue.top/categories/Linux/"},{"name":"操作系统","slug":"操作系统","permalink":"http://tangmenjue.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"前端框架","slug":"前端框架","permalink":"http://tangmenjue.top/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Web框架","slug":"Web框架","permalink":"http://tangmenjue.top/categories/Web%E6%A1%86%E6%9E%B6/"},{"name":"数据库","slug":"数据库","permalink":"http://tangmenjue.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"edge","slug":"edge","permalink":"http://tangmenjue.top/categories/edge/"},{"name":"XAMPP","slug":"XAMPP","permalink":"http://tangmenjue.top/categories/XAMPP/"}],"tags":[{"name":"YAML","slug":"YAML","permalink":"http://tangmenjue.top/tags/YAML/"},{"name":"Redis","slug":"Redis","permalink":"http://tangmenjue.top/tags/Redis/"},{"name":"Docker","slug":"Docker","permalink":"http://tangmenjue.top/tags/Docker/"},{"name":"应用部署","slug":"应用部署","permalink":"http://tangmenjue.top/tags/%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/"},{"name":"企业微信","slug":"企业微信","permalink":"http://tangmenjue.top/tags/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1/"},{"name":"应用开发","slug":"应用开发","permalink":"http://tangmenjue.top/tags/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"CentOS 7","slug":"CentOS-7","permalink":"http://tangmenjue.top/tags/CentOS-7/"},{"name":"Linux","slug":"Linux","permalink":"http://tangmenjue.top/tags/Linux/"},{"name":"网络管理","slug":"网络管理","permalink":"http://tangmenjue.top/tags/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://tangmenjue.top/tags/Vue-js/"},{"name":"前端","slug":"前端","permalink":"http://tangmenjue.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://tangmenjue.top/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://tangmenjue.top/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://tangmenjue.top/tags/HTML/"},{"name":"python","slug":"python","permalink":"http://tangmenjue.top/tags/python/"},{"name":"Flask Web","slug":"Flask-Web","permalink":"http://tangmenjue.top/tags/Flask-Web/"},{"name":"后端","slug":"后端","permalink":"http://tangmenjue.top/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Web框架","slug":"Web框架","permalink":"http://tangmenjue.top/tags/Web%E6%A1%86%E6%9E%B6/"},{"name":"PgSQL","slug":"PgSQL","permalink":"http://tangmenjue.top/tags/PgSQL/"},{"name":"数据库","slug":"数据库","permalink":"http://tangmenjue.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"结构性思维","slug":"结构性思维","permalink":"http://tangmenjue.top/tags/%E7%BB%93%E6%9E%84%E6%80%A7%E6%80%9D%E7%BB%B4/"},{"name":"设计模式","slug":"设计模式","permalink":"http://tangmenjue.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"闪退","slug":"闪退","permalink":"http://tangmenjue.top/tags/%E9%97%AA%E9%80%80/"},{"name":"XAMPP","slug":"XAMPP","permalink":"http://tangmenjue.top/tags/XAMPP/"},{"name":"报错","slug":"报错","permalink":"http://tangmenjue.top/tags/%E6%8A%A5%E9%94%99/"}]}